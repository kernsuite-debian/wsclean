diff --git a/external/aocommon/.clang-format b/external/aocommon/.clang-format
new file mode 100644
index 0000000..67255e6
--- /dev/null
+++ b/external/aocommon/.clang-format
@@ -0,0 +1,157 @@
+---
+Language:        Cpp
+# BasedOnStyle:  Google
+AccessModifierOffset: -1
+AlignAfterOpenBracket: Align
+AlignConsecutiveMacros: false
+AlignConsecutiveAssignments: false
+AlignConsecutiveDeclarations: false
+AlignEscapedNewlines: Left
+AlignOperands:   true
+AlignTrailingComments: true
+AllowAllArgumentsOnNextLine: true
+AllowAllConstructorInitializersOnNextLine: true
+AllowAllParametersOfDeclarationOnNextLine: true
+AllowShortBlocksOnASingleLine: false
+AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: All
+AllowShortLambdasOnASingleLine: All
+AllowShortIfStatementsOnASingleLine: WithoutElse
+AllowShortLoopsOnASingleLine: true
+AlwaysBreakAfterDefinitionReturnType: None
+AlwaysBreakAfterReturnType: None
+AlwaysBreakBeforeMultilineStrings: true
+AlwaysBreakTemplateDeclarations: Yes
+BinPackArguments: true
+BinPackParameters: true
+BraceWrapping:
+  AfterCaseLabel:  false
+  AfterClass:      false
+  AfterControlStatement: false
+  AfterEnum:       false
+  AfterFunction:   false
+  AfterNamespace:  false
+  AfterObjCDeclaration: false
+  AfterStruct:     false
+  AfterUnion:      false
+  AfterExternBlock: false
+  BeforeCatch:     false
+  BeforeElse:      false
+  IndentBraces:    false
+  SplitEmptyFunction: true
+  SplitEmptyRecord: true
+  SplitEmptyNamespace: true
+BreakBeforeBinaryOperators: None
+BreakBeforeBraces: Attach
+BreakBeforeInheritanceComma: false
+BreakInheritanceList: BeforeColon
+BreakBeforeTernaryOperators: true
+BreakConstructorInitializersBeforeComma: false
+BreakConstructorInitializers: BeforeColon
+BreakAfterJavaFieldAnnotations: false
+BreakStringLiterals: true
+ColumnLimit:     80
+CommentPragmas:  '^ IWYU pragma:'
+CompactNamespaces: false
+ConstructorInitializerAllOnOneLineOrOnePerLine: true
+ConstructorInitializerIndentWidth: 4
+ContinuationIndentWidth: 4
+Cpp11BracedListStyle: true
+DerivePointerAlignment: false
+DisableFormat:   false
+ExperimentalAutoDetectBinPacking: false
+FixNamespaceComments: true
+ForEachMacros:
+  - foreach
+  - Q_FOREACH
+  - BOOST_FOREACH
+IncludeBlocks:   Regroup
+IncludeCategories:
+  - Regex:           '^<ext/.*\.h>'
+    Priority:        2
+  - Regex:           '^<.*\.h>'
+    Priority:        1
+  - Regex:           '^<.*'
+    Priority:        2
+  - Regex:           '.*'
+    Priority:        3
+IncludeIsMainRegex: '([-_](test|unittest))?$'
+IndentCaseLabels: true
+IndentPPDirectives: None
+IndentWidth:     2
+IndentWrappedFunctionNames: false
+JavaScriptQuotes: Leave
+JavaScriptWrapImports: true
+KeepEmptyLinesAtTheStartOfBlocks: false
+MacroBlockBegin: ''
+MacroBlockEnd:   ''
+MaxEmptyLinesToKeep: 1
+NamespaceIndentation: None
+ObjCBinPackProtocolList: Never
+ObjCBlockIndentWidth: 2
+ObjCSpaceAfterProperty: false
+ObjCSpaceBeforeProtocolList: true
+PenaltyBreakAssignment: 2
+PenaltyBreakBeforeFirstCallParameter: 1
+PenaltyBreakComment: 300
+PenaltyBreakFirstLessLess: 120
+PenaltyBreakString: 1000
+PenaltyBreakTemplateDeclaration: 10
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 200
+PointerAlignment: Left
+RawStringFormats:
+  - Language:        Cpp
+    Delimiters:
+      - cc
+      - CC
+      - cpp
+      - Cpp
+      - CPP
+      - 'c++'
+      - 'C++'
+    CanonicalDelimiter: ''
+    BasedOnStyle:    google
+  - Language:        TextProto
+    Delimiters:
+      - pb
+      - PB
+      - proto
+      - PROTO
+    EnclosingFunctions:
+      - EqualsProto
+      - EquivToProto
+      - PARSE_PARTIAL_TEXT_PROTO
+      - PARSE_TEST_PROTO
+      - PARSE_TEXT_PROTO
+      - ParseTextOrDie
+      - ParseTextProtoOrDie
+    CanonicalDelimiter: ''
+    BasedOnStyle:    google
+ReflowComments:  true
+SortIncludes:    false
+SortUsingDeclarations: true
+SpaceAfterCStyleCast: false
+SpaceAfterLogicalNot: false
+SpaceAfterTemplateKeyword: true
+SpaceBeforeAssignmentOperators: true
+SpaceBeforeCpp11BracedList: false
+SpaceBeforeCtorInitializerColon: true
+SpaceBeforeInheritanceColon: true
+SpaceBeforeParens: ControlStatements
+SpaceBeforeRangeBasedForLoopColon: true
+SpaceInEmptyParentheses: false
+SpacesBeforeTrailingComments: 2
+SpacesInAngles:  false
+SpacesInContainerLiterals: true
+SpacesInCStyleCastParentheses: false
+SpacesInParentheses: false
+SpacesInSquareBrackets: false
+Standard:        c++11
+StatementMacros:
+  - Q_UNUSED
+  - QT_REQUIRE_VERSION
+TabWidth:        8
+UseTab:          Never
+...
+
diff --git a/external/aocommon/.cmake-format.py b/external/aocommon/.cmake-format.py
new file mode 100644
index 0000000..94457f5
--- /dev/null
+++ b/external/aocommon/.cmake-format.py
@@ -0,0 +1,240 @@
+# ----------------------------------
+# Options affecting listfile parsing
+# ----------------------------------
+with section("parse"):
+
+  # Specify structure for custom cmake functions
+  additional_commands = { 'foo': { 'flags': ['BAR', 'BAZ'],
+             'kwargs': {'DEPENDS': '*', 'HEADERS': '*', 'SOURCES': '*'}}}
+
+  # Override configurations per-command where available
+  override_spec = {}
+
+  # Specify variable tags.
+  vartags = []
+
+  # Specify property tags.
+  proptags = []
+
+# -----------------------------
+# Options affecting formatting.
+# -----------------------------
+with section("format"):
+
+  # Disable formatting entirely, making cmake-format a no-op
+  disable = False
+
+  # How wide to allow formatted cmake files
+  line_width = 80
+
+  # How many spaces to tab for indent
+  tab_size = 2
+
+  # If true, lines are indented using tab characters (utf-8 0x09) instead of
+  # <tab_size> space characters (utf-8 0x20). In cases where the layout would
+  # require a fractional tab character, the behavior of the  fractional
+  # indentation is governed by <fractional_tab_policy>
+  use_tabchars = False
+
+  # If <use_tabchars> is True, then the value of this variable indicates how
+  # fractional indentions are handled during whitespace replacement. If set to
+  # 'use-space', fractional indentation is left as spaces (utf-8 0x20). If set
+  # to `round-up` fractional indentation is replaced with a single tab character
+  # (utf-8 0x09) effectively shifting the column to the next tabstop
+  fractional_tab_policy = 'use-space'
+
+  # If an argument group contains more than this many sub-groups (parg or kwarg
+  # groups) then force it to a vertical layout.
+  max_subgroups_hwrap = 2
+
+  # If a positional argument group contains more than this many arguments, then
+  # force it to a vertical layout.
+  max_pargs_hwrap = 6
+
+  # If a cmdline positional group consumes more than this many lines without
+  # nesting, then invalidate the layout (and nest)
+  max_rows_cmdline = 2
+
+  # If true, separate flow control names from their parentheses with a space
+  separate_ctrl_name_with_space = False
+
+  # If true, separate function names from parentheses with a space
+  separate_fn_name_with_space = False
+
+  # If a statement is wrapped to more than one line, than dangle the closing
+  # parenthesis on its own line.
+  dangle_parens = False
+
+  # If the trailing parenthesis must be 'dangled' on its on line, then align it
+  # to this reference: `prefix`: the start of the statement,  `prefix-indent`:
+  # the start of the statement, plus one indentation  level, `child`: align to
+  # the column of the arguments
+  dangle_align = 'prefix'
+
+  # If the statement spelling length (including space and parenthesis) is
+  # smaller than this amount, then force reject nested layouts.
+  min_prefix_chars = 4
+
+  # If the statement spelling length (including space and parenthesis) is larger
+  # than the tab width by more than this amount, then force reject un-nested
+  # layouts.
+  max_prefix_chars = 10
+
+  # If a candidate layout is wrapped horizontally but it exceeds this many
+  # lines, then reject the layout.
+  max_lines_hwrap = 2
+
+  # What style line endings to use in the output.
+  line_ending = 'unix'
+
+  # Format command names consistently as 'lower' or 'upper' case
+  command_case = 'canonical'
+
+  # Format keywords consistently as 'lower' or 'upper' case
+  keyword_case = 'unchanged'
+
+  # A list of command names which should always be wrapped
+  always_wrap = []
+
+  # If true, the argument lists which are known to be sortable will be sorted
+  # lexicographicall
+  enable_sort = True
+
+  # If true, the parsers may infer whether or not an argument list is sortable
+  # (without annotation).
+  autosort = False
+
+  # By default, if cmake-format cannot successfully fit everything into the
+  # desired linewidth it will apply the last, most agressive attempt that it
+  # made. If this flag is True, however, cmake-format will print error, exit
+  # with non-zero status code, and write-out nothing
+  require_valid_layout = False
+
+  # A dictionary mapping layout nodes to a list of wrap decisions. See the
+  # documentation for more information.
+  layout_passes = {}
+
+# ------------------------------------------------
+# Options affecting comment reflow and formatting.
+# ------------------------------------------------
+with section("markup"):
+
+  # What character to use for bulleted lists
+  bullet_char = '*'
+
+  # What character to use as punctuation after numerals in an enumerated list
+  enum_char = '.'
+
+  # If comment markup is enabled, don't reflow the first comment block in each
+  # listfile. Use this to preserve formatting of your copyright/license
+  # statements.
+  first_comment_is_literal = False
+
+  # If comment markup is enabled, don't reflow any comment block which matches
+  # this (regex) pattern. Default is `None` (disabled).
+  literal_comment_pattern = None
+
+  # Regular expression to match preformat fences in comments default=
+  # ``r'^\s*([`~]{3}[`~]*)(.*)$'``
+  fence_pattern = '^\\s*([`~]{3}[`~]*)(.*)$'
+
+  # Regular expression to match rulers in comments default=
+  # ``r'^\s*[^\w\s]{3}.*[^\w\s]{3}$'``
+  ruler_pattern = '^\\s*[^\\w\\s]{3}.*[^\\w\\s]{3}$'
+
+  # If a comment line matches starts with this pattern then it is explicitly a
+  # trailing comment for the preceeding argument. Default is '#<'
+  explicit_trailing_pattern = '#<'
+
+  # If a comment line starts with at least this many consecutive hash
+  # characters, then don't lstrip() them off. This allows for lazy hash rulers
+  # where the first hash char is not separated by space
+  hashruler_min_length = 10
+
+  # If true, then insert a space between the first hash char and remaining hash
+  # chars in a hash ruler, and normalize its length to fill the column
+  canonicalize_hashrulers = True
+
+  # enable comment markup parsing and reflow
+  enable_markup = False
+
+# ----------------------------
+# Options affecting the linter
+# ----------------------------
+with section("lint"):
+
+  # a list of lint codes to disable
+  disabled_codes = []
+
+  # regular expression pattern describing valid function names
+  function_pattern = '[0-9a-z_]+'
+
+  # regular expression pattern describing valid macro names
+  macro_pattern = '[0-9A-Z_]+'
+
+  # regular expression pattern describing valid names for variables with global
+  # (cache) scope
+  global_var_pattern = '[A-Z][0-9A-Z_]+'
+
+  # regular expression pattern describing valid names for variables with global
+  # scope (but internal semantic)
+  internal_var_pattern = '_[A-Z][0-9A-Z_]+'
+
+  # regular expression pattern describing valid names for variables with local
+  # scope
+  local_var_pattern = '[a-z][a-z0-9_]+'
+
+  # regular expression pattern describing valid names for privatedirectory
+  # variables
+  private_var_pattern = '_[0-9a-z_]+'
+
+  # regular expression pattern describing valid names for public directory
+  # variables
+  public_var_pattern = '[A-Z][0-9A-Z_]+'
+
+  # regular expression pattern describing valid names for function/macro
+  # arguments and loop variables.
+  argument_var_pattern = '[a-z][a-z0-9_]+'
+
+  # regular expression pattern describing valid names for keywords used in
+  # functions or macros
+  keyword_pattern = '[A-Z][0-9A-Z_]+'
+
+  # In the heuristic for C0201, how many conditionals to match within a loop in
+  # before considering the loop a parser.
+  max_conditionals_custom_parser = 2
+
+  # Require at least this many newlines between statements
+  min_statement_spacing = 1
+
+  # Require no more than this many newlines between statements
+  max_statement_spacing = 2
+  max_returns = 6
+  max_branches = 12
+  max_arguments = 5
+  max_localvars = 15
+  max_statements = 50
+
+# -------------------------------
+# Options affecting file encoding
+# -------------------------------
+with section("encode"):
+
+  # If true, emit the unicode byte-order mark (BOM) at the start of the file
+  emit_byteorder_mark = False
+
+  # Specify the encoding of the input file. Defaults to utf-8
+  input_encoding = 'utf-8'
+
+  # Specify the encoding of the output file. Defaults to utf-8. Note that cmake
+  # only claims to support utf-8 so be careful when using anything else
+  output_encoding = 'utf-8'
+
+# -------------------------------------
+# Miscellaneous configurations options.
+# -------------------------------------
+with section("misc"):
+
+  # A dictionary containing any per-command configuration overrides. Currently
+  # only `command_case` is supported.
+  per_command = {}
diff --git a/external/aocommon/.gitignore b/external/aocommon/.gitignore
new file mode 100644
index 0000000..79947ee
--- /dev/null
+++ b/external/aocommon/.gitignore
@@ -0,0 +1,6 @@
+.kateconfig
+.kdev4/
+.vscode/
+*~
+aocommon.kdev4
+build/
diff --git a/external/aocommon/.gitlab-ci.yml b/external/aocommon/.gitlab-ci.yml
new file mode 100644
index 0000000..3e2aa7e
--- /dev/null
+++ b/external/aocommon/.gitlab-ci.yml
@@ -0,0 +1,35 @@
+image: ubuntu:20.04
+
+before_script:
+ - apt-get update -qq
+ - export DEBIAN_FRONTEND=noninteractive && apt-get install -y -qq
+    casacore-data casacore-dev
+    cmake
+    g++
+    git
+    libboost-test-dev
+    libboost-date-time-dev
+    libcfitsio-dev
+    pkg-config
+    python3-pip
+    clang-format-12
+ - pip3 install gcovr cmake-format
+
+format:
+  script:
+    # run-format.sh uses 'clang-format', not 'clang-format-12'.
+    - ln -sf clang-format-12 /usr/bin/clang-format
+    - ./scripts/run-format.sh
+
+aocommon:
+  script:
+    - mkdir build
+    - cd build
+    - cmake -DCMAKE_CXX_FLAGS="-coverage" -DCMAKE_EXE_LINKER_FLAGS="-coverage" ../
+    - make
+    # gcovr to create badge
+    # This also writes the xml file to enable line coverage highlighting in MRs
+    - make coverage
+  artifacts:
+    reports:
+      cobertura: build/coverage.xml
diff --git a/external/aocommon/CMake/CheckBLAS.cmake b/external/aocommon/CMake/CheckBLAS.cmake
new file mode 100644
index 0000000..9b07c54
--- /dev/null
+++ b/external/aocommon/CMake/CheckBLAS.cmake
@@ -0,0 +1,44 @@
+# When calling the function, CMAKE_CURRENT_LIST_DIR is from the caller.
+set(CHECKBLAS_DIR ${CMAKE_CURRENT_LIST_DIR})
+
+# Define a function for testing OpenBLAS compatibility.
+# Arguments:
+# LIBRARIES: All libraries that the application normally links to. The test
+# application dynamically checks if OpenBLAS is linked or not.
+function(check_blas)
+  cmake_parse_arguments(ARG "" "" "LIBRARIES" ${ARGN})
+
+  # Create a list with the locations of all imported libraries.
+  set(LIBRARY_LOCATIONS)
+  foreach(LIB ${ARG_LIBRARIES})
+    if(TARGET ${LIB})
+      # Only add imported non-interface libraries.
+      get_target_property(IMPORTED ${LIB} IMPORTED)
+      get_target_property(TYPE ${LIB} TYPE)
+      if (IMPORTED AND NOT ${TYPE} STREQUAL "INTERFACE_LIBRARY")
+        get_target_property(LOCATION ${LIB} LOCATION)
+        list(APPEND LIBRARY_LOCATIONS ${LOCATION})
+      endif()
+    else()
+      list(APPEND LIBRARY_LOCATIONS ${LIB})
+    endif()
+  endforeach()
+
+  # Run check_openblas_multithreading() from checkblas.h at configure time,
+  # which provides an early warning about a wrong OpenBLAS library.
+  # The application should also call this function at run time, since it
+  # then may use a different OpenBLAS library.
+  try_run(RUN_RESULT COMPILE_RESULT
+          "${CMAKE_CURRENT_BINARY_DIR}" "${CHECKBLAS_DIR}/checkblas.cpp"
+          CMAKE_FLAGS "-DINCLUDE_DIRECTORIES=${CHECKBLAS_DIR}/../include"
+          LINK_LIBRARIES "dl;${LIBRARY_LOCATIONS}"
+          COMPILE_OUTPUT_VARIABLE COMPILE_OUTPUT
+          RUN_OUTPUT_VARIABLE RUN_OUTPUT)
+  if (NOT COMPILE_RESULT)
+    message(FATAL_ERROR "Error compiling BLAS Check! Compile output:\n${COMPILE_OUTPUT}")
+  endif()
+  if (RUN_RESULT)
+    message(FATAL_ERROR "${RUN_OUTPUT}")
+  endif()
+  message(STATUS "BLAS check succeeded.")
+endfunction()
diff --git a/external/aocommon/CMake/FindCFITSIO.cmake b/external/aocommon/CMake/FindCFITSIO.cmake
new file mode 100644
index 0000000..c8c14ae
--- /dev/null
+++ b/external/aocommon/CMake/FindCFITSIO.cmake
@@ -0,0 +1,32 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# - Try to find CFITSIO.
+# Variables used by this module:
+#  CFITSIO_ROOT_DIR     - CFITSIO root directory
+# Variables defined by this module:
+#  CFITSIO_FOUND        - system has CFITSIO
+#  CFITSIO_INCLUDE_DIR  - the CFITSIO include directory (cached)
+#  CFITSIO_INCLUDE_DIRS - the CFITSIO include directories
+#                         (identical to CFITSIO_INCLUDE_DIR)
+#  CFITSIO_LIBRARY      - the CFITSIO library (cached)
+#  CFITSIO_LIBRARIES    - the CFITSIO libraries
+#                         (identical to CFITSIO_LIBRARY)
+
+if(NOT CFITSIO_FOUND)
+
+  find_path(CFITSIO_INCLUDE_DIR fitsio.h
+    HINTS ${CFITSIO_ROOT_DIR} PATH_SUFFIXES include include/cfitsio include/libcfitsio0)
+  find_library(CFITSIO_LIBRARY cfitsio
+    HINTS ${CFITSIO_ROOT_DIR} PATH_SUFFIXES lib)
+  find_library(M_LIBRARY m)
+  mark_as_advanced(CFITSIO_INCLUDE_DIR CFITSIO_LIBRARY M_LIBRARY)
+
+  include(FindPackageHandleStandardArgs)
+  find_package_handle_standard_args(CFITSIO DEFAULT_MSG
+    CFITSIO_LIBRARY M_LIBRARY CFITSIO_INCLUDE_DIR)
+
+  set(CFITSIO_INCLUDE_DIRS ${CFITSIO_INCLUDE_DIR})
+  set(CFITSIO_LIBRARIES ${CFITSIO_LIBRARY} ${M_LIBRARY})
+
+endif(NOT CFITSIO_FOUND)
diff --git a/external/aocommon/CMake/FindCasacore.cmake b/external/aocommon/CMake/FindCasacore.cmake
new file mode 100644
index 0000000..d5255de
--- /dev/null
+++ b/external/aocommon/CMake/FindCasacore.cmake
@@ -0,0 +1,249 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# - Try to find Casacore include dirs and libraries
+# Usage:
+#   find_package(Casacore [REQUIRED] [COMPONENTS components...])
+# Valid components are:
+#   casa, coordinates, derivedmscal, fits, images, lattices,
+#   meas, measures, mirlib, ms, msfits, python, scimath, scimath_f, tables
+#
+# Note that most components are dependent on other (more basic) components.
+# In that case, it suffices to specify the "top-level" components; dependent
+# components will be searched for automatically.
+#
+# The dependency tree can be generated using the script get_casacore_deps.sh.
+# For this, you need to have a complete casacore installation, built with shared
+# libraries, at your disposal.
+#
+# The dependencies in this macro were generated against casacore release 1.7.0.
+#
+# Variables used by this module:
+#  CASACORE_ROOT_DIR         - Casacore root directory.
+#
+# Variables defined by this module:
+#  CASACORE_FOUND            - System has Casacore, which means that the
+#                              include dir was found, as well as all
+#                              libraries specified (not cached)
+#  CASACORE_INCLUDE_DIR      - Casacore include directory (cached)
+#  CASACORE_INCLUDE_DIRS     - Casacore include directories (not cached)
+#                              identical to CASACORE_INCLUDE_DIR
+#  CASACORE_LIBRARIES        - The Casacore libraries (not cached)
+#  CASA_${COMPONENT}_LIBRARY - The absolute path of Casacore library
+#                              "component" (cached)
+#  HAVE_AIPSPP               - True if system has Casacore (cached)
+#                              for backward compatibility with AIPS++
+#  HAVE_CASACORE             - True if system has Casacore (cached)
+#                              identical to CASACORE_FOUND
+#  TAQL_EXECUTABLE           - The absolute path of the TaQL executable
+#                              (cached)
+#
+# ATTENTION: The component names need to be in lower case, just as the
+# casacore library names. However, the CMake variables use all upper case.
+
+# - casacore_resolve_dependencies(_result)
+#
+# Resolve the Casacore library dependencies for the given components.
+# The list of dependent libraries will be returned in the variable result.
+# It is sorted from least dependent to most dependent library, so it can be
+# directly fed to the linker.
+#
+#   Usage: casacore_resolve_dependencies(result components...)
+#
+macro(casacore_resolve_dependencies _result)
+  set(${_result} ${ARGN})
+  set(_index 0)
+  # Do a breadth-first search through the dependency graph; append to the
+  # result list the dependent components for each item in that list.
+  # Duplicates will be removed later.
+  while(1)
+    list(LENGTH ${_result} _length)
+    if(NOT _index LESS _length)
+      break()
+    endif(NOT _index LESS _length)
+    list(GET ${_result} ${_index} item)
+    list(APPEND ${_result} ${Casacore_${item}_DEPENDENCIES})
+    math(EXPR _index "${_index}+1")
+  endwhile(1)
+  # Remove all duplicates in the current result list, while retaining only the
+  # last of each duplicate.
+  list(REVERSE ${_result})
+  list(REMOVE_DUPLICATES ${_result})
+  list(REVERSE ${_result})
+endmacro(casacore_resolve_dependencies _result)
+
+
+# - casacore_find_library(_name)
+#
+# Search for the library ${_name}.
+# If library is found, add it to CASACORE_LIBRARIES; if not, add ${_name}
+# to CASACORE_MISSING_COMPONENTS and set CASACORE_FOUND to false.
+#
+#   Usage: casacore_find_library(name)
+#
+macro(casacore_find_library _name)
+  string(TOUPPER ${_name} _NAME)
+  find_library(${_NAME}_LIBRARY ${_name}
+    HINTS ${CASACORE_ROOT_DIR} PATH_SUFFIXES lib)
+  mark_as_advanced(${_NAME}_LIBRARY)
+  if(${_NAME}_LIBRARY)
+    list(APPEND CASACORE_LIBRARIES ${${_NAME}_LIBRARY})
+  else(${_NAME}_LIBRARY)
+    set(CASACORE_FOUND FALSE)
+    list(APPEND CASACORE_MISSING_COMPONENTS ${_name})
+  endif(${_NAME}_LIBRARY)
+endmacro(casacore_find_library _name)
+
+
+# - casacore_find_package(_name)
+#
+# Search for the package ${_name}.
+# If the package is found, add the contents of ${_name}_INCLUDE_DIRS to
+# CASACORE_INCLUDE_DIRS and ${_name}_LIBRARIES to CASACORE_LIBRARIES.
+#
+# If Casacore itself is required, then, strictly speaking, the packages it
+# requires must be present. However, when linking against static libraries
+# they may not be needed. One can override the REQUIRED setting by switching
+# CASACORE_MAKE_REQUIRED_EXTERNALS_OPTIONAL to ON. Beware that this might cause
+# compile and/or link errors.
+#
+#   Usage: casacore_find_package(name [REQUIRED])
+#
+macro(casacore_find_package _name)
+  if("${ARGN}" MATCHES "^REQUIRED$" AND
+      Casacore_FIND_REQUIRED AND
+      NOT CASACORE_MAKE_REQUIRED_EXTERNALS_OPTIONAL)
+    find_package(${_name} REQUIRED)
+  else()
+    find_package(${_name})
+  endif()
+  if(${_name}_FOUND)
+    list(APPEND CASACORE_INCLUDE_DIRS ${${_name}_INCLUDE_DIRS})
+    list(APPEND CASACORE_LIBRARIES ${${_name}_LIBRARIES})
+  endif(${_name}_FOUND)
+endmacro(casacore_find_package _name)
+
+# Define the Casacore components.
+set(Casacore_components
+  casa
+  coordinates
+  derivedmscal
+  fits
+  images
+  lattices
+  meas
+  measures
+  mirlib
+  ms
+  msfits
+  python
+  scimath
+  scimath_f
+  tables
+)
+
+# Define the Casacore components' inter-dependencies.
+set(Casacore_casa_DEPENDENCIES)
+set(Casacore_coordinates_DEPENDENCIES   fits measures casa)
+set(Casacore_derivedmscal_DEPENDENCIES  ms measures tables casa)
+set(Casacore_fits_DEPENDENCIES          measures tables casa)
+set(Casacore_images_DEPENDENCIES        mirlib lattices coordinates fits measures scimath tables casa)
+set(Casacore_lattices_DEPENDENCIES      tables scimath casa)
+set(Casacore_meas_DEPENDENCIES          measures tables casa)
+set(Casacore_measures_DEPENDENCIES      tables casa)
+set(Casacore_mirlib_DEPENDENCIES)
+set(Casacore_ms_DEPENDENCIES            measures scimath tables casa)
+set(Casacore_msfits_DEPENDENCIES        ms fits measures tables casa)
+set(Casacore_python_DEPENDENCIES        casa)
+set(Casacore_scimath_DEPENDENCIES       scimath_f casa)
+set(Casacore_scimath_f_DEPENDENCIES)
+set(Casacore_tables_DEPENDENCIES        casa)
+
+# Initialize variables.
+set(CASACORE_FOUND FALSE)
+set(CASACORE_DEFINITIONS)
+set(CASACORE_LIBRARIES)
+set(CASACORE_MISSING_COMPONENTS)
+
+# Search for the header file first.
+if(NOT CASACORE_INCLUDE_DIR)
+  find_path(CASACORE_INCLUDE_DIR casacore/casa/aips.h
+    HINTS ${CASACORE_ROOT_DIR} PATH_SUFFIXES include)
+  mark_as_advanced(CASACORE_INCLUDE_DIR)
+endif(NOT CASACORE_INCLUDE_DIR)
+
+# Fallback for systems that have old casacore installed in directory not called 'casacore'
+# This fallback can be removed once we move to casacore 2.0 which always puts headers in 'casacore'
+if(NOT CASACORE_INCLUDE_DIR)
+  find_path(CASACORE_INCLUDE_DIR casa/aips.h
+    HINTS ${CASACORE_ROOT_DIR} PATH_SUFFIXES include)
+  mark_as_advanced(CASACORE_INCLUDE_DIR)
+endif(NOT CASACORE_INCLUDE_DIR)
+
+if(NOT CASACORE_INCLUDE_DIR)
+  set(CASACORE_ERROR_MESSAGE "Casacore: unable to find the header file casa/aips.h.\nPlease set CASACORE_ROOT_DIR to the root directory containing Casacore.")
+else(NOT CASACORE_INCLUDE_DIR)
+  # We've found the header file; let's continue.
+  set(CASACORE_FOUND TRUE)
+  # Note that new Casacore uses #include<casacore/casa/...>, while
+  # LOFAR still uses #include<casa/...>. Hence use both in -I path.
+  set(CASACORE_INCLUDE_DIRS ${CASACORE_INCLUDE_DIR} ${CASACORE_INCLUDE_DIR}/casacore)
+
+  # Search for some often used binaries.
+  find_program(TAQL_EXECUTABLE taql
+    HINTS ${CASACORE_ROOT_DIR}/bin)
+  mark_as_advanced(TAQL_EXECUTABLE)
+
+  # If the user specified components explicity, use that list; otherwise we'll
+  # assume that the user wants to use all components.
+  if(NOT Casacore_FIND_COMPONENTS)
+    set(Casacore_FIND_COMPONENTS ${Casacore_components})
+  endif(NOT Casacore_FIND_COMPONENTS)
+
+  # Get a list of all dependent Casacore libraries that need to be found.
+  casacore_resolve_dependencies(_find_components ${Casacore_FIND_COMPONENTS})
+
+  # Find the library for each component, and handle external dependencies
+  foreach(_comp ${_find_components})
+    casacore_find_library(casa_${_comp})
+    if(${_comp} STREQUAL casa)
+      casacore_find_package(HDF5)
+      casacore_find_library(m)
+      list(APPEND CASACORE_LIBRARIES ${CMAKE_DL_LIBS})
+    elseif(${_comp} STREQUAL coordinates)
+      casacore_find_package(WCSLIB REQUIRED)
+    elseif(${_comp} STREQUAL fits)
+      casacore_find_package(CFITSIO REQUIRED)
+    elseif(${_comp} STREQUAL scimath_f)
+      casacore_find_package(LAPACK REQUIRED)
+    endif(${_comp} STREQUAL casa)
+  endforeach(_comp ${_find_components})
+endif(NOT CASACORE_INCLUDE_DIR)
+
+# Set HAVE_CASACORE; and HAVE_AIPSPP (for backward compatibility with AIPS++).
+if(CASACORE_FOUND)
+  set(HAVE_CASACORE TRUE CACHE INTERNAL "Define if Casacore is installed")
+  set(HAVE_AIPSPP TRUE CACHE INTERNAL "Define if AIPS++/Casacore is installed")
+endif(CASACORE_FOUND)
+
+# Compose diagnostic message if not all necessary components were found.
+if(CASACORE_MISSING_COMPONENTS)
+  set(CASACORE_ERROR_MESSAGE "Casacore: the following components could not be found:\n     ${CASACORE_MISSING_COMPONENTS}")
+endif(CASACORE_MISSING_COMPONENTS)
+
+# Print diagnostics.
+if(CASACORE_FOUND)
+  if(NOT Casacore_FIND_QUIETLY)
+    message(STATUS "Found the following Casacore components: ")
+    foreach(_comp ${_find_components})
+      string(TOUPPER casa_${_comp} _COMP)
+      message(STATUS "  ${_comp}: ${${_COMP}_LIBRARY}")
+    endforeach(_comp ${_find_components})
+  endif(NOT Casacore_FIND_QUIETLY)
+else(CASACORE_FOUND)
+  if(Casacore_FIND_REQUIRED)
+    message(FATAL_ERROR "${CASACORE_ERROR_MESSAGE}")
+  else(Casacore_FIND_REQUIRED)
+    message(STATUS "${CASACORE_ERROR_MESSAGE}")
+  endif(Casacore_FIND_REQUIRED)
+endif(CASACORE_FOUND)
diff --git a/external/aocommon/CMake/checkblas.cpp b/external/aocommon/CMake/checkblas.cpp
new file mode 100644
index 0000000..acc413d
--- /dev/null
+++ b/external/aocommon/CMake/checkblas.cpp
@@ -0,0 +1,13 @@
+#include <aocommon/checkblas.h>
+
+#include <iostream>
+
+int main() {
+  try {
+    check_openblas_multithreading();
+    return 0;
+  } catch (std::runtime_error& e) {
+    std::cout << e.what() << '\n';
+    return 1;
+  }
+}
diff --git a/external/aocommon/CMakeLists.txt b/external/aocommon/CMakeLists.txt
new file mode 100644
index 0000000..40f0ed8
--- /dev/null
+++ b/external/aocommon/CMakeLists.txt
@@ -0,0 +1,94 @@
+cmake_minimum_required(VERSION 2.8.8)
+
+project(aocommon)
+
+include(CheckCXXCompilerFlag)
+check_cxx_compiler_flag("-std=c++17" COMPILER_HAS_CXX17)
+
+set(CMAKE_CXX_FLAGS
+    "${CMAKE_CXX_FLAGS} -Wall -Werror=zero-as-null-pointer-constant -ggdb")
+
+if(COMPILER_HAS_CXX17 AND NOT DISABLE_CXX17)
+  add_compile_options(-std=c++17)
+  add_definitions(-DHAVE_LOGGER)
+else()
+  add_compile_options(-std=c++11)
+  message(
+    WARNING
+      "Selected compiler does not support the C++17 standard. This will disable the Logger class, which requires C++17."
+  )
+endif()
+
+# add target to generate API documentation with Doxygen
+find_package(Threads REQUIRED)
+find_package(Doxygen)
+
+if(DOXYGEN_FOUND)
+  configure_file(${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.in
+                 ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile @ONLY)
+  add_custom_target(
+    doc
+    ${DOXYGEN_EXECUTABLE} ${CMAKE_CURRENT_BINARY_DIR}/Doxyfile
+    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
+    COMMENT "Generating API documentation with Doxygen"
+    VERBATIM)
+endif(DOXYGEN_FOUND)
+
+find_package(
+  Boost
+  COMPONENTS unit_test_framework date_time
+  REQUIRED)
+
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/include)
+
+# Casacore has a separate CMake file in this directory
+set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/CMake)
+set(CASACORE_MAKE_REQUIRED_EXTERNALS_OPTIONAL TRUE)
+find_package(Casacore REQUIRED COMPONENTS casa ms tables measures fits)
+include_directories(SYSTEM ${CASACORE_INCLUDE_DIRS})
+
+find_package(CFITSIO REQUIRED)
+include_directories(SYSTEM ${CFITSIO_INCLUDE_DIR})
+
+add_executable(
+  runtests
+  tests/runtests.cpp
+  tests/tangle.cpp
+  tests/tbanddata.cpp
+  tests/tfits.cpp
+  tests/tfluxdensity.cpp
+  tests/thmatrix4x4.cpp
+  tests/timage.cpp
+  tests/tlane.cpp
+  tests/tlogger.cpp
+  tests/tmatrix2x2.cpp
+  tests/tmatrix2x2diag.cpp
+  tests/tmatrix4x4.cpp
+  tests/tmultibanddata.cpp
+  tests/tparallelfor.cpp
+  tests/tqueue.cpp
+  tests/tradeccoord.cpp
+  tests/tstaticfor.cpp
+  tests/tserialstream.cpp
+  tests/tthreadpool.cpp
+  tests/tthrowruntimeerror.cpp
+  tests/ttransform_if.cpp
+  tests/tuvector.cpp)
+target_link_libraries(
+  runtests ${Boost_UNIT_TEST_FRAMEWORK_LIBRARY} ${Boost_DATE_TIME_LIBRARY}
+  ${CMAKE_THREAD_LIBS_INIT} ${CASACORE_LIBRARIES} ${CFITSIO_LIBRARY})
+
+add_custom_target(execute_runtests_target ALL DEPENDS execute_runtests)
+add_custom_command(
+  OUTPUT execute_runtests
+  COMMAND runtests
+  DEPENDS runtests)
+
+add_custom_target(
+  coverage
+  COMMAND gcovr -r .. -e '.*/tests/.*' -e '.*/CompilerIdCXX/.*'
+  COMMAND gcovr -r .. -e '.*/tests/.*' -e '.*/CompilerIdCXX/.*' --xml >
+          coverage.xml
+  DEPENDS execute_runtests)
+
+message(STATUS "Flags passed to C++ compiler: " ${CMAKE_CXX_FLAGS})
diff --git a/external/aocommon/Doxyfile.in b/external/aocommon/Doxyfile.in
new file mode 100644
index 0000000..0c63338
--- /dev/null
+++ b/external/aocommon/Doxyfile.in
@@ -0,0 +1,2579 @@
+# Doxyfile 1.8.17
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the configuration
+# file that follow. The default is UTF-8 which is also the encoding used for all
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the
+# iconv built into libc) for the transcoding. See
+# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = "AOCommon"
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         =
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          =
+
+# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
+# in the documentation. The maximum height of the logo should not exceed 55
+# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
+# the logo to the output directory.
+
+PROJECT_LOGO           =
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       =
+
+# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = NO
+
+# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
+# characters to appear in the names of generated files. If set to NO, non-ASCII
+# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
+# U+3044.
+# The default value is: NO.
+
+ALLOW_UNICODE_NAMES    = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+# Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = English
+
+# The OUTPUT_TEXT_DIRECTION tag is used to specify the direction in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all generated output in the proper direction.
+# Possible values are: None, LTR, RTL and Context.
+# The default value is: None.
+
+OUTPUT_TEXT_DIRECTION  = None
+
+# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = YES
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        =
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the JAVADOC_BANNER tag is set to YES then doxygen will interpret a line
+# such as
+# /***************
+# as being the beginning of a Javadoc-style comment "banner". If set to NO, the
+# Javadoc-style will behave just like regular comments and it will not be
+# interpreted by doxygen.
+# The default value is: NO.
+
+JAVADOC_BANNER         = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
+# page for each member. If set to NO, the documentation of a member will be part
+# of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:\n"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". You can put \n's in the value part of an alias to insert
+# newlines (in the resulting output). You can put ^^ in the value part of an
+# alias to insert a newline as if a physical newline was in the original file.
+# When you need a literal { or } or , in the value part of an alias you have to
+# escape them by means of a backslash (\), this can lead to conflicts with the
+# commands \{ and \} for these it is advised to use the version @{ and @} or use
+# a double escape (\\{ and \\})
+
+ALIASES                =
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding "class=itcl::class"
+# will allow you to use the command class in the itcl::class meaning.
+
+TCL_SUBST              =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice
+# sources only. Doxygen will then generate output that is more tailored for that
+# language. For instance, namespaces will be presented as modules, types will be
+# separated into more groups, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_SLICE  = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, JavaScript,
+# Csharp (C#), C, C++, D, PHP, md (Markdown), Objective-C, Python, Slice,
+# Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:
+# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser
+# tries to guess whether the code is fixed or free formatted code, this is the
+# default for Fortran type files), VHDL, tcl. For instance to make doxygen treat
+# .inc files as Fortran files (default is PHP), and .f files as C (default is
+# Fortran), use: inc=Fortran f=C.
+#
+# Note: For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen.
+
+EXTENSION_MAPPING      =
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See https://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
+# to that level are automatically included in the table of contents, even if
+# they do not have an id attribute.
+# Note: This feature currently applies only to Markdown headings.
+# Minimum value: 0, maximum value: 99, default value: 5.
+# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.
+
+TOC_INCLUDE_HEADINGS   = 5
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by putting a % sign in front of the word or
+# globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = YES
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# If one adds a struct or class to a group and this option is enabled, then also
+# any nested class or struct is added to the same group. By default this option
+# is disabled and one has to add nested compounds explicitly via \ingroup.
+# The default value is: NO.
+
+GROUP_NESTED_COMPOUNDS = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual
+# methods of a class will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIV_VIRTUAL   = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO,
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. If set to YES, local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO, only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO, these classes will be included in the various overviews. This option
+# has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# declarations. If set to NO, these declarations will be included in the
+# documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO, these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+# names in lower-case letters. If set to YES, upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# (including Cygwin) ands Mac users are advised to set this option to NO.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES, the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
+# append additional text to a page's title, such as Class Reference. If set to
+# YES the compound reference will be hidden.
+# The default value is: NO.
+
+HIDE_COMPOUND_REFERENCE= NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+# grouped member an include statement to the documentation, telling the reader
+# which file to include in order to use the member.
+# The default value is: NO.
+
+SHOW_GROUPED_MEMB_INC  = NO
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order. Note that
+# this will also influence the order of the classes in the class list.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
+# list. This list is created by putting \todo commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
+# list. This list is created by putting \test commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES, the
+# list will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            =
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. See also \cite for info how to create references.
+
+CITE_BIB_FILES         =
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some parameters
+# in a documented function, or documenting parameters that don't exist or using
+# markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO, doxygen will only warn about wrong or incomplete
+# parameter documentation, but not about the absence of documentation. If
+# EXTRACT_ALL is set to YES then this flag will automatically be disabled.
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
+# a warning is encountered.
+# The default value is: NO.
+
+WARN_AS_ERROR          = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = @CMAKE_CURRENT_SOURCE_DIR@/include/aocommon
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see: https://www.gnu.org/software/libiconv/) for the list of
+# possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# read by doxygen.
+#
+# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
+# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
+# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
+# *.m, *.markdown, *.md, *.mm, *.dox (to be provided as doxygen C comment),
+# *.doc (to be provided as doxygen C comment), *.txt (to be provided as doxygen
+# C comment), *.py, *.pyw, *.f90, *.f95, *.f03, *.f08, *.f, *.for, *.tcl, *.vhd,
+# *.vhdl, *.ucf, *.qsf and *.ice.
+
+FILE_PATTERNS          = *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.idl \
+                         *.ddl \
+                         *.odl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.cs \
+                         *.d \
+                         *.php \
+                         *.php4 \
+                         *.php5 \
+                         *.phtml \
+                         *.inc \
+                         *.m \
+                         *.markdown \
+                         *.md \
+                         *.mm \
+                         *.dox \
+                         *.doc \
+                         *.txt \
+                         *.py \
+                         *.pyw \
+                         *.f90 \
+                         *.f95 \
+                         *.f03 \
+                         *.f08 \
+                         *.f \
+                         *.for \
+                         *.tcl \
+                         *.vhd \
+                         *.vhdl \
+                         *.ucf \
+                         *.qsf \
+                         *.ice
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                =
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       = *
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             =
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS =
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE =
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# entity all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see https://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = YES
+
+# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the
+# clang parser (see: http://clang.llvm.org/) for more accurate parsing at the
+# cost of reduced performance. This can be particularly helpful with template
+# rich C++ code for which doxygen's built-in parser lacks the necessary type
+# information.
+# Note: The availability of this option depends on whether or not doxygen was
+# generated with the -Duse_libclang=ON option for CMake.
+# The default value is: NO.
+
+CLANG_ASSISTED_PARSING = NO
+
+# If clang assisted parsing is enabled you can provide the compiler with command
+# line options that you would normally use when invoking the compiler. Note that
+# the include paths will already be set by doxygen for the files and directories
+# specified with INPUT and INCLUDE_PATH.
+# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.
+
+CLANG_OPTIONS          =
+
+# If clang assisted parsing is enabled you can provide the clang parser with the
+# path to the compilation database (see:
+# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) used when the files
+# were built. This is equivalent to specifying the "-p" option to a clang tool,
+# such as clang-check. These options will then be passed to the parser.
+# Note: The availability of this option depends on whether or not doxygen was
+# generated with the -Duse_libclang=ON option for CMake.
+
+CLANG_DATABASE_PATH    =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = YES
+
+# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+# which the alphabetical index list will be split.
+# Minimum value: 1, maximum value: 20, default value: 5.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            =
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        =
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# cascading style sheets that are included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefore more robust against future updates.
+# Doxygen will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list). For an example see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  =
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       =
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the style sheet and background images according to
+# this color. Hue is specified as an angle on a colorwheel, see
+# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use grayscales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to YES can help to show when doxygen was last run and thus if the
+# documentation is up to date.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = NO
+
+# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
+# documentation will contain a main index with vertical navigation menus that
+# are dynamically created via JavaScript. If disabled, the navigation index will
+# consists of multiple levels of tabs that are statically embedded in every HTML
+# page. Disable this option to support browsers that do not have JavaScript,
+# like the Qt help browser.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_MENUS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see: https://developer.apple.com/xcode/), introduced with OSX
+# 10.5 (Leopard). To create a documentation set, doxygen will generate a
+# Makefile in the HTML output directory. Running make will produce the docset in
+# that directory and running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy
+# genXcode/_index.html for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# (see: https://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+# Windows.
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               =
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler (hhc.exe). If non-empty,
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           =
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated
+# (YES) or that it should be included in the master .chm file (NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     =
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated
+# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
+# enables the Previous and Next buttons.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-
+# folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# The QHG_LOCATION tag can be used to specify the location of Qt's
+# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+# generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine-tune the look of the index. As an example, the default style
+# sheet generated by doxygen has an example that shows how to put an image at
+# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+# the same information as the tab index, you could consider setting
+# DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = NO
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANSPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# The FORMULA_MACROFILE can contain LaTeX \newcommand and \renewcommand commands
+# to create new LaTeX commands to be used in formulas as building blocks. See
+# the section "Including formulas" for details.
+
+FORMULA_MACROFILE      =
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# https://www.mathjax.org) which uses client side JavaScript for the rendering
+# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. See the MathJax site (see:
+# http://docs.mathjax.org/en/latest/output.html) for more details.
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility), NativeMML (i.e. MathML) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from https://www.mathjax.org before deployment.
+# The default value is: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        = https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     =
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       =
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using JavaScript. There
+# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
+# setting. When disabled, doxygen will generate a PHP script for searching and
+# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
+# and searching needs to be provided by external tools. See the section
+# "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: https://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: https://xapian.org/). See the section "External Indexing and
+# Searching" for details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       =
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     =
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when not enabling USE_PDFLATEX the default is latex when enabling
+# USE_PDFLATEX the default is pdflatex and when in the later case latex is
+# chosen this is overwritten by pdflatex. For specific output languages the
+# default can have been set differently, this depends on the implementation of
+# the output language.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         =
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# Note: This tag is used in the Makefile / make.bat.
+# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file
+# (.tex).
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to
+# generate index for LaTeX. In case there is no backslash (\) as first character
+# it will be automatically added in the LaTeX code.
+# Note: This tag is used in the generated output file (.tex).
+# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.
+# The default value is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_MAKEINDEX_CMD    = makeindex
+
+# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = a4
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. The package can be specified just
+# by its name or with the correct syntax as to be used with the LaTeX
+# \usepackage command. To get the times font for instance you can specify :
+# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
+# To use the option intlimits with the amsmath package you can specify:
+# EXTRA_PACKAGES=[intlimits]{amsmath}
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+# generated LaTeX document. The header should contain everything until the first
+# chapter. If it is left blank doxygen will generate a standard header. See
+# section "Doxygen usage" for information on how to let doxygen write the
+# default header to a separate file.
+#
+# Note: Only use a user-defined header if you know what you are doing! The
+# following commands have a special meaning inside the header: $title,
+# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
+# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
+# string, for the replacement values of the other commands the user is referred
+# to HTML_HEADER.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           =
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+# generated LaTeX document. The footer should contain everything after the last
+# chapter. If it is left blank doxygen will generate a standard footer. See
+# LATEX_HEADER for more information on how to generate a default footer and what
+# special commands can be used inside the footer.
+#
+# Note: Only use a user-defined footer if you know what you are doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           =
+
+# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# LaTeX style sheets that are included after the standard style sheets created
+# by doxygen. Using this option one can overrule certain style aspects. Doxygen
+# will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list).
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_STYLESHEET =
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+# the PDF file directly from the LaTeX files. Set this option to YES, to get a
+# higher quality PDF documentation.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help. This option is also used
+# when generating formulas in HTML.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = NO
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = NO
+
+# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+# code with syntax highlighting in the LaTeX output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_TIMESTAMP        = NO
+
+# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)
+# path from which the emoji images will be read. If a relative path is entered,
+# it will be relative to the LATEX_OUTPUT directory. If left blank the
+# LATEX_OUTPUT directory will be used.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EMOJI_DIRECTORY  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's
+# configuration file, i.e. a series of assignments. You only have to provide
+# replacements, missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's configuration file. A template extensions file can be
+# generated using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    =
+
+# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
+# with syntax highlighting in the RTF output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_SOURCE_CODE        = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# The MAN_SUBDIR tag determines the name of the directory created within
+# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
+# MAN_EXTENSION with the initial . removed.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_SUBDIR             =
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include
+# namespace members in file scope as well, matching the HTML output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_NS_MEMB_FILE_SCOPE = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
+# program listings (including syntax highlighting and cross-referencing
+# information) to the DOCBOOK output. Note that enabling this will significantly
+# increase the size of the DOCBOOK output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_PROGRAMLISTING = NO
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
+# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures
+# the structure of the code including all documentation. Note that this feature
+# is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO, the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
+# in the source code. If set to NO, only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES, the include files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             =
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all references to function-like macros that are alone on a line, have
+# an all uppercase name, and do not end with a semicolon. Such function macros
+# are typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have a unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
+# the class index. If set to NO, only the inherited external classes will be
+# listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = YES
+
+# You can include diagrams made with dia in doxygen documentation. Doxygen will
+# then run dia to produce the diagram and insert it in the documentation. The
+# DIA_PATH tag allows you to specify the directory where the dia binary resides.
+# If left empty dia is assumed to be found in the default search path.
+
+DIA_PATH               =
+
+# If set to YES the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: YES.
+
+HAVE_DOT               = YES
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font in the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command. Disabling a call graph can be
+# accomplished by means of the command \hidecallgraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command. Disabling a caller graph can be
+# accomplished by means of the command \hidecallergraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. For an explanation of the image formats see the section
+# output formats in the documentation of the dot tool (Graphviz (see:
+# http://www.graphviz.org/)).
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, png:cairo, png:cairo:cairo, png:cairo:gd, png:gd,
+# png:gd:gd, jpg, jpg:cairo, jpg:cairo:gd, jpg:gd, jpg:gd:gd, gif, gif:cairo,
+# gif:cairo:gd, gif:gd, gif:gd:gd, svg, png:gd, png:gd:gd, png:cairo,
+# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
+# png:gdiplus:gdiplus.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               =
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           =
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           =
+
+# The DIAFILE_DIRS tag can be used to specify one or more directories that
+# contain dia files that are included in the documentation (see the \diafile
+# command).
+
+DIAFILE_DIRS           =
+
+# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
+# path where java can find the plantuml.jar file. If left blank, it is assumed
+# PlantUML is not used or called during a preprocessing step. Doxygen will
+# generate a warning when it encounters a \startuml command in this case and
+# will not generate output for the diagram.
+
+PLANTUML_JAR_PATH      =
+
+# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
+# configuration file for plantuml.
+
+PLANTUML_CFG_FILE      =
+
+# When using plantuml, the specified paths are searched for files specified by
+# the !include statement in a plantuml block.
+
+PLANTUML_INCLUDE_PATH  =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
+# files that are used to generate the various graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_CLEANUP            = YES
diff --git a/external/aocommon/LICENSE b/external/aocommon/LICENSE
new file mode 100644
index 0000000..10926e8
--- /dev/null
+++ b/external/aocommon/LICENSE
@@ -0,0 +1,675 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
+
diff --git a/external/aocommon/include/aocommon/banddata.h b/external/aocommon/include/aocommon/banddata.h
new file mode 100644
index 0000000..2e9a200
--- /dev/null
+++ b/external/aocommon/include/aocommon/banddata.h
@@ -0,0 +1,357 @@
+#ifndef AOCOMMON_BANDDATA_H_
+#define AOCOMMON_BANDDATA_H_
+
+#include "uvector.h"
+
+#include <stdexcept>
+
+#include <casacore/ms/MeasurementSets/MeasurementSet.h>
+
+#include <casacore/tables/Tables/ArrayColumn.h>
+#include <casacore/tables/Tables/ScalarColumn.h>
+
+namespace aocommon {
+
+/** Global function that returns the speed of light in meters per second. */
+constexpr static long double c() { return 299792458.0L; }
+
+/** Holds the meta data of a channel. */
+class ChannelInfo {
+ public:
+  /** Construct a channel.
+   * @param frequency Channel frequency in Hz.
+   * @param width Channel width in Hz.
+   */
+  constexpr ChannelInfo(double frequency, double width)
+      : _frequency(frequency), _width(width) {}
+
+  /** Whether the frequency of the lhs is less than that of the rhs.
+   * @param rhs ChannelInfo to compare with.
+   * @returns lhs.Frequency() < rhs.Frequency()
+   */
+  constexpr bool operator<(const ChannelInfo& rhs) const {
+    return _frequency < rhs._frequency;
+  }
+
+  /** Whether the frequency of the lhs is greater than that of the rhs.
+   * @param rhs ChannelInfo to compare with.
+   * @returns lhs.Frequency() > rhs.Frequency()
+   */
+  constexpr bool operator>(const ChannelInfo& rhs) const {
+    return _frequency > rhs._frequency;
+  }
+
+  /** Whether the frequencies of lhs and rhs are the same. The channel width is
+   * ignored.
+   * @param rhs ChannelInfo to compare with
+   * @returns lhs.Frequency() == rhs.Frequency()
+   */
+  constexpr bool operator==(const ChannelInfo& rhs) const {
+    return _frequency == rhs._frequency;
+  }
+
+  /** Frequency of channel in Hz. */
+  constexpr double Frequency() const { return _frequency; }
+  /** Width of channel in Hz. */
+  constexpr double Width() const { return _width; }
+
+ private:
+  double _frequency, _width;
+};
+
+/**
+ * Contains information about a single band ("spectral window").
+ * A band consists of a sequence of contiguous channels.
+ */
+class BandData {
+ public:
+  /** Reverse iterator of frequencies */
+  typedef std::reverse_iterator<double*> reverse_iterator;
+  /** Constant reverse iterator of frequencies. */
+  typedef std::reverse_iterator<const double*> const_reverse_iterator;
+
+  /**
+   * Construct an empty instance.
+   */
+  BandData()
+      : _channelCount(0),
+        _channelFrequencies(),
+        _frequencyStep(0.0),
+        _referenceFrequency(0.0) {}
+
+  /**
+   * Construct an instance from a spectral window table. The spectral window
+   * table can only have a single entry, otherwise an exception is thrown.
+   * @param spwTable The CASA Measurement Set spectral window table.
+   */
+  explicit BandData(const casacore::MSSpectralWindow& spwTable) {
+    if (spwTable.nrow() != 1)
+      throw std::runtime_error("Set should have exactly one spectral window");
+
+    initFromTable(spwTable, 0);
+  }
+
+  /**
+   * Construct an instance from a specified entry of a spectral window table.
+   * @param spwTable The CASA Measurement Set spectral window table.
+   * @param bandIndex The entry index of the spectral window table.
+   */
+  BandData(const casacore::MSSpectralWindow& spwTable, size_t bandIndex) {
+    initFromTable(spwTable, bandIndex);
+  }
+
+  /**
+   * Construct a new instance from a part of another band.
+   * @param source Instance that is partially copied.
+   * @param startChannel Start of range of channels that are copied.
+   * @param endChannel End of range, exclusive.
+   */
+  BandData(const BandData& source, size_t startChannel, size_t endChannel)
+      : _channelCount(endChannel - startChannel),
+        _frequencyStep(source._frequencyStep),
+        _referenceFrequency(source._referenceFrequency) {
+    if (_channelCount == 0) throw std::runtime_error("No channels in set");
+    if (endChannel < startChannel)
+      throw std::runtime_error("Invalid band specification");
+    _channelFrequencies.resize(_channelCount);
+
+    for (size_t index = 0; index != _channelCount; ++index) {
+      _channelFrequencies[index] =
+          source._channelFrequencies[index + startChannel];
+    }
+  }
+
+  /**
+   * Construct a banddata from an array with channel infos.
+   */
+  BandData(const std::vector<ChannelInfo>& channels, double referenceFrequency)
+      : _referenceFrequency(referenceFrequency) {
+    initFromArray(channels);
+  }
+
+  /** Iterator over frequencies, pointing to first channel */
+  double* begin() { return _channelFrequencies.begin(); }
+  /** Iterator over frequencies, pointing past last channel */
+  double* end() { return _channelFrequencies.end(); }
+  /** Constant iterator over frequencies, pointing to first channel */
+  const double* begin() const { return _channelFrequencies.begin(); }
+  /** Constant iterator over frequencies, pointing to last channel */
+  const double* end() const { return _channelFrequencies.end(); }
+
+  /** Reverse iterator over frequencies, pointing to last channel */
+  std::reverse_iterator<double*> rbegin() {
+    return std::reverse_iterator<double*>(end());
+  }
+
+  /** Reverse iterator over frequencies, pointing past first channel */
+  std::reverse_iterator<double*> rend() {
+    return std::reverse_iterator<double*>(begin());
+  }
+
+  /** Constant reverse iterator over frequencies, pointing to last channel */
+  std::reverse_iterator<const double*> rbegin() const {
+    return std::reverse_iterator<const double*>(end());
+  }
+
+  /** Constant reverse iterator over frequencies, pointing past first channel */
+  std::reverse_iterator<const double*> rend() const {
+    return std::reverse_iterator<const double*>(begin());
+  }
+
+  /**
+   * Assign new frequencies to this instance. The reference frequency
+   * remains unmodified.
+   * @param channelCount Number of channels.
+   * @param frequencies Array of @p channelCount doubles containing the channel
+   * frequencies.
+   */
+  void Set(size_t channelCount, const double* frequencies) {
+    _channelCount = channelCount;
+    _channelFrequencies.assign(frequencies, frequencies + channelCount);
+  }
+
+  /** Retrieve number of channels in this band.
+   * @returns Number of channels.
+   */
+  size_t ChannelCount() const { return _channelCount; }
+
+  /** Get the frequency in Hz of a specified channel.
+   * @param channelIndex Zero-indexed channel index.
+   */
+  double ChannelFrequency(size_t channelIndex) const {
+    return _channelFrequencies[channelIndex];
+  }
+
+  /** Get the channelwidth in Hz of a specified channel.
+   * @param channelIndex Zero-indexed channel index.
+   */
+  double ChannelWidth(size_t /*channelIndex*/) const { return _frequencyStep; }
+
+  /** Get information of a specified channel.
+   * @param channelIndex Zero-indexed channel index.
+   */
+  ChannelInfo Channel(size_t channelIndex) const {
+    return ChannelInfo(_channelFrequencies[channelIndex], _frequencyStep);
+  }
+
+  /** Get the wavelength in m of a specified channel.
+   * @param channelIndex Zero-indexed channel index.
+   */
+  double ChannelWavelength(size_t channelIndex) const {
+    return c() / _channelFrequencies[channelIndex];
+  }
+
+  /**
+   * Get the frequency of the last channel.
+   * In case the frequencies are stored in reverse channel order, the frequency
+   * of the first channel is returned.
+   * @returns Highest frequency.
+   */
+  double HighestFrequency() const {
+    return _channelCount == 0               ? 0
+           : lastChannel() > firstChannel() ? lastChannel()
+                                            : firstChannel();
+  }
+
+  /**
+   * Get the frequency of the first channel.
+   * In case the frequencies are stored in reverse channel order, the frequency
+   * of the last channel is returned.
+   * @returns Lowest frequency.
+   */
+  double LowestFrequency() const {
+    return _channelCount == 0
+               ? 0
+               : (firstChannel() < lastChannel() ? firstChannel()
+                                                 : lastChannel());
+  }
+
+  /** Get the centre frequency.
+   * @returns 0.5 * (HighestFrequency + LowestFrequency)
+   */
+  double CentreFrequency() const {
+    return (HighestFrequency() + LowestFrequency()) * 0.5;
+  }
+
+  /**
+   * @brief Get the reference frequency in Hz as stored in the spectral window
+   * table. Can be slightly different from centre frequency.
+   */
+  double ReferenceFrequency() const { return _referenceFrequency; }
+
+  /** Convert a frequency to a wavelength.
+   * @param frequencyHz Frequency in Hz.
+   * @returns Wavelength in m.
+   */
+  static double FrequencyToLambda(double frequencyHz) {
+    return c() / frequencyHz;
+  }
+
+  /** Get the wavelength of the central channel.
+   * @returns Central channel wavelength.
+   */
+  double CentreWavelength() const {
+    return c() / ((HighestFrequency() + LowestFrequency()) * 0.5);
+  }
+
+  /** Get the distance between channels in Hz.
+   * @returns Distance between channels.
+   */
+  double FrequencyStep() const { return _frequencyStep; }
+
+  /** Get the wavelength of the first channel.
+   * @returns longest wavelength. */
+  double LongestWavelength() const {
+    return _channelCount == 0 ? 0 : c() / LowestFrequency();
+  }
+
+  /**
+   * Get the wavelength of the last channel.
+   * @returns smallest wavelength.
+   */
+  double SmallestWavelength() const {
+    return _channelCount == 0 ? 0 : c() / HighestFrequency();
+  }
+
+  /** Get the start of the frequency range covered by this band.
+   * @returns Start of the band in Hz.
+   */
+  double BandStart() const { return LowestFrequency() - FrequencyStep() * 0.5; }
+  /** Get the end of the frequency range covered by this band.
+   * @returns End of the band in Hz. */
+  double BandEnd() const { return HighestFrequency() + FrequencyStep() * 0.5; }
+
+  /** Get the total bandwidth covered by this band.
+   * @returns Bandwidth in Hz. */
+  double Bandwidth() const {
+    return HighestFrequency() - LowestFrequency() + FrequencyStep();
+  }
+
+ private:
+  void initFromTable(const casacore::MSSpectralWindow& spwTable,
+                     size_t bandIndex) {
+    casacore::ScalarColumn<int> numChanCol(
+        spwTable, casacore::MSSpectralWindow::columnName(
+                      casacore::MSSpectralWindowEnums::NUM_CHAN));
+    int temp;
+    numChanCol.get(bandIndex, temp);
+    _channelCount = temp;
+    if (_channelCount == 0) throw std::runtime_error("No channels in set");
+
+    casacore::ArrayColumn<double> chanFreqCol(
+        spwTable, casacore::MSSpectralWindow::columnName(
+                      casacore::MSSpectralWindowEnums::CHAN_FREQ));
+    casacore::ArrayColumn<double> chanWidthCol(
+        spwTable, casacore::MSSpectralWindow::columnName(
+                      casacore::MSSpectralWindowEnums::CHAN_WIDTH));
+    casacore::Array<double> channelFrequencies, channelWidths;
+    chanFreqCol.get(bandIndex, channelFrequencies, true);
+    chanWidthCol.get(bandIndex, channelWidths, true);
+
+    _channelFrequencies.resize(_channelCount);
+    size_t index = 0;
+    for (casacore::Array<double>::const_iterator i = channelFrequencies.begin();
+         i != channelFrequencies.end(); ++i) {
+      _channelFrequencies[index] = *i;
+      ++index;
+    }
+    _frequencyStep = 0.0;
+    index = 0;
+    for (casacore::Array<double>::const_iterator i = channelWidths.begin();
+         i != channelWidths.end(); ++i) {
+      _frequencyStep += *i;
+      ++index;
+    }
+    _frequencyStep /= double(index);
+
+    casacore::ScalarColumn<double> referenceFrequencyColumn(
+        spwTable, casacore::MSSpectralWindow::columnName(
+                      casacore::MSSpectralWindowEnums::REF_FREQUENCY));
+    _referenceFrequency = referenceFrequencyColumn(bandIndex);
+  }
+
+  void initFromArray(const std::vector<ChannelInfo>& channels) {
+    _channelCount = channels.size();
+    _channelFrequencies.resize(_channelCount);
+    size_t index = 0;
+    _frequencyStep = 0.0;
+    for (const ChannelInfo& channel : channels) {
+      _channelFrequencies[index] = channel.Frequency();
+      _frequencyStep += channel.Width();
+      ++index;
+    }
+    _frequencyStep /= double(index);
+  }
+
+  double firstChannel() const { return _channelFrequencies[0]; }
+  double lastChannel() const { return _channelFrequencies[_channelCount - 1]; }
+
+  size_t _channelCount;
+  aocommon::UVector<double> _channelFrequencies;
+  double _frequencyStep;
+  double _referenceFrequency;
+};
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/barrier.h b/external/aocommon/include/aocommon/barrier.h
new file mode 100644
index 0000000..6738307
--- /dev/null
+++ b/external/aocommon/include/aocommon/barrier.h
@@ -0,0 +1,75 @@
+#ifndef AOCOMMON_BARRIER_H_
+#define AOCOMMON_BARRIER_H_
+
+#include <condition_variable>
+#include <functional>
+#include <mutex>
+
+namespace aocommon {
+
+/**
+ * This class is unfortunately necessary because boost::barrier had a
+ * bug in completion functions, and std::barrier is still experimental.
+ */
+class Barrier {
+ public:
+  /**
+   * Construct barrier for n threads without a completion function.
+   * @param n Number of threads to wait for
+   * @param completionFunction void function that is called when all threads
+   * have arrived, just before the threads are released.
+   */
+  Barrier(size_t n)
+      : _n(n), _count(_n), _cycle(0), _completionFunction(&Barrier::nop) {}
+
+  /**
+   * Construct barrier for n threads with the given completion function.
+   * @param n Number of threads to wait for
+   * @param completionFunction void function that is called when all threads
+   * have arrived, just before the threads are released.
+   */
+  Barrier(size_t n, std::function<void()> completionFunction)
+      : _n(n), _count(_n), _cycle(0), _completionFunction(completionFunction) {}
+
+  /**
+   * @brief Move constructor
+   *
+   * count could be checked for != _n to assert no threads
+   * are waiting, but I leave this the responsibility of the caller.
+   */
+  Barrier& operator=(Barrier&& rhs) {
+    _n = rhs._n;
+    _count = _n;
+    _cycle = 0;
+    _completionFunction = rhs._completionFunction;
+    return *this;
+  }
+
+  /**
+   * Wait until all threads are waiting for the barrier.
+   */
+  void wait() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    --_count;
+    if (_count == 0) {
+      ++_cycle;
+      _count = _n;
+      _completionFunction();
+      _condition.notify_all();
+    } else {
+      size_t cycle = _cycle;
+      while (cycle == _cycle) _condition.wait(lock);
+    }
+  }
+
+ private:
+  static void nop() {}
+
+  std::mutex _mutex;
+  std::condition_variable _condition;
+  size_t _n, _count, _cycle;
+  std::function<void()> _completionFunction;
+};
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/checkblas.h b/external/aocommon/include/aocommon/checkblas.h
new file mode 100644
index 0000000..dc0e945
--- /dev/null
+++ b/external/aocommon/include/aocommon/checkblas.h
@@ -0,0 +1,124 @@
+#ifndef AOCOMMON_CHECKBLAS_H_
+#define AOCOMMON_CHECKBLAS_H_
+
+#include <cstdio>
+#include <cstddef>
+#include <dlfcn.h>
+#include <stdexcept>
+#include <string>
+
+/**
+ * Detect if OpenBLAS is linked to the application and determine the version
+ * number.
+ * @return The encoded version number, for example 30712 for version 3.7.12.
+ * @retval -1 If OpenBLAS is not linked.
+ * @retval -2 If the OpenBLAS version could not be determined.
+ */
+inline int get_openblas_version() {
+  // Ask the dynamic linker to lookup the openblas_get_config() function.
+  char* (*openblas_get_config)(void) = reinterpret_cast<char* (*)(void)>(
+      dlsym(RTLD_DEFAULT, "openblas_get_config"));
+  if (!openblas_get_config) return -1;
+
+  // The config should contain a version string like "OpenBLAS 0.3.18"
+  // Old OpenBLAS versions do not have a version in their config.
+  int major = 0;
+  int minor = 0;
+  int patch = 0;
+  const int assigned = std::sscanf(openblas_get_config(), "OpenBLAS %d.%d.%d",
+                                   &major, &minor, &patch);
+  if (assigned != 3) return -2;
+
+  return major * 10000 + minor * 100 + patch;
+}
+
+/**
+ * Checks if the application is dynamically linked to OpenBLAS. If it is,
+ * checks if the OpenBLAS library is properly configured.
+ *
+ * @throws runtime_error When the application is linked to an OpenBLAS library
+ *         that is not supported or incorrectly configured.
+ */
+inline void check_openblas_multithreading() {
+  // Ask the dynamic linker to lookup the openblas_get_parallel() function.
+  int (*openblas_get_parallel)(void) = reinterpret_cast<int (*)(void)>(
+      dlsym(RTLD_DEFAULT, "openblas_get_parallel"));
+  // If the lookup failed, the application does not use OpenBLAS, so there is
+  // no need for further checks.
+  if (!openblas_get_parallel) return;
+
+  const std::string please =
+      "Please use a multi-threaded OpenBLAS version but configure it to use a "
+      "single\n"
+      "thread by setting the OPENBLAS_NUM_THREADS environment variable "
+      "to 1.";
+
+  switch (openblas_get_parallel()) {
+    case 0: {
+      // The executable is linked to a single threaded version of OpenBLAS.
+      const int version = get_openblas_version();
+
+      if (version >= 0 && version < 307) {
+        // Before 0.3.7, OpenBLAS certainly does not support locking.
+        throw std::runtime_error(
+            "This software was linked to a single-threaded version of OpenBLAS "
+            "with a version before 0.3.7, which does not support "
+            "multi-threaded environments.\n" +
+            please);
+      } else {
+        // OpenBLAS may support locking, but typically does not.
+        // Unfortunately there is no means of checking if OpenBLAS supports
+        // locking, so assume that the library is bad.
+        throw std::runtime_error(
+            "This software was linked to a single-threaded version of "
+            "OpenBLAS, which typically does not support multi-threaded "
+            "environments.\n" +
+            please);
+      }
+
+      break;
+    }
+    case 1: {
+      // The executable is linked to a multithreaded version of OpenBLAS.
+      // Read the OPENBLAS_NUM_THREADS environment variable
+      int openblas_num_threads = 0;
+      char* openblas_num_threads_env_var = getenv("OPENBLAS_NUM_THREADS");
+      if (openblas_num_threads_env_var != nullptr) {
+        openblas_num_threads = atoi(openblas_num_threads_env_var);
+      }
+
+      if (openblas_num_threads != 1) {
+        // TODO: Fix the problem by calling openblas_set_num_threads(1),
+        // resetting thread affinity. aocommon::NCPU will then return the
+        // correct value again instead of 1. Then detect whether OpenMP is
+        // used (IDG uses OpenMP) and then somehow reinitialize OpenMP
+        // such that not all its threads are bound to CPU 0. But for now
+        // throw an error and ask the user to fix the problem
+
+        throw std::runtime_error(
+            "This software was linked to a multi-threaded version of OpenBLAS. "
+            "OpenBLAS multi-threading interferes with other multi-threaded "
+            "parts of the code, which has a severe impact on performance. "
+            "Please disable OpenBLAS multi-threading by setting the "
+            "environment variable OPENBLAS_NUM_THREADS to 1. For csh like "
+            "shells, use:  setenv OPENBLAS_NUM_THREADS 1 For bash like shells, "
+            "use: export OPENBLAS_NUM_THREADS=1");
+      }
+      break;
+    }
+    case 2:
+      throw std::runtime_error(
+          "This software was linked to an OpenMP version of OpenBLAS, which is "
+          "not supported.\n" +
+          please);
+      break;
+    default:
+      throw std::runtime_error(
+          "This software was linked to an OpenBLAS version with an unknown "
+          "multi-threading mode, which is not supported.\n" +
+          please);
+      break;
+  }
+}
+
+#endif  // AOCOMMON_CHECKBLAS_H
diff --git a/external/aocommon/include/aocommon/cloned_ptr.h b/external/aocommon/include/aocommon/cloned_ptr.h
new file mode 100644
index 0000000..d8ccb56
--- /dev/null
+++ b/external/aocommon/include/aocommon/cloned_ptr.h
@@ -0,0 +1,53 @@
+#ifndef AOCOMMON_CLONED_PTR_H_
+#define AOCOMMON_CLONED_PTR_H_
+
+#include <cstddef>
+#include <memory>
+
+namespace aocommon {
+
+template <typename T>
+class cloned_ptr {
+ public:
+  cloned_ptr() noexcept {}
+  cloned_ptr(std::nullptr_t) noexcept {}
+  cloned_ptr(T* object) noexcept : _ptr(object) {}
+  cloned_ptr(const cloned_ptr<T>& other)
+      : _ptr(other._ptr == nullptr ? nullptr : new T(*other._ptr)) {}
+  cloned_ptr(cloned_ptr<T>&& other) noexcept : _ptr(std::move(other._ptr)) {}
+
+  cloned_ptr<T>& operator=(std::nullptr_t) noexcept { _ptr.reset(); }
+  cloned_ptr<T>& operator=(const cloned_ptr<T>& other) {
+    _ptr.reset(other._ptr == nullptr ? nullptr : new T(*other._ptr));
+  }
+  cloned_ptr<T>& operator=(cloned_ptr<T>&& other) noexcept {
+    _ptr = std::move(other._ptr);
+  }
+  void reset() noexcept { _ptr.reset(); }
+  void reset(T* object) noexcept { _ptr.reset(object); }
+
+  T& operator*() const noexcept { return *_ptr; }
+  T* operator->() const noexcept { return _ptr.get(); }
+  T* get() const { return _ptr.get(); }
+
+  bool operator==(std::nullptr_t) const noexcept { return _ptr == nullptr; }
+  bool operator==(const std::unique_ptr<T>& rhs) const noexcept {
+    return _ptr == rhs;
+  }
+  bool operator==(const cloned_ptr<T>& rhs) const noexcept {
+    return _ptr == rhs._ptr;
+  }
+  void swap(cloned_ptr<T>& other) noexcept { std::swap(_ptr, other._ptr); }
+
+ private:
+  std::unique_ptr<T> _ptr;
+};
+
+template <typename T>
+void swap(cloned_ptr<T>& left, cloned_ptr<T>& right) {
+  left.swap(right);
+}
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/fits/fitsbase.h b/external/aocommon/include/aocommon/fits/fitsbase.h
new file mode 100644
index 0000000..a68870c
--- /dev/null
+++ b/external/aocommon/include/aocommon/fits/fitsbase.h
@@ -0,0 +1,67 @@
+#ifndef AOCOMMON_FITS_FITSBASE_H_
+#define AOCOMMON_FITS_FITSBASE_H_
+
+#include <fitsio.h>
+
+#include <sstream>
+#include <stdexcept>
+#include <string>
+
+namespace aocommon {
+
+/// Base class for reading and writing fits files.
+/// Requires the fitsio library.
+class FitsBase {
+ protected:
+  static void checkStatus(int status, const std::string& filename) {
+    if (status) {
+      /* fits_get_errstatus returns at most 30 characters */
+      char err_text[31];
+      fits_get_errstatus(status, err_text);
+      char err_msg[81];
+      std::stringstream errMsg;
+      errMsg << "CFITSIO reported error when performing IO on file '"
+             << filename << "':" << err_text << " (";
+      while (fits_read_errmsg(err_msg)) errMsg << err_msg;
+      errMsg << ')';
+      throw std::runtime_error(errMsg.str());
+    }
+  }
+  static void checkStatus(int status, const std::string& filename,
+                          const std::string& operation) {
+    if (status) {
+      /* fits_get_errstatus returns at most 30 characters */
+      char err_text[31];
+      fits_get_errstatus(status, err_text);
+      char err_msg[81];
+      std::stringstream errMsg;
+      errMsg << "During operation " << operation
+             << ", CFITSIO reported error when performing IO on file '"
+             << filename << "': " << err_text << " (";
+      while (fits_read_errmsg(err_msg)) errMsg << err_msg;
+      errMsg << ')';
+      throw std::runtime_error(errMsg.str());
+    }
+  }
+
+ public:
+  enum Unit { JanskyPerBeam, JanskyPerPixel, Jansky, Kelvin, MilliKelvin };
+  static const char* UnitName(Unit unit) {
+    switch (unit) {
+      case JanskyPerBeam:
+        return "Jansky/beam";
+      case JanskyPerPixel:
+        return "Jansky/pixel";
+      case Jansky:
+        return "Jansky";
+      case Kelvin:
+        return "Kelvin";
+      case MilliKelvin:
+        return "Milli-Kelvin";
+    }
+    return "";
+  }
+};
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/fits/fitsreader.h b/external/aocommon/include/aocommon/fits/fitsreader.h
new file mode 100644
index 0000000..1513707
--- /dev/null
+++ b/external/aocommon/include/aocommon/fits/fitsreader.h
@@ -0,0 +1,482 @@
+#ifndef AOCOMMON_FITS_FITSREADER_H_
+#define AOCOMMON_FITS_FITSREADER_H_
+
+#include <string>
+#include <vector>
+#include <stdexcept>
+#include <sstream>
+#include <cmath>
+
+#include <fitsio.h>
+
+#include "fitsbase.h"
+#include "../polarization.h"
+
+#include <casacore/fits/FITS/FITSDateUtil.h>
+#include <casacore/casa/Quanta/MVTime.h>
+#include <casacore/measures/Measures/MeasConvert.h>
+
+namespace aocommon {
+
+/// Requires the fitsio library.
+class FitsReader : public FitsBase {
+ public:
+  explicit FitsReader(const std::string& filename)
+      : FitsReader(filename, true, false) {}
+  explicit FitsReader(const std::string& filename, bool checkCType,
+                      bool allowMultipleImages = false)
+      : _meta(filename, checkCType, allowMultipleImages) {
+    initialize();
+  }
+  FitsReader(const FitsReader& source)
+      : _fitsPtr(nullptr), _meta(source._meta) {
+    int status = 0;
+    fits_open_file(&_fitsPtr, _meta.filename.c_str(), READONLY, &status);
+    checkStatus(status, _meta.filename);
+
+    // Move to first HDU
+    int hduType;
+    fits_movabs_hdu(_fitsPtr, 1, &hduType, &status);
+    checkStatus(status, _meta.filename);
+    if (hduType != IMAGE_HDU)
+      throw std::runtime_error("First HDU is not an image");
+  }
+  FitsReader(FitsReader&& source)
+      : _fitsPtr(source._fitsPtr), _meta(std::move(source._meta)) {
+    source._fitsPtr = nullptr;
+  }
+  ~FitsReader() {
+    if (_fitsPtr != nullptr) {
+      int status = 0;
+      fits_close_file(_fitsPtr, &status);
+    }
+  }
+
+  FitsReader& operator=(const FitsReader& rhs) {
+    if (_fitsPtr != nullptr) {
+      int status = 0;
+      fits_close_file(_fitsPtr, &status);
+      checkStatus(status, _meta.filename);
+    }
+
+    if (rhs._fitsPtr != nullptr) {
+      int status = 0;
+      fits_open_file(&_fitsPtr, _meta.filename.c_str(), READONLY, &status);
+      checkStatus(status, _meta.filename);
+
+      // Move to first HDU
+      int hduType;
+      fits_movabs_hdu(_fitsPtr, 1, &hduType, &status);
+      checkStatus(status, _meta.filename);
+      if (hduType != IMAGE_HDU)
+        throw std::runtime_error("First HDU is not an image");
+    }
+
+    return *this;
+  }
+  FitsReader& operator=(FitsReader&& rhs) {
+    if (_fitsPtr != nullptr) {
+      int status = 0;
+      fits_close_file(_fitsPtr, &status);
+      checkStatus(status, _meta.filename);
+    }
+    _meta = std::move(rhs._meta);
+    _fitsPtr = rhs._fitsPtr;
+    rhs._fitsPtr = nullptr;
+
+    return *this;
+  }
+
+  // template void ReadIndex(float* image, size_t index);
+  // template void ReadIndex(double* image, size_t index);
+
+  template <typename NumType>
+  void ReadIndex(NumType* image, size_t index) {
+    int status = 0;
+    int naxis = 0;
+    fits_get_img_dim(_fitsPtr, &naxis, &status);
+    checkStatus(status, _meta.filename);
+    std::vector<long> firstPixel(naxis);
+    for (int i = 0; i != naxis; ++i) firstPixel[i] = 1;
+    if (naxis > 2) firstPixel[2] = index + 1;
+
+    if (sizeof(NumType) == 8)
+      fits_read_pix(_fitsPtr, TDOUBLE, &firstPixel[0],
+                    _meta.imgWidth * _meta.imgHeight, nullptr, image, nullptr,
+                    &status);
+    else if (sizeof(NumType) == 4)
+      fits_read_pix(_fitsPtr, TFLOAT, &firstPixel[0],
+                    _meta.imgWidth * _meta.imgHeight, nullptr, image, nullptr,
+                    &status);
+    else
+      throw std::runtime_error("sizeof(NumType)!=8 || 4 not implemented");
+    checkStatus(status, _meta.filename);
+  }
+
+  template <typename NumType>
+  void Read(NumType* image) {
+    ReadIndex(image, 0);
+  }
+
+  size_t ImageWidth() const { return _meta.imgWidth; }
+  size_t ImageHeight() const { return _meta.imgHeight; }
+
+  double PhaseCentreRA() const { return _meta.phaseCentreRA; }
+  double PhaseCentreDec() const { return _meta.phaseCentreDec; }
+
+  double PixelSizeX() const { return _meta.pixelSizeX; }
+  double PixelSizeY() const { return _meta.pixelSizeY; }
+
+  double PhaseCentreDL() const { return _meta.phaseCentreDL; }
+  double PhaseCentreDM() const { return _meta.phaseCentreDM; }
+
+  double Frequency() const { return _meta.frequency; }
+  double Bandwidth() const { return _meta.bandwidth; }
+
+  double DateObs() const { return _meta.dateObs; }
+  aocommon::PolarizationEnum Polarization() const { return _meta.polarization; }
+
+  FitsBase::Unit Unit() const { return _meta.unit; }
+
+  bool HasBeam() const { return _meta.hasBeam; }
+  double BeamMajorAxisRad() const { return _meta.beamMajorAxisRad; }
+  double BeamMinorAxisRad() const { return _meta.beamMinorAxisRad; }
+  double BeamPositionAngle() const { return _meta.beamPositionAngle; }
+
+  const std::string& TelescopeName() const { return _meta.telescopeName; }
+  const std::string& Observer() const { return _meta.observer; }
+  const std::string& ObjectName() const { return _meta.objectName; }
+
+  const std::string& Origin() const { return _meta.origin; }
+  const std::string& OriginComment() const { return _meta.originComment; }
+
+  const std::vector<std::string>& History() const { return _meta.history; }
+
+  bool ReadDoubleKeyIfExists(const char* key, double& dest) {
+    int status = 0;
+    double doubleValue;
+    fits_read_key(_fitsPtr, TDOUBLE, key, &doubleValue, nullptr, &status);
+    if (status == 0) dest = doubleValue;
+    return status == 0;
+  }
+  bool ReadStringKeyIfExists(const char* key, std::string& dest) {
+    std::string c;
+    return ReadStringKeyIfExists(key, dest, c);
+  }
+  bool ReadStringKeyIfExists(const char* key, std::string& value,
+                             std::string& comment) {
+    int status = 0;
+    char valueStr[256], commentStr[256];
+    fits_read_key(_fitsPtr, TSTRING, key, valueStr, commentStr, &status);
+    if (status == 0) {
+      value = valueStr;
+      comment = commentStr;
+    }
+    return status == 0;
+  }
+  bool ReadFloatKeyIfExists(const char* key, float& dest) {
+    int status = 0;
+    float floatValue;
+    fits_read_key(_fitsPtr, TFLOAT, key, &floatValue, nullptr, &status);
+    if (status == 0) dest = floatValue;
+    return status == 0;
+  }
+
+  static double ParseFitsDateToMJD(const char* valueStr) {
+    casacore::MVTime time;
+    casacore::MEpoch::Types systypes;
+    bool parseSuccess =
+        casacore::FITSDateUtil::fromFITS(time, systypes, valueStr, "UTC");
+    if (!parseSuccess)
+      throw std::runtime_error(std::string("Could not parse FITS date: ") +
+                               valueStr);
+    casacore::MEpoch epoch(time.get(), systypes);
+    return epoch.getValue().get();
+  }
+
+  const std::string& Filename() const { return _meta.filename; }
+
+  fitsfile* FitsHandle() const { return _fitsPtr; }
+
+  size_t NMatrixElements() const { return _meta.nMatrixElements; }
+  size_t NFrequencies() const { return _meta.nFrequencies; }
+  size_t NAntennas() const { return _meta.nAntennas; }
+  size_t NTimesteps() const { return _meta.nTimesteps; }
+
+  double TimeDimensionStart() const { return _meta.timeDimensionStart; }
+  double TimeDimensionIncr() const { return _meta.timeDimensionIncr; }
+
+  double FrequencyDimensionStart() const { return _meta.frequency; }
+  double FrequencyDimensionIncr() const { return _meta.bandwidth; }
+
+  double ReadDoubleKey(const char* key) {
+    int status = 0;
+    double value;
+    fits_read_key(_fitsPtr, TDOUBLE, key, &value, nullptr, &status);
+    checkStatus(status, _meta.filename, std::string("Read float key ") + key);
+    return value;
+  }
+
+ private:
+  void readHistory() {
+    int status = 0;
+    int npos, moreKeys;
+    fits_get_hdrspace(_fitsPtr, &npos, &moreKeys, &status);
+    checkStatus(status, _meta.filename);
+    char keyCard[256];
+    for (int pos = 1; pos <= npos; ++pos) {
+      fits_read_record(_fitsPtr, pos, keyCard, &status);
+      keyCard[7] = 0;
+      if (std::string("HISTORY") == keyCard) {
+        _meta.history.push_back(&keyCard[8]);
+      }
+    }
+  }
+  bool readDateKeyIfExists(const char* key, double& dest) {
+    int status = 0;
+    char keyStr[256];
+    fits_read_key(_fitsPtr, TSTRING, key, keyStr, nullptr, &status);
+    if (status == 0) {
+      dest = FitsReader::ParseFitsDateToMJD(keyStr);
+      return true;
+    } else
+      return false;
+  }
+
+  void initialize() {
+    _meta.nMatrixElements = 1;
+    _meta.nFrequencies = 1;
+    _meta.nAntennas = 1;
+    _meta.nTimesteps = 1;
+    _meta.phaseCentreRA = 0.0;
+    _meta.pixelSizeX = 0.0;
+    _meta.phaseCentreDec = 0.0;
+    _meta.pixelSizeY = 0.0;
+    _meta.dateObs = 0.0;
+    _meta.frequency = 0.0;
+    _meta.bandwidth = 0.0;
+    _meta.polarization = aocommon::Polarization::StokesI;
+    _meta.unit = JanskyPerBeam;
+
+    int status = 0;
+    fits_open_file(&_fitsPtr, _meta.filename.c_str(), READONLY, &status);
+    checkStatus(status, _meta.filename);
+
+    // Move to first HDU
+    int hduType;
+    fits_movabs_hdu(_fitsPtr, 1, &hduType, &status);
+    checkStatus(status, _meta.filename);
+    if (hduType != IMAGE_HDU)
+      throw std::runtime_error("First HDU is not an image");
+
+    int naxis = 0;
+    fits_get_img_dim(_fitsPtr, &naxis, &status);
+    checkStatus(status, _meta.filename);
+    if (naxis < 2) throw std::runtime_error("NAxis in image < 2");
+
+    std::vector<long> naxes(naxis);
+    fits_get_img_size(_fitsPtr, naxis, &naxes[0], &status);
+    checkStatus(status, _meta.filename);
+
+    _meta.imgWidth = naxes[0];
+    _meta.imgHeight = naxes[1];
+
+    // There are fits files that say naxis=2 but then still define
+    // the third and fourth axes, so we always continue reading
+    // at least 4 axes:
+    if (naxis < 4) {
+      naxis = 4;
+      while (naxes.size() < 4) naxes.emplace_back(1);
+    }
+
+    std::string tmp;
+    for (int i = 2; i != naxis; ++i) {
+      std::ostringstream name;
+      name << "CTYPE" << (i + 1);
+      if (ReadStringKeyIfExists(name.str().c_str(), tmp)) {
+        std::ostringstream crval, cdelt;
+        crval << "CRVAL" << (i + 1);
+        cdelt << "CDELT" << (i + 1);
+        if (tmp == "FREQ" || tmp == "VRAD" || tmp == "FREQ-OBS") {
+          _meta.nFrequencies = naxes[i];
+          _meta.frequency = ReadDoubleKey(crval.str().c_str());
+          _meta.bandwidth = ReadDoubleKey(cdelt.str().c_str());
+        } else if (tmp == "ANTENNA")
+          _meta.nAntennas = naxes[i];
+        else if (tmp == "TIME") {
+          _meta.nTimesteps = naxes[i];
+          _meta.timeDimensionStart = ReadDoubleKey(crval.str().c_str());
+          _meta.timeDimensionIncr = ReadDoubleKey(cdelt.str().c_str());
+        } else if (tmp == "STOKES") {
+          double val = ReadDoubleKey(crval.str().c_str());
+          switch (int(val)) {
+            default:
+              throw std::runtime_error(
+                  "Unknown polarization specified in fits file");
+            case 1:
+              _meta.polarization = aocommon::Polarization::StokesI;
+              break;
+            case 2:
+              _meta.polarization = aocommon::Polarization::StokesQ;
+              break;
+            case 3:
+              _meta.polarization = aocommon::Polarization::StokesU;
+              break;
+            case 4:
+              _meta.polarization = aocommon::Polarization::StokesV;
+              break;
+            case -1:
+              _meta.polarization = aocommon::Polarization::RR;
+              break;
+            case -2:
+              _meta.polarization = aocommon::Polarization::LL;
+              break;
+            case -3:
+              _meta.polarization = aocommon::Polarization::RL;
+              break;
+            case -4:
+              _meta.polarization = aocommon::Polarization::LR;
+              break;
+            case -5:
+              _meta.polarization = aocommon::Polarization::XX;
+              break;
+            case -6:
+              _meta.polarization = aocommon::Polarization::YY;
+              break;
+            case -7:
+              _meta.polarization = aocommon::Polarization::XY;
+              break;
+            case -8:
+              _meta.polarization = aocommon::Polarization::YX;
+              break;
+          }
+          if (naxes[i] != 1 && !_meta.allowMultipleImages)
+            throw std::runtime_error(
+                "Multiple polarizations given in fits file");
+        } else if (tmp == "MATRIX") {
+          _meta.nMatrixElements = naxes[i];
+        } else if (naxes[i] != 1)
+          throw std::runtime_error("Multiple images given in fits file");
+      }
+    }
+
+    if (_meta.nMatrixElements != 1 && !_meta.allowMultipleImages)
+      throw std::runtime_error("Multiple matrix elements given in fits file");
+    if (_meta.nFrequencies != 1 && !_meta.allowMultipleImages)
+      throw std::runtime_error("Multiple frequencies given in fits file");
+    if (_meta.nAntennas != 1 && !_meta.allowMultipleImages)
+      throw std::runtime_error("Multiple antennas given in fits file");
+    if (_meta.nTimesteps != 1 && !_meta.allowMultipleImages)
+      throw std::runtime_error("Multiple timesteps given in fits file");
+
+    double bScale = 1.0, bZero = 0.0, equinox = 2000.0;
+    ReadDoubleKeyIfExists("BSCALE", bScale);
+    ReadDoubleKeyIfExists("BZERO", bZero);
+    ReadDoubleKeyIfExists("EQUINOX", equinox);
+    if (bScale != 1.0) throw std::runtime_error("Invalid value for BSCALE");
+    if (bZero != 0.0) throw std::runtime_error("Invalid value for BZERO");
+    if (equinox != 2000.0) {
+      std::string str;
+      ReadStringKeyIfExists("EQUINOX", str);
+      throw std::runtime_error("Invalid value for EQUINOX: " + str);
+    }
+
+    if (ReadStringKeyIfExists("CTYPE1", tmp) && tmp != "RA---SIN" &&
+        _meta.checkCType)
+      throw std::runtime_error("Invalid value for CTYPE1");
+
+    ReadDoubleKeyIfExists("CRVAL1", _meta.phaseCentreRA);
+    _meta.phaseCentreRA *= M_PI / 180.0;
+    ReadDoubleKeyIfExists("CDELT1", _meta.pixelSizeX);
+    _meta.pixelSizeX *= -M_PI / 180.0;
+    if (ReadStringKeyIfExists("CUNIT1", tmp) && tmp != "deg" &&
+        _meta.checkCType)
+      throw std::runtime_error("Invalid value for CUNIT1");
+    double centrePixelX = 0.0;
+    if (ReadDoubleKeyIfExists("CRPIX1", centrePixelX))
+      _meta.phaseCentreDL =
+          (centrePixelX - ((_meta.imgWidth / 2.0) + 1.0)) * _meta.pixelSizeX;
+    else
+      _meta.phaseCentreDL = 0.0;
+
+    if (ReadStringKeyIfExists("CTYPE2", tmp) && tmp != "DEC--SIN" &&
+        _meta.checkCType)
+      throw std::runtime_error("Invalid value for CTYPE2");
+    ReadDoubleKeyIfExists("CRVAL2", _meta.phaseCentreDec);
+    _meta.phaseCentreDec *= M_PI / 180.0;
+    ReadDoubleKeyIfExists("CDELT2", _meta.pixelSizeY);
+    _meta.pixelSizeY *= M_PI / 180.0;
+    if (ReadStringKeyIfExists("CUNIT2", tmp) && tmp != "deg" &&
+        _meta.checkCType)
+      throw std::runtime_error("Invalid value for CUNIT2");
+    double centrePixelY = 0.0;
+    if (ReadDoubleKeyIfExists("CRPIX2", centrePixelY))
+      _meta.phaseCentreDM =
+          ((_meta.imgHeight / 2.0) + 1.0 - centrePixelY) * _meta.pixelSizeY;
+    else
+      _meta.phaseCentreDM = 0.0;
+
+    readDateKeyIfExists("DATE-OBS", _meta.dateObs);
+
+    double bMaj = 0.0, bMin = 0.0, bPa = 0.0;
+    if (ReadDoubleKeyIfExists("BMAJ", bMaj) &&
+        ReadDoubleKeyIfExists("BMIN", bMin) &&
+        ReadDoubleKeyIfExists("BPA", bPa)) {
+      _meta.hasBeam = true;
+      _meta.beamMajorAxisRad = bMaj * (M_PI / 180.0);
+      _meta.beamMinorAxisRad = bMin * (M_PI / 180.0);
+      _meta.beamPositionAngle = bPa * (M_PI / 180.0);
+    } else {
+      _meta.hasBeam = false;
+      _meta.beamMajorAxisRad = 0.0;
+      _meta.beamMinorAxisRad = 0.0;
+      _meta.beamPositionAngle = 0.0;
+    }
+
+    _meta.telescopeName = std::string();
+    ReadStringKeyIfExists("TELESCOP", _meta.telescopeName);
+    _meta.observer = std::string();
+    ReadStringKeyIfExists("OBSERVER", _meta.observer);
+    _meta.objectName = std::string();
+    ReadStringKeyIfExists("OBJECT", _meta.objectName);
+
+    _meta.origin = std::string();
+    _meta.originComment = std::string();
+    ReadStringKeyIfExists("ORIGIN", _meta.origin, _meta.originComment);
+
+    _meta.history.clear();
+    readHistory();
+  }
+
+  fitsfile* _fitsPtr;
+
+  struct MetaData {
+    MetaData(const std::string& filename_, bool checkCType_,
+             bool allowMultipleImages_)
+        : filename(filename_),
+          hasBeam(false),
+          checkCType(checkCType_),
+          allowMultipleImages(allowMultipleImages_) {}
+    std::string filename;
+    size_t imgWidth, imgHeight;
+    size_t nMatrixElements, nAntennas, nFrequencies, nTimesteps;
+    double phaseCentreRA, phaseCentreDec;
+    double pixelSizeX, pixelSizeY;
+    double phaseCentreDL, phaseCentreDM;
+    double frequency, bandwidth, dateObs;
+    bool hasBeam;
+    double beamMajorAxisRad, beamMinorAxisRad, beamPositionAngle;
+    double timeDimensionStart, timeDimensionIncr;
+
+    aocommon::PolarizationEnum polarization;
+    FitsBase::Unit unit;
+    std::string telescopeName, observer, objectName;
+    std::string origin, originComment;
+    std::vector<std::string> history;
+
+    bool checkCType, allowMultipleImages;
+  } _meta;
+};
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/fits/fitswriter.h b/external/aocommon/include/aocommon/fits/fitswriter.h
new file mode 100644
index 0000000..851b0c7
--- /dev/null
+++ b/external/aocommon/include/aocommon/fits/fitswriter.h
@@ -0,0 +1,729 @@
+#ifndef AOCOMMON_FITS_FITSWRITER_H_
+#define AOCOMMON_FITS_FITSWRITER_H_
+
+#include "fitsbase.h"
+#include "fitsreader.h"
+#include "../polarization.h"
+#include "../uvector.h"
+
+#include <array>
+#include <cmath>
+#include <limits>
+#include <map>
+#include <string>
+#include <vector>
+
+#include <fitsio.h>
+
+namespace aocommon {
+
+/// Requires the fitsio library.
+class FitsWriter : public FitsBase {
+ public:
+  enum DimensionType {
+    FrequencyDimension,
+    PolarizationDimension,
+    AntennaDimension,
+    TimeDimension,
+    MatrixDimension
+  };
+
+  FitsWriter()
+      : _width(0),
+        _height(0),
+        _phaseCentreRA(0.0),
+        _phaseCentreDec(0.0),
+        _pixelSizeX(0.0),
+        _pixelSizeY(0.0),
+        _phaseCentreDL(0.0),
+        _phaseCentreDM(0.0),
+        _frequency(0.0),
+        _bandwidth(0.0),
+        _dateObs(0.0),
+        _hasBeam(false),
+        _beamMajorAxisRad(0.0),
+        _beamMinorAxisRad(0.0),
+        _beamPositionAngle(0.0),
+        _polarization(aocommon::Polarization::StokesI),
+        _unit(JanskyPerBeam),
+        _isUV(false),
+        _telescopeName(),
+        _observer(),
+        _objectName(),
+        _origin("AO/WSImager"),
+        _originComment("Imager written by Andre Offringa"),
+        _multiFPtr(nullptr) {}
+
+  explicit FitsWriter(const class FitsReader& reader)
+      : _width(0),
+        _height(0),
+        _phaseCentreRA(0.0),
+        _phaseCentreDec(0.0),
+        _pixelSizeX(0.0),
+        _pixelSizeY(0.0),
+        _phaseCentreDL(0.0),
+        _phaseCentreDM(0.0),
+        _frequency(0.0),
+        _bandwidth(0.0),
+        _dateObs(0.0),
+        _hasBeam(false),
+        _beamMajorAxisRad(0.0),
+        _beamMinorAxisRad(0.0),
+        _beamPositionAngle(0.0),
+        _polarization(aocommon::Polarization::StokesI),
+        _unit(JanskyPerBeam),
+        _isUV(false),
+        _telescopeName(),
+        _observer(),
+        _objectName(),
+        _origin("AO/WSImager"),
+        _originComment("Imager written by Andre Offringa"),
+        _multiFPtr(nullptr) {
+    SetMetadata(reader);
+  }
+
+  ~FitsWriter() {
+    if (_multiFPtr != nullptr) FinishMulti();
+  }
+
+  // template void Write<long double>(const std::string& filename,
+  //                                  const long double* image) const;
+  // template void Write<double>(const std::string& filename,
+  //                             const double* image) const;
+  // template void Write<float>(const std::string& filename,
+  //                            const float* image) const;
+
+  template <typename NumType>
+  void Write(const std::string& filename, const NumType* image) const {
+    fitsfile* fptr;
+
+    writeHeaders(fptr, filename);
+
+    long firstPixel[4] = {1, 1, 1, 1};
+    writeImage(fptr, filename, image, firstPixel);
+
+    int status = 0;
+    fits_close_file(fptr, &status);
+    checkStatus(status, filename);
+  }
+
+  void WriteMask(const std::string& filename, const bool* mask) const {
+    aocommon::UVector<float> maskAsImage(_width * _height);
+    for (size_t i = 0; i != _width * _height; ++i)
+      maskAsImage[i] = mask[i] ? 1.0 : 0.0;
+    Write(filename, maskAsImage.data());
+  }
+
+  void StartMulti(const std::string& filename) {
+    if (_multiFPtr != nullptr)
+      throw std::runtime_error(
+          "StartMulti() called twice without calling FinishMulti()");
+    _multiFilename = filename;
+    writeHeaders(_multiFPtr, _multiFilename, _extraDimensions);
+    _currentPixel.assign(_extraDimensions.size() + 2, 1);
+  }
+
+  template <typename NumType>
+  void AddToMulti(const NumType* image) {
+    if (_multiFPtr == nullptr)
+      throw std::runtime_error("AddToMulti() called before StartMulti()");
+    writeImage(_multiFPtr, _multiFilename, image, _currentPixel.data());
+    size_t index = 2;
+    _currentPixel[index]++;
+    while (index < _currentPixel.size() - 1 &&
+           _currentPixel[index] > long(_extraDimensions[index - 2].size)) {
+      _currentPixel[index] = 1;
+      ++index;
+      _currentPixel[index]++;
+    }
+  }
+
+  void FinishMulti() {
+    int status = 0;
+    fits_close_file(_multiFPtr, &status);
+    checkStatus(status, _multiFilename);
+    _multiFPtr = nullptr;
+  }
+
+  void SetBeamInfo(double widthRad) { SetBeamInfo(widthRad, widthRad, 0.0); }
+  void SetBeamInfo(double majorAxisRad, double minorAxisRad,
+                   double positionAngleRad) {
+    _hasBeam = true;
+    _beamMajorAxisRad = majorAxisRad;
+    _beamMinorAxisRad = minorAxisRad;
+    _beamPositionAngle = positionAngleRad;
+  }
+  void SetNoBeamInfo() {
+    _hasBeam = false;
+    _beamMajorAxisRad = 0.0;
+    _beamMinorAxisRad = 0.0;
+    _beamPositionAngle = 0.0;
+  }
+  void SetImageDimensions(size_t width, size_t height) {
+    _width = width;
+    _height = height;
+  }
+  void SetImageDimensions(size_t width, size_t height, double pixelSizeX,
+                          double pixelSizeY) {
+    SetImageDimensions(width, height);
+    _pixelSizeX = pixelSizeX;
+    _pixelSizeY = pixelSizeY;
+  }
+  void SetImageDimensions(size_t width, size_t height, double phaseCentreRA,
+                          double phaseCentreDec, double pixelSizeX,
+                          double pixelSizeY) {
+    SetImageDimensions(width, height, pixelSizeX, pixelSizeY);
+    _phaseCentreRA = phaseCentreRA;
+    _phaseCentreDec = phaseCentreDec;
+  }
+  void SetFrequency(double frequency, double bandwidth) {
+    _frequency = frequency;
+    _bandwidth = bandwidth;
+  }
+  void SetDate(double dateObs) { _dateObs = dateObs; }
+  void SetPolarization(aocommon::PolarizationEnum polarization) {
+    _polarization = polarization;
+  }
+  Unit GetUnit() const { return _unit; }
+  void SetUnit(Unit unit) { _unit = unit; }
+  void SetIsUV(bool isUV) { _isUV = isUV; }
+  void SetTelescopeName(const std::string& telescopeName) {
+    _telescopeName = telescopeName;
+  }
+  void SetObserver(const std::string& observer) { _observer = observer; }
+  void SetObjectName(const std::string& objectName) {
+    _objectName = objectName;
+  }
+  void SetOrigin(const std::string& origin, const std::string& comment) {
+    _origin = origin;
+    _originComment = comment;
+  }
+  void SetHistory(const std::vector<std::string>& history) {
+    _history = history;
+  }
+  void AddHistory(const std::string& historyLine) {
+    _history.push_back(historyLine);
+  }
+
+  void SetMetadata(const FitsReader& reader) {
+    _width = reader.ImageWidth();
+    _height = reader.ImageHeight();
+    _phaseCentreRA = reader.PhaseCentreRA();
+    _phaseCentreDec = reader.PhaseCentreDec();
+    _pixelSizeX = reader.PixelSizeX();
+    _pixelSizeY = reader.PixelSizeY();
+    _frequency = reader.Frequency();
+    _bandwidth = reader.Bandwidth();
+    _dateObs = reader.DateObs();
+    _polarization = reader.Polarization();
+    _hasBeam = reader.HasBeam();
+    if (_hasBeam) {
+      _beamMajorAxisRad = reader.BeamMajorAxisRad();
+      _beamMinorAxisRad = reader.BeamMinorAxisRad();
+      _beamPositionAngle = reader.BeamPositionAngle();
+    }
+    _phaseCentreDL = reader.PhaseCentreDL();
+    _phaseCentreDM = reader.PhaseCentreDM();
+    _telescopeName = reader.TelescopeName();
+    _observer = reader.Observer();
+    _objectName = reader.ObjectName();
+    _origin = reader.Origin();
+    _originComment = reader.OriginComment();
+    _history = reader.History();
+  }
+
+  /**
+   * @return double Right ascension of phase centre (rad)
+   */
+  double RA() const { return _phaseCentreRA; }
+
+  /**
+   * @return double Declination of phase centre (rad)
+   */
+  double Dec() const { return _phaseCentreDec; }
+
+  /**
+   * @return double Pixel size in x-direction (rad)
+   */
+  double PixelSizeX() const { return _pixelSizeX; }
+
+  /**
+   * @return double Pixel size in y-direction (rad)
+   */
+  double PixelSizeY() const { return _pixelSizeY; }
+
+  double Frequency() const { return _frequency; }
+  double Bandwidth() const { return _bandwidth; }
+  double BeamSizeMajorAxis() const { return _beamMajorAxisRad; }
+  double BeamSizeMinorAxis() const { return _beamMinorAxisRad; }
+  double BeamPositionAngle() const { return _beamPositionAngle; }
+
+  void SetExtraKeyword(const std::string& name, const std::string& value) {
+    if (_extraStringKeywords.count(name) != 0) _extraStringKeywords.erase(name);
+    _extraStringKeywords.insert(std::make_pair(name, value));
+  }
+  void SetExtraKeyword(const std::string& name, double value) {
+    if (_extraNumKeywords.count(name) != 0) _extraNumKeywords.erase(name);
+    _extraNumKeywords.insert(std::make_pair(name, value));
+  }
+  void RemoveExtraKeyword(const std::string& name) {
+    if (_extraNumKeywords.count(name) != 0) _extraNumKeywords.erase(name);
+    if (_extraStringKeywords.count(name) != 0) _extraStringKeywords.erase(name);
+  }
+  void SetExtraStringKeywords(
+      const std::map<std::string, std::string>& keywords) {
+    _extraStringKeywords = keywords;
+  }
+  void SetExtraNumKeywords(const std::map<std::string, double>& keywords) {
+    _extraNumKeywords = keywords;
+  }
+  void SetPhaseCentreShift(double dl, double dm) {
+    _phaseCentreDL = dl;
+    _phaseCentreDM = dm;
+  }
+  size_t Width() const { return _width; }
+  size_t Height() const { return _height; }
+  double PhaseCentreDL() const { return _phaseCentreDL; }
+  double PhaseCentreDM() const { return _phaseCentreDM; }
+
+  void CopyDoubleKeywordIfExists(FitsReader& reader, const char* keywordName) {
+    double v;
+    if (reader.ReadDoubleKeyIfExists(keywordName, v))
+      SetExtraKeyword(keywordName, v);
+  }
+
+  void CopyStringKeywordIfExists(FitsReader& reader, const char* keywordName) {
+    std::string v;
+    if (reader.ReadStringKeyIfExists(keywordName, v))
+      SetExtraKeyword(keywordName, v);
+  }
+
+  static void MJDToHMS(double mjd, int& hour, int& minutes, int& seconds,
+                       int& deciSec) {
+    // It might seem one can calculate each of these immediately
+    // without adjusting 'mjd', but this way circumvents some
+    // catastrophic rounding problems, where "0:59.9" might end up
+    // as "1:59.9".
+    deciSec = int(fmod(mjd * 36000.0 * 24.0, 10.0));
+    mjd -= double(deciSec) / (36000.0 * 24.0);
+
+    seconds = int(fmod(round(mjd * 3600.0 * 24.0), 60.0));
+    mjd -= double(seconds) / (3600.0 * 24.0);
+
+    minutes = int(fmod(round(mjd * 60.0 * 24.0), 60.0));
+    mjd -= double(minutes) / (60.0 * 24.0);
+
+    hour = int(fmod(round(mjd * 24.0), 24.0));
+  }
+
+  void AddExtraDimension(enum DimensionType type, size_t size) {
+    _extraDimensions.emplace_back(Dimension{type, size});
+  }
+  void SetTimeDirectionStart(double time) { _timeDirectionStart = time; }
+  void SetTimeDirectionInc(double dTime) { _timeDirectionInc = dTime; }
+
+ private:
+  struct Dimension {
+    DimensionType type;
+    size_t size;
+  };
+
+  template <typename T>
+  static T setNotFiniteToZero(T num) {
+    return std::isfinite(num) ? num : 0.0;
+  }
+  std::size_t _width, _height;
+  double _phaseCentreRA, _phaseCentreDec, _pixelSizeX, _pixelSizeY;
+  double _phaseCentreDL, _phaseCentreDM;
+  double _frequency, _bandwidth;
+  double _dateObs;
+  bool _hasBeam;
+  double _beamMajorAxisRad, _beamMinorAxisRad, _beamPositionAngle;
+  aocommon::PolarizationEnum _polarization;
+  Unit _unit;
+  bool _isUV;
+  std::string _telescopeName, _observer, _objectName;
+  std::string _origin, _originComment;
+  std::vector<std::string> _history;
+  std::vector<Dimension> _extraDimensions;
+  std::map<std::string, std::string> _extraStringKeywords;
+  std::map<std::string, double> _extraNumKeywords;
+  double _timeDirectionStart, _timeDirectionInc;
+
+  void julianDateToYMD(double jd, int& year, int& month, int& day) const {
+    int z = jd + 0.5;
+    int w = (z - 1867216.25) / 36524.25;
+    int x = w / 4;
+    int a = z + 1 + w - x;
+    int b = a + 1524;
+    int c = (b - 122.1) / 365.25;
+    int d = 365.25 * c;
+    int e = (b - d) / 30.6001;
+    int f = 30.6001 * e;
+    day = b - d - f;
+    while (e - 1 > 12) e -= 12;
+    month = e - 1;
+    year = c - 4715 - ((e - 1) > 2 ? 1 : 0);
+  }
+
+  void writeHeaders(fitsfile*& fptr, const std::string& filename) const {
+    if (_extraDimensions.empty()) {
+      std::vector<Dimension> dimensions(2);
+      dimensions[0].type = FrequencyDimension;
+      dimensions[0].size = 1;
+      dimensions[1].type = PolarizationDimension;
+      dimensions[1].size = 1;
+      writeHeaders(fptr, filename, dimensions);
+    } else {
+      writeHeaders(fptr, filename, _extraDimensions);
+    }
+  }
+
+  void writeHeaders(fitsfile*& fptr, const std::string& filename,
+                    const std::vector<Dimension>& extraDimensions) const {
+    int status = 0;
+    fits_create_file(&fptr, (std::string("!") + filename).c_str(), &status);
+    checkStatus(status, filename);
+
+    // append image HDU
+    int bitPixInt = FLOAT_IMG;
+    std::vector<long> naxes(2 + extraDimensions.size());
+    naxes[0] = _width;
+    naxes[1] = _height;
+    for (size_t i = 0; i != extraDimensions.size(); ++i)
+      naxes[i + 2] = extraDimensions[i].size;
+    fits_create_img(fptr, bitPixInt, naxes.size(), naxes.data(), &status);
+    checkStatus(status, filename);
+    double zero = 0, one = 1, equinox = 2000.0;
+    fits_write_key(fptr, TDOUBLE, "BSCALE", (void*)&one, "", &status);
+    checkStatus(status, filename);
+    fits_write_key(fptr, TDOUBLE, "BZERO", (void*)&zero, "", &status);
+    checkStatus(status, filename);
+
+    switch (_unit) {
+      default:
+      case JanskyPerBeam:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"JY/BEAM",
+                       "Units are in Jansky per beam", &status);
+        checkStatus(status, filename);
+        break;
+      case JanskyPerPixel:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"JY/PIXEL",
+                       "Units are in Jansky per pixel", &status);
+        checkStatus(status, filename);
+        break;
+      case Jansky:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"JY",
+                       "Units are in Jansky", &status);
+        checkStatus(status, filename);
+        break;
+      case Kelvin:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"K",
+                       "Units are in Kelvin", &status);
+        checkStatus(status, filename);
+        break;
+      case MilliKelvin:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"mK",
+                       "Units are in milli Kelvin", &status);
+        checkStatus(status, filename);
+        break;
+    }
+
+    if (_hasBeam) {
+      double majDeg = setNotFiniteToZero(_beamMajorAxisRad * 180.0 / M_PI),
+             minDeg = setNotFiniteToZero(_beamMinorAxisRad * 180.0 / M_PI),
+             posAngle = setNotFiniteToZero(_beamPositionAngle * 180.0 / M_PI);
+      fits_write_key(fptr, TDOUBLE, "BMAJ", (void*)&majDeg, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "BMIN", (void*)&minDeg, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "BPA", (void*)&posAngle, "", &status);
+      checkStatus(status, filename);
+    }
+
+    fits_write_key(fptr, TDOUBLE, "EQUINOX", (void*)&equinox, "J2000", &status);
+    checkStatus(status, filename);
+    fits_write_key(fptr, TSTRING, "BTYPE", (void*)"Intensity", "", &status);
+    checkStatus(status, filename);
+    if (!_telescopeName.empty()) {
+      fits_write_key(fptr, TSTRING, "TELESCOP", (void*)_telescopeName.c_str(),
+                     "", &status);
+      checkStatus(status, filename);
+    }
+    if (!_observer.empty()) {
+      fits_write_key(fptr, TSTRING, "OBSERVER", (void*)_observer.c_str(), "",
+                     &status);
+      checkStatus(status, filename);
+    }
+    if (!_objectName.empty()) {
+      fits_write_key(fptr, TSTRING, "OBJECT", (void*)_objectName.c_str(), "",
+                     &status);
+      checkStatus(status, filename);
+    }
+    fits_write_key(fptr, TSTRING, "ORIGIN", (void*)_origin.c_str(),
+                   _originComment.c_str(), &status);
+    checkStatus(status, filename);
+    double phaseCentreRADeg = (_phaseCentreRA / M_PI) * 180.0,
+           phaseCentreDecDeg = (_phaseCentreDec / M_PI) * 180.0;
+    double centrePixelX =
+               _pixelSizeX != 0.0
+                   ? ((_width / 2.0) + 1.0 + _phaseCentreDL / _pixelSizeX)
+                   : (_width / 2.0) + 1.0,
+           centrePixelY =
+               _pixelSizeY != 0.0
+                   ? ((_height / 2.0) + 1.0 - _phaseCentreDM / _pixelSizeY)
+                   : (_height / 2.0) + 1.0;
+    if (_isUV) {
+      double deltX, deltY;
+      if (_pixelSizeX == 0.0 || _pixelSizeY == 0.0) {
+        deltX = 1.0;
+        deltY = 1.0;
+      } else {
+        deltX = 1.0 / (_width * _pixelSizeX);
+        deltY = 1.0 / (_height * _pixelSizeY);
+      }
+      fits_write_key(fptr, TSTRING, "CTYPE1", (void*)"U---WAV",
+                     "U axis of UV plane", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRPIX1", (void*)&centrePixelX, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRVAL1", (void*)&zero, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CDELT1", (void*)&deltX, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TSTRING, "CUNIT1", (void*)"lambda", "", &status);
+      checkStatus(status, filename);
+
+      fits_write_key(fptr, TSTRING, "CTYPE2", (void*)"V---WAV",
+                     "V axis of UV plane", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRPIX2", (void*)&centrePixelY, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRVAL2", (void*)&zero, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CDELT2", (void*)&deltY, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TSTRING, "CUNIT2", (void*)"lambda", "", &status);
+      checkStatus(status, filename);
+    } else {
+      double stepXDeg = (-_pixelSizeX / M_PI) * 180.0,
+             stepYDeg = (_pixelSizeY / M_PI) * 180.0;
+      fits_write_key(fptr, TSTRING, "CTYPE1", (void*)"RA---SIN",
+                     "Right ascension angle cosine", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRPIX1", (void*)&centrePixelX, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRVAL1", (void*)&phaseCentreRADeg, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CDELT1", (void*)&stepXDeg, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TSTRING, "CUNIT1", (void*)"deg", "", &status);
+      checkStatus(status, filename);
+
+      fits_write_key(fptr, TSTRING, "CTYPE2", (void*)"DEC--SIN",
+                     "Declination angle cosine", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRPIX2", (void*)&centrePixelY, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRVAL2", (void*)&phaseCentreDecDeg, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CDELT2", (void*)&stepYDeg, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TSTRING, "CUNIT2", (void*)"deg", "", &status);
+      checkStatus(status, filename);
+    }
+
+    char ctypeDim[7] = "CTYPE?", crpixDim[7] = "CRPIX?", crvalDim[7] = "CRVAL?",
+         cdeltDim[7] = "CDELT?", cunitDim[7] = "CUNIT?";
+    for (size_t i = 0; i != extraDimensions.size(); ++i) {
+      ctypeDim[5] = (i + '3');
+      crpixDim[5] = (i + '3');
+      crvalDim[5] = (i + '3');
+      cdeltDim[5] = (i + '3');
+      cunitDim[5] = (i + '3');
+      switch (extraDimensions[i].type) {
+        case FrequencyDimension:
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"FREQ",
+                         "Central frequency", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&_frequency, "",
+                         &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, cdeltDim, (void*)&_bandwidth, "",
+                         &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TSTRING, cunitDim, (void*)"Hz", "", &status);
+          checkStatus(status, filename);
+          break;
+        case PolarizationDimension: {
+          double pol;
+          switch (_polarization) {
+            case aocommon::Polarization::StokesI:
+              pol = 1.0;
+              break;
+            case aocommon::Polarization::StokesQ:
+              pol = 2.0;
+              break;
+            case aocommon::Polarization::StokesU:
+              pol = 3.0;
+              break;
+            case aocommon::Polarization::StokesV:
+              pol = 4.0;
+              break;
+            case aocommon::Polarization::RR:
+              pol = -1.0;
+              break;
+            case aocommon::Polarization::LL:
+              pol = -2.0;
+              break;
+            case aocommon::Polarization::RL:
+              pol = -3.0;
+              break;
+            case aocommon::Polarization::LR:
+              pol = -4.0;
+              break;
+            case aocommon::Polarization::XX:
+              pol = -5.0;
+              break;
+            case aocommon::Polarization::YY:
+              pol = -6.0;
+              break;  // yup, this is really the right value
+            case aocommon::Polarization::XY:
+              pol = -7.0;
+              break;
+            case aocommon::Polarization::YX:
+              pol = -8.0;
+              break;
+            case aocommon::Polarization::FullStokes:
+            case aocommon::Polarization::Instrumental:
+            case aocommon::Polarization::DiagonalInstrumental:
+              throw std::runtime_error(
+                  "Incorrect polarization given to fits writer");
+          }
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"STOKES", "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&pol, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, cdeltDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TSTRING, cunitDim, (void*)"", "", &status);
+          checkStatus(status, filename);
+        } break;
+        case AntennaDimension:
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"ANTENNA", "",
+                         &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&zero, "", &status);
+          checkStatus(status, filename);
+          break;
+        case TimeDimension:
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"TIME", "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&_timeDirectionStart,
+                         "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, cdeltDim, (void*)&_timeDirectionInc, "",
+                         &status);
+          checkStatus(status, filename);
+          break;
+        case MatrixDimension:
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"MATRIX", "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&zero, "", &status);
+          checkStatus(status, filename);
+          break;
+      }
+    }
+
+    // RESTFRQ ?
+    fits_write_key(fptr, TSTRING, "SPECSYS", (void*)"TOPOCENT", "", &status);
+    checkStatus(status, filename);
+
+    int year, month, day, hour, min, sec, deciSec;
+    julianDateToYMD(_dateObs + 2400000.5, year, month, day);
+    MJDToHMS(_dateObs, hour, min, sec, deciSec);
+    char dateStr[40];
+    std::sprintf(dateStr, "%d-%02d-%02dT%02d:%02d:%02d.%01d", year, month, day,
+                 hour, min, sec, deciSec);
+    fits_write_key(fptr, TSTRING, "DATE-OBS", (void*)dateStr, "", &status);
+    checkStatus(status, filename);
+
+    // Extra keywords
+    for (std::map<std::string, std::string>::const_iterator i =
+             _extraStringKeywords.begin();
+         i != _extraStringKeywords.end(); ++i) {
+      const char* name = i->first.c_str();
+      char* valueStr = const_cast<char*>(i->second.c_str());
+      fits_write_key(fptr, TSTRING, name, valueStr, "", &status);
+      checkStatus(status, filename);
+    }
+    for (std::map<std::string, double>::const_iterator i =
+             _extraNumKeywords.begin();
+         i != _extraNumKeywords.end(); ++i) {
+      const char* name = i->first.c_str();
+      double value = setNotFiniteToZero(i->second);
+      fits_write_key(fptr, TDOUBLE, name, (void*)&value, "", &status);
+      checkStatus(status, filename);
+    }
+
+    // History
+    std::ostringstream histStr;
+    for (std::vector<std::string>::const_iterator i = _history.begin();
+         i != _history.end(); ++i) {
+      fits_write_history(fptr, i->c_str(), &status);
+      checkStatus(status, filename);
+    }
+  }
+  void writeImage(fitsfile* fptr, const std::string& filename,
+                  const double* image, long* currentPixel) const {
+    double nullValue = std::numeric_limits<double>::max();
+    int status = 0;
+    fits_write_pixnull(fptr, TDOUBLE, currentPixel, _width * _height,
+                       const_cast<double*>(image), &nullValue, &status);
+    checkStatus(status, filename);
+  }
+  void writeImage(fitsfile* fptr, const std::string& filename,
+                  const float* image, long* currentPixel) const {
+    float nullValue = std::numeric_limits<float>::max();
+    int status = 0;
+    fits_write_pixnull(fptr, TFLOAT, currentPixel, _width * _height,
+                       const_cast<float*>(image), &nullValue, &status);
+    checkStatus(status, filename);
+  }
+
+  template <typename NumType>
+  void writeImage(fitsfile* fptr, const std::string& filename,
+                  const NumType* image, long* currentPixel) const {
+    double nullValue = std::numeric_limits<double>::max();
+    int status = 0;
+    size_t totalSize = _width * _height;
+    std::vector<double> copy(totalSize);
+    for (size_t i = 0; i != totalSize; ++i) copy[i] = image[i];
+    fits_write_pixnull(fptr, TDOUBLE, currentPixel, totalSize, &copy[0],
+                       &nullValue, &status);
+    checkStatus(status, filename);
+  }
+
+  std::string _multiFilename;
+  fitsfile* _multiFPtr;
+  std::vector<long> _currentPixel;
+};
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/hmatrix4x4.h b/external/aocommon/include/aocommon/hmatrix4x4.h
new file mode 100644
index 0000000..52053a2
--- /dev/null
+++ b/external/aocommon/include/aocommon/hmatrix4x4.h
@@ -0,0 +1,294 @@
+#ifndef AOCOMMON_HMATRIX_4X4_H_
+#define AOCOMMON_HMATRIX_4X4_H_
+
+#include <complex>
+#include <string>
+#include <sstream>
+#include <stdexcept>
+
+#include <aocommon/matrix2x2.h>
+#include <aocommon/matrix4x4.h>
+
+namespace aocommon {
+
+/**
+ * Class implements a Hermitian 4x4 matrix. Internally, the data is
+ * stored as 16 doubles, rather than storing 16 complex doubles.
+ */
+class HMatrix4x4 {
+ public:
+  /**
+   * Fill Hermitian matrix with zeros.
+   *
+   */
+  HMatrix4x4() { std::fill_n(_data, 16, 0.0); }
+
+  /**
+   * Construct a HMatrix4x4 object form a buffer with size 16
+   *
+   */
+  HMatrix4x4(const double buffer[16]) { std::copy_n(buffer, 16, _data); }
+
+  /**
+   * Construct a new HMatrix4x4 object from the lower triangular entries in a
+   * Matrix4x4 object. No error is thrown if the input is not Hermitian.
+   *
+   */
+  explicit HMatrix4x4(const aocommon::Matrix4x4& src) {
+    // row 0
+    _data[0] = src[0].real();
+
+    // row 1
+    _data[1] = src[4].real();
+    _data[2] = src[4].imag();
+    _data[3] = src[5].real();
+
+    // row 2
+    _data[4] = src[8].real();
+    _data[5] = src[8].imag();
+    _data[6] = src[9].real();
+    _data[7] = src[9].imag();
+    _data[8] = src[10].real();
+
+    // row 3
+    _data[9] = src[12].real();
+    _data[10] = src[12].imag();
+    _data[11] = src[13].real();
+    _data[12] = src[13].imag();
+    _data[13] = src[14].real();
+    _data[14] = src[14].imag();
+    _data[15] = src[15].real();
+  }
+
+  /**
+   * Construct a new HMatrix4x4 object from an initializer list of
+   * std::complex<double> having length 16. No error is thrown if
+   * the input matrix is not Hermitian.
+   *
+   * @param list Initializer list of std::complex<double>, should have length 16
+   */
+  HMatrix4x4(std::initializer_list<std::complex<double>> list) {
+    *this = HMatrix4x4(aocommon::Matrix4x4(list));
+  }
+
+  /**
+   * Make a HMatrix4x4 object from an initializer list of (16) doubles
+   *
+   * @param list Initializer list of doubles with length 16
+   * @return HMatrix4x4
+   */
+  static HMatrix4x4 FromData(std::initializer_list<double> list) {
+    if (list.size() != 16)
+      throw std::runtime_error("FromData parameter should have 16 elements");
+    HMatrix4x4 m;
+    double* ptr = m._data;
+    for (double e : list) {
+      *ptr = e;
+      ++ptr;
+    }
+    return m;
+  }
+
+  /**
+   * Return HMatrix4x4 filled with zeros.
+   */
+  static HMatrix4x4 Zero() { return HMatrix4x4(); }
+
+  /**
+   * Return Hermitian 4x4 identity matrix.
+   */
+  static HMatrix4x4 Unit() {
+    HMatrix4x4 unit;
+    unit._data[0] = 1.0;
+    unit._data[3] = 1.0;
+    unit._data[8] = 1.0;
+    unit._data[15] = 1.0;
+    return unit;
+  }
+
+  /**
+   * Addition assignment operator
+   */
+  HMatrix4x4& operator+=(const HMatrix4x4& rhs) {
+    for (size_t i = 0; i != 16; ++i) _data[i] += rhs._data[i];
+    return *this;
+  }
+
+  /**
+   * Scalar multiplication operator
+   */
+  HMatrix4x4 operator*(double rhs) const {
+    HMatrix4x4 m;
+    for (size_t i = 0; i != 16; ++i) m._data[i] = _data[i] * rhs;
+    return m;
+  }
+
+  /**
+   * Matrix-vector dot product
+   */
+  aocommon::Vector4 operator*(const aocommon::Vector4& rhs) const {
+    aocommon::Vector4 v(_data[0] * rhs[0], (*this)[4] * rhs[0],
+                        (*this)[8] * rhs[0], (*this)[12] * rhs[0]);
+    v[0] += (*this)[1] * rhs[1];
+    v[1] += _data[3] * rhs[1];
+    v[2] += (*this)[1 + 8] * rhs[1];
+    v[3] += (*this)[1 + 12] * rhs[1];
+
+    v[0] += (*this)[2] * rhs[2];
+    v[1] += (*this)[2 + 4] * rhs[2];
+    v[2] += _data[8] * rhs[2];
+    v[3] += (*this)[2 + 12] * rhs[2];
+
+    v[0] += (*this)[3] * rhs[3];
+    v[1] += (*this)[3 + 4] * rhs[3];
+    v[2] += (*this)[3 + 8] * rhs[3];
+    v[3] += _data[15] * rhs[3];
+
+    return v;
+  }
+
+  /**
+   * Scalar multiplication-assignment
+   */
+  HMatrix4x4& operator*=(double rhs) {
+    for (size_t i = 0; i != 16; ++i) _data[i] *= rhs;
+    return *this;
+  }
+
+  /**
+   * Scalar division assignment
+   */
+  HMatrix4x4& operator/=(double rhs) {
+    for (size_t i = 0; i != 16; ++i) _data[i] /= rhs;
+    return *this;
+  }
+
+  /**
+   * Invert matrix. Returns false if Hermitian not invertible.
+   */
+  bool Invert() {
+    aocommon::Matrix4x4 inv = ToMatrix();
+    if (!inv.Invert())
+      return false;
+    else {
+      *this = HMatrix4x4(inv);
+      return true;
+    }
+  }
+
+  /**
+   * Indexing operator
+   */
+  std::complex<double> operator[](size_t i) const {
+    const size_t lookup[16] = {32, 17, 20, 25, 1, 35, 22, 27,
+                               4,  6,  40, 29, 9, 11, 13, 47};
+    const size_t l = lookup[i];
+    return ((l & 32) == 0)
+               ? (((l & 16) == 0)
+                      ? std::complex<double>(_data[l], _data[l + 1])
+                      : std::complex<double>(_data[l & (~16)],
+                                             -_data[(l & (~16)) + 1]))
+               : (_data[l & (~32)]);
+  }
+
+  /**
+   * Convert Hermitian to regular (complex-valued) 4x4 matrix
+   */
+  aocommon::Matrix4x4 ToMatrix() const {
+    aocommon::Matrix4x4 m;
+    for (size_t i = 0; i != 16; ++i) {
+      m[i] = (*this)[i];
+    }
+    return m;
+  }
+
+  /**
+   * "Entrywise" square of the L2 norm of the Hermitian
+   */
+  double Norm() const {
+    return
+        // diagonal
+        _data[0] * _data[0] + _data[3] * _data[3] + _data[8] * _data[8] +
+        _data[15] * _data[15] +
+        // lower half x 2
+        2.0 * (std::norm(ToComplex(1)) + std::norm(ToComplex(4)) +
+               std::norm(ToComplex(6)) + std::norm(ToComplex(9)) +
+               std::norm(ToComplex(11)) + std::norm(ToComplex(13)));
+  }
+
+  /**
+   * Convert matrix to pretty string
+   */
+  std::string String() const {
+    std::ostringstream str;
+    for (size_t y = 0; y != 4; ++y) {
+      for (size_t x = 0; x != 3; ++x) {
+        str << (*this)[x + y * 4] << '\t';
+      }
+      str << (*this)[3 + y * 4] << '\n';
+    }
+    return str.str();
+  }
+
+  /**
+   * Compute Hermitian matrix as the product of two 2x2 complex valued matrices.
+   * Typical use case is to convert the product of two Jones matrices
+   * into a Mueller matrix.
+   */
+  static HMatrix4x4 KroneckerProduct(const aocommon::MC2x2& hma,
+                                     const aocommon::MC2x2& hmb) {
+    HMatrix4x4 result;
+
+    // top left submatrix
+    result._data[0] = (hma[0] * hmb[0]).real();
+    result.SetComplex(1, hma[0] * hmb[2]);
+    result._data[3] = (hma[0] * hmb[3]).real();
+
+    // bottom left submatrix
+    result.SetComplex(4, hma[2] * hmb[0]);
+    result.SetComplex(6, hma[2] * hmb[1]);
+    result.SetComplex(9, hma[2] * hmb[2]);
+    result.SetComplex(11, hma[2] * hmb[3]);
+
+    // bottom right submatrix
+    result._data[8] = (hma[3] * hmb[0]).real();
+    result.SetComplex(13, hma[3] * hmb[2]);
+    result._data[15] = (hma[3] * hmb[3]).real();
+
+    return result;
+  }
+
+  /**
+   * Get underlying data by index, where 0 <= index <= 15. This indexing
+   * is used since the data is internally stored as 16 doubles. The diagonal
+   * is real, and only the lower (complex) half is stored, in
+   * column-first order. The elements can therefore be index in
+   * the following way:
+   *  0
+   *  1  3
+   *  4  6 8
+   *  9 11 13 15
+   *
+   * Note that "skipped indices" are the imaginary entries of the
+   * Hermitian matrix
+   */
+  const double& Data(size_t index) const { return _data[index]; }
+  double& Data(size_t index) { return _data[index]; }
+
+ private:
+  std::complex<double> ToComplex(size_t singleIndex) const {
+    return std::complex<double>(_data[singleIndex], _data[singleIndex + 1]);
+  }
+  void SetComplex(size_t singleIndex, std::complex<double> val) {
+    _data[singleIndex] = val.real();
+    _data[singleIndex + 1] = val.imag();
+  }
+
+  // See documentation for Data method on the internal data storage
+  double _data[16];
+};
+
+typedef HMatrix4x4 HMC4x4;
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/image.h b/external/aocommon/include/aocommon/image.h
new file mode 100644
index 0000000..74dde7a
--- /dev/null
+++ b/external/aocommon/include/aocommon/image.h
@@ -0,0 +1,530 @@
+#ifndef AOCOMMON_IMAGE_H_
+#define AOCOMMON_IMAGE_H_
+
+#include <aocommon/io/serialostream.h>
+#include <aocommon/io/serialistream.h>
+#include <aocommon/uvector.h>
+
+#include <cassert>
+#include <cstring>
+#include <cmath>
+#include <complex>
+#include <memory>
+
+namespace aocommon {
+namespace detail {
+/**
+ * Because Image can be instantiated for complex values, a
+ * helper function is used to implement ordering operations like
+ * median that do not have complex implementations.
+ */
+template <typename NumT>
+inline NumT MedianWithCopyImplementation(const NumT* data, size_t size,
+                                         aocommon::UVector<NumT>& copy) {
+  copy.reserve(size);
+  for (const NumT* i = data; i != data + size; ++i) {
+    if (std::isfinite(*i)) copy.push_back(*i);
+  }
+  if (copy.empty())
+    return 0.0;
+  else {
+    bool even = (copy.size() % 2) == 0;
+    typename aocommon::UVector<NumT>::iterator mid =
+        copy.begin() + (copy.size() - 1) / 2;
+    std::nth_element(copy.begin(), mid, copy.end());
+    NumT median = *mid;
+    if (even) {
+      std::nth_element(mid, mid + 1, copy.end());
+      median = (median + *(mid + 1)) * 0.5;
+    }
+    return median;
+  }
+}
+
+template <typename NumT>
+inline NumT MadImplementation(const NumT* data, size_t size) {
+  aocommon::UVector<NumT> copy;
+  NumT median = MedianWithCopyImplementation(data, size, copy);
+  if (copy.empty()) return 0.0;
+
+  // Replace all values by the difference from the mean
+  typename aocommon::UVector<NumT>::iterator mid =
+      copy.begin() + (copy.size() - 1) / 2;
+  for (typename aocommon::UVector<NumT>::iterator i = copy.begin();
+       i != mid + 1; ++i)
+    *i = median - *i;
+  for (typename aocommon::UVector<NumT>::iterator i = mid + 1; i != copy.end();
+       ++i)
+    *i = *i - median;
+
+  std::nth_element(copy.begin(), mid, copy.end());
+  median = *mid;
+  bool even = (copy.size() % 2) == 0;
+  if (even) {
+    std::nth_element(mid, mid + 1, copy.end());
+    median = (median + *(mid + 1)) * 0.5;
+  }
+  return median;
+}
+}  // namespace detail
+
+template <typename NumT>
+class ImageBase {
+ public:
+  using value_type = NumT;
+  using num_t = value_type;
+
+  using iterator = value_type*;
+  using const_iterator = const value_type*;
+
+  constexpr ImageBase() noexcept : data_(nullptr), width_(0), height_(0) {}
+
+  /**
+   * @brief Construct new ImageBase object of given width and
+   * height, but with uninitialized values.
+   */
+  ImageBase(size_t width, size_t height)
+      : data_(new value_type[width * height]), width_(width), height_(height) {}
+
+  /**
+   * @brief Construct an new ImageBase object with given width and height, with
+   * all values initialized to \c initial_value.
+   */
+  ImageBase(size_t width, size_t height, value_type initial_value)
+      : data_(new value_type[width * height]), width_(width), height_(height) {
+    std::fill(data_, data_ + width_ * height_, initial_value);
+  }
+
+  /**
+   * @brief Construct an new ImageBase object with given width and height, with
+   * values initialized from an initializer list.
+   */
+  ImageBase(size_t width, size_t height,
+            std::initializer_list<NumT> initial_values)
+      : data_(new value_type[width * height]), width_(width), height_(height) {
+    assert(initial_values.size() == width * height);
+    std::copy_n(initial_values.begin(), width_ * height_, data_);
+  }
+
+  ~ImageBase() noexcept { delete[] data_; }
+
+  ImageBase(const ImageBase<NumT>& source)
+      : data_(new value_type[source.width_ * source.height_]),
+        width_(source.width_),
+        height_(source.height_) {
+    std::copy(source.data_, source.data_ + width_ * height_, data_);
+  }
+
+  ImageBase<NumT>& operator=(const ImageBase<NumT>& source) {
+    if (width_ * height_ != source.width_ * source.height_) {
+      delete[] data_;
+      // Make data_ robust against failure of "new" (e.g. due to out of mem
+      // failures)
+      data_ = nullptr;
+      data_ = new value_type[source.width_ * source.height_];
+    }
+    width_ = source.width_;
+    height_ = source.height_;
+    std::copy(source.data_, source.data_ + width_ * height_, data_);
+    return *this;
+  }
+
+  ImageBase<NumT>& operator=(value_type value) noexcept {
+    std::fill_n(data_, width_ * height_, value);
+    return *this;
+  }
+
+  ImageBase<NumT>& Assign(const NumT* begin, const NumT* end) {
+    if (size_t(end - begin) != width_ * height_)
+      throw std::runtime_error("Invalid Assign()");
+    std::copy(begin, end, data_);
+    return *this;
+  }
+
+  ImageBase(ImageBase<NumT>&& source) noexcept
+      : data_(source.data_), width_(source.width_), height_(source.height_) {
+    source.width_ = 0;
+    source.height_ = 0;
+    source.data_ = nullptr;
+  }
+
+  ImageBase<NumT>& operator=(ImageBase<NumT>&& source) noexcept {
+    std::swap(data_, source.data_);
+    std::swap(width_, source.width_);
+    std::swap(height_, source.height_);
+    return *this;
+  }
+
+  static std::unique_ptr<ImageBase<NumT>> Make(size_t width, size_t height) {
+    return std::unique_ptr<ImageBase<NumT>>(new ImageBase<NumT>(width, height));
+  }
+  static std::unique_ptr<ImageBase<NumT>> Make(size_t width, size_t height,
+                                               value_type initial_value) {
+    return std::unique_ptr<ImageBase<NumT>>(
+        new ImageBase<NumT>(width, height, initial_value));
+  }
+
+  value_type* Data() { return data_; }
+  const value_type* Data() const { return data_; }
+
+  size_t Width() const { return width_; }
+  size_t Height() const { return height_; }
+  size_t Size() const { return width_ * height_; }
+  bool Empty() const { return width_ == 0 || height_ == 0; }
+
+  iterator begin() { return data_; }
+  const_iterator begin() const { return data_; }
+
+  iterator end() { return data_ + width_ * height_; }
+  const_iterator end() const { return data_ + width_ * height_; }
+
+  const value_type& operator[](size_t index) const { return data_[index]; }
+  value_type& operator[](size_t index) { return data_[index]; }
+
+  ImageBase<NumT>& operator+=(const ImageBase<NumT>& other) {
+    assert(Size() == other.Size());
+    for (size_t i = 0; i != width_ * height_; ++i) data_[i] += other[i];
+    return *this;
+  }
+
+  ImageBase<NumT>& operator-=(const ImageBase<NumT>& other) {
+    assert(Size() == other.Size());
+    for (size_t i = 0; i != width_ * height_; ++i) data_[i] -= other[i];
+    return *this;
+  }
+
+  ImageBase<NumT>& operator*=(value_type factor) {
+    for (size_t i = 0; i != width_ * height_; ++i) data_[i] *= factor;
+    return *this;
+  }
+
+  ImageBase<NumT>& operator*=(const ImageBase<NumT>& other) {
+    assert(Size() == other.Size());
+    for (size_t i = 0; i != width_ * height_; ++i) data_[i] *= other[i];
+    return *this;
+  }
+
+  ImageBase<NumT>& operator/=(value_type factor) {
+    return (*this) *= value_type(1.0) / factor;
+  }
+
+  ImageBase<NumT>& Sqrt() {
+    for (size_t i = 0; i != width_ * height_; ++i)
+      data_[i] = std::sqrt(data_[i]);
+    return *this;
+  }
+
+  ImageBase<NumT>& SqrtWithFactor(NumT factor) {
+    for (size_t i = 0; i != width_ * height_; ++i)
+      data_[i] = std::sqrt(data_[i]) * factor;
+    return *this;
+  }
+
+  ImageBase<NumT>& Square() {
+    for (size_t i = 0; i != width_ * height_; ++i) data_[i] *= data_[i];
+    return *this;
+  }
+
+  ImageBase<NumT>& SquareWithFactor(NumT factor) {
+    for (size_t i = 0; i != width_ * height_; ++i)
+      data_[i] *= data_[i] * factor;
+    return *this;
+  }
+
+  ImageBase<NumT>& AddWithFactor(const ImageBase<NumT>& rhs, NumT factor) {
+    assert(Size() == rhs.Size());
+    for (size_t i = 0; i != width_ * height_; ++i) data_[i] += rhs[i] * factor;
+    return *this;
+  }
+
+  ImageBase<NumT>& AddSquared(const ImageBase<NumT>& rhs) {
+    assert(Size() == rhs.Size());
+    for (size_t i = 0; i != width_ * height_; ++i) data_[i] += rhs[i] * rhs[i];
+    return *this;
+  }
+
+  ImageBase<NumT>& AddSquared(const ImageBase<NumT>& rhs, NumT factor) {
+    assert(Size() == rhs.Size());
+    for (size_t i = 0; i != width_ * height_; ++i)
+      data_[i] += rhs[i] * rhs[i] * factor;
+    return *this;
+  }
+
+  void Reset() {
+    delete[] data_;
+    data_ = nullptr;
+    width_ = 0;
+    height_ = 0;
+  }
+
+  /** Cut-off the borders of an image.
+   * @param out_width Should be &lt;= in_width.
+   * @param out_height Should be &lt;= in_height.
+   */
+  static void Trim(value_type* output, size_t out_width, size_t out_height,
+                   const value_type* input, size_t in_width, size_t in_height) {
+    const size_t start_x = (in_width - out_width) / 2;
+    const size_t start_y = (in_height - out_height) / 2;
+    const size_t end_y = (in_height + out_height) / 2;
+    for (size_t y = start_y; y != end_y; ++y) {
+      std::copy_n(&input[y * in_width + start_x], out_width,
+                  &output[(y - start_y) * out_width]);
+    }
+  }
+
+  ImageBase<NumT> Trim(size_t out_width, size_t out_height) const {
+    ImageBase<NumT> image(out_width, out_height);
+    Trim(image.Data(), out_width, out_height, Data(), Width(), Height());
+    return image;
+  }
+
+  /**
+   * @brief Trim image to box, given a lower left (x,y)-coordinate
+   * and box width and height.
+   *
+   * @param x1 Lower left x-coordinate
+   * @param y1 Lower left y-coordinate
+   * @param box_width Box width
+   * @param box_height Box height
+   * @return ImageBase<NumT> Trimmed image
+   */
+  ImageBase<NumT> TrimBox(size_t x1, size_t y1, size_t box_width,
+                          size_t box_height) const {
+    ImageBase<NumT> image(box_width, box_height);
+    TrimBox(image.Data(), x1, y1, box_width, box_height, Data(), Width(),
+            Height());
+    return image;
+  }
+
+  template <typename T>
+  static void TrimBox(T* output, size_t x1, size_t y1, size_t box_width,
+                      size_t box_height, const T* input, size_t in_width,
+                      size_t in_height) {
+    size_t end_y = y1 + box_height;
+    for (size_t y = y1; y != end_y; ++y) {
+      std::copy_n(&input[y * in_width + x1], box_width,
+                  &output[(y - y1) * box_width]);
+    }
+  }
+
+  template <typename T>
+  static void CopyMasked(T* to, size_t to_x, size_t to_y, size_t to_width,
+                         const T* from, size_t from_width, size_t from_height,
+                         const bool* from_mask) {
+    for (size_t y = 0; y != from_height; ++y) {
+      for (size_t x = 0; x != from_width; ++x) {
+        if (from_mask[y * from_width + x])
+          to[to_x + (to_y + y) * to_width + x] = from[y * from_width + x];
+      }
+    }
+  }
+
+  /**
+   * Add the contents of an image to a bigger image at a specific place.
+   * This function is templated such that it also works with images stored
+   * as (one-dimensional) arrays of size width x height.
+   * The height of the target image is not necessary as parameter, but it
+   * is assumed that the subimage fits completely in the target image at the
+   * specified position.
+   *
+   * @param to Target image to which the subimage is added.
+   * @param to_x Horizontal size of the target image where the subimage is
+   * placed
+   * @param to_y Vertical size of target image
+   * @param to_width Width of target image.
+   * @param from Subimage to be placed on the target image
+   * @param from_width Horizontal size of the @c from image
+   * @param from_height Vertical size of the @c from image
+   */
+  template <typename ValueTypeTo, typename ValueTypeFrom>
+  static void AddSubImage(ValueTypeTo* to, size_t to_x, size_t to_y,
+                          size_t to_width, const ValueTypeFrom* from,
+                          size_t from_width, size_t from_height) {
+    assert(to_x + from_width <= to_width);
+    for (size_t y = 0; y != from_height; ++y) {
+      ValueTypeTo* to_line = &to[to_x + (to_y + y) * to_width];
+      const ValueTypeFrom* from_line = &from[y * from_width];
+      for (size_t x = 0; x != from_width; ++x) {
+        to_line[x] += from_line[x];
+      }
+    }
+  }
+
+  /** Extend an image with zeros, complement of Trim.
+   * @param out_width Should be &gt;= in_width.
+   * @param out_height Should be &gt;= in_height.
+   */
+  static void Untrim(value_type* output, size_t out_width, size_t out_height,
+                     const value_type* input, size_t in_width,
+                     size_t in_height) {
+    const size_t start_x = (out_width - in_width) / 2;
+    const size_t end_x = (out_width + in_width) / 2;
+    const size_t start_y = (out_height - in_height) / 2;
+    const size_t end_y = (out_height + in_height) / 2;
+    for (size_t y = 0; y != start_y; ++y) {
+      value_type* ptr = &output[y * out_width];
+      std::fill_n(ptr, out_width, 0.0);
+    }
+    for (size_t y = start_y; y != end_y; ++y) {
+      value_type* ptr = &output[y * out_width];
+      std::fill_n(ptr, start_x, 0.0);
+      std::copy_n(&input[(y - start_y) * in_width], in_width,
+                  &output[y * out_width + start_x]);
+      std::fill_n(ptr + end_x, out_width, 0.0);
+    }
+    for (size_t y = end_y; y != out_height; ++y) {
+      value_type* ptr = &output[y * out_width];
+      std::fill_n(ptr, out_width, 0.0);
+    }
+  }
+
+  ImageBase<NumT> Untrim(size_t out_width, size_t out_height) const {
+    ImageBase<NumT> image(out_width, out_height);
+    Untrim(image.Data(), out_width, out_height, Data(), Width(), Height());
+    return image;
+  }
+
+  static value_type Median(const value_type* data, size_t size);
+
+  static value_type MAD(const value_type* data, size_t size);
+
+  value_type Sum() const {
+    value_type sum = 0.0;
+    for (const value_type& v : *this) sum += v;
+    return sum;
+  }
+
+  value_type Average() const { return Sum() / NumT(Size()); }
+
+  value_type Min() const;
+  value_type Max() const;
+
+  value_type StdDevFromMAD() const {
+    return StdDevFromMAD(data_, width_ * height_);
+  }
+  static value_type StdDevFromMAD(const value_type* data, size_t size) {
+    // norminv(0.75) x MAD
+    return value_type(1.48260221850560) * MAD(data, size);
+  }
+
+  value_type RMS() const { return RMS(data_, width_ * height_); }
+
+  static value_type RMS(const value_type* data, size_t size) {
+    value_type sum = 0.0;
+    for (size_t i = 0; i != size; ++i) sum += data[i] * data[i];
+    return std::sqrt(sum / value_type(size));
+  }
+
+  void Negate() {
+    for (value_type& d : *this) d = -d;
+  }
+
+  void Serialize(aocommon::SerialOStream& stream) const {
+    stream.UInt64(width_).UInt64(height_);
+    size_t n = sizeof(NumT) * width_ * height_;
+    std::copy_n(reinterpret_cast<const unsigned char*>(data_), n,
+                stream.Chunk(n));
+  }
+  void Unserialize(aocommon::SerialIStream& stream) {
+    delete[] data_;
+    // Make robust against stream failing
+    data_ = nullptr;
+    stream.UInt64(width_).UInt64(height_);
+    if (width_ * height_ != 0) {
+      data_ = new value_type[width_ * height_];
+    }
+    const size_t n = sizeof(NumT) * width_ * height_;
+    std::copy_n(stream.Chunk(n), n, reinterpret_cast<unsigned char*>(data_));
+  }
+
+ private:
+  value_type* data_;
+  size_t width_;
+  size_t height_;
+
+  static value_type MedianWithCopy(const value_type* data, size_t size,
+                                   aocommon::UVector<value_type>& copy);
+};
+
+/**
+ * A single-precision two-dimensional image.
+ */
+using Image = ImageBase<float>;
+
+/**
+ * A double-precision two-dimensional image.
+ * This type is (currently) not used inside WSClean, but it is used in
+ * some other projects that share the same Image class, hence it is here.
+ */
+using DImage = ImageBase<double>;
+
+using ImageCF = ImageBase<std::complex<float>>;
+
+template <class T>
+using ComplexImageBase = ImageBase<std::complex<T>>;
+
+template <>
+inline typename ImageBase<double>::value_type ImageBase<double>::Min() const {
+  return *std::min_element(begin(), end());
+}
+
+template <>
+inline typename ImageBase<float>::value_type ImageBase<float>::Min() const {
+  return *std::min_element(begin(), end());
+}
+
+template <>
+inline typename ImageBase<double>::value_type ImageBase<double>::Max() const {
+  return *std::max_element(begin(), end());
+}
+
+template <>
+inline typename ImageBase<float>::value_type ImageBase<float>::Max() const {
+  return *std::max_element(begin(), end());
+}
+
+template <>
+inline typename ImageBase<float>::value_type ImageBase<float>::MedianWithCopy(
+    const value_type* data, size_t size, aocommon::UVector<value_type>& copy) {
+  return detail::MedianWithCopyImplementation(data, size, copy);
+}
+
+template <>
+inline typename ImageBase<double>::value_type ImageBase<double>::MedianWithCopy(
+    const value_type* data, size_t size, aocommon::UVector<value_type>& copy) {
+  return detail::MedianWithCopyImplementation(data, size, copy);
+}
+
+template <typename NumT>
+typename ImageBase<NumT>::value_type ImageBase<NumT>::MedianWithCopy(
+    const value_type*, size_t, aocommon::UVector<value_type>&) {
+  throw std::runtime_error("not implemented");
+}
+
+template <typename NumT>
+typename ImageBase<NumT>::value_type ImageBase<NumT>::Median(
+    const value_type* data, size_t size) {
+  aocommon::UVector<value_type> copy;
+  return MedianWithCopy(data, size, copy);
+}
+
+template <>
+inline typename ImageBase<float>::value_type ImageBase<float>::MAD(
+    const value_type* data, size_t size) {
+  return detail::MadImplementation(data, size);
+}
+
+template <>
+inline typename ImageBase<double>::value_type ImageBase<double>::MAD(
+    const value_type* data, size_t size) {
+  return detail::MadImplementation(data, size);
+}
+
+template <typename NumT>
+typename ImageBase<NumT>::value_type ImageBase<NumT>::MAD(const value_type*,
+                                                          size_t) {
+  throw std::runtime_error("not implemented");
+}
+
+}  // namespace aocommon
+#endif
diff --git a/external/aocommon/include/aocommon/imageaccessor.h b/external/aocommon/include/aocommon/imageaccessor.h
new file mode 100644
index 0000000..aed5593
--- /dev/null
+++ b/external/aocommon/include/aocommon/imageaccessor.h
@@ -0,0 +1,36 @@
+#ifndef AOCOMMON_IMAGE_ACCESSOR_H_
+#define AOCOMMON_IMAGE_ACCESSOR_H_
+
+#include "image.h"
+
+namespace aocommon {
+
+/**
+ * @brief Abstract interface for loading and storing an image.
+ *
+ * An ImageAccessor object knows how to store a single image and load it back
+ * later. When used in an interface, the caller can implement storing the image
+ * in different ways (e.g. on disk, in memory, etc)."
+ */
+class ImageAccessor {
+ public:
+  virtual ~ImageAccessor() {}
+
+  /**
+   * @brief Load the image.
+   *
+   * @param image Location where the image will be stored.
+   */
+  virtual void Load(Image& image) const = 0;
+
+  /**
+   * @brief Store the image, so it can be loaded back later.
+   *
+   * @param image The image that must be stored.
+   */
+  virtual void Store(const Image& image) = 0;
+};
+
+}  // namespace aocommon
+
+#endif
\ No newline at end of file
diff --git a/external/aocommon/include/aocommon/imagecoordinates.h b/external/aocommon/include/aocommon/imagecoordinates.h
new file mode 100644
index 0000000..b879554
--- /dev/null
+++ b/external/aocommon/include/aocommon/imagecoordinates.h
@@ -0,0 +1,136 @@
+#ifndef AOCOMMON_IMAGE_COORDINATES_H_
+#define AOCOMMON_IMAGE_COORDINATES_H_
+
+#include <algorithm>
+#include <cmath>
+#include <vector>
+
+namespace aocommon {
+
+/**
+ * This class collects all the LM coordinate transform as defined in
+ * Perley (1999)'s "imaging with non-coplaner arrays".
+ */
+class ImageCoordinates {
+ public:
+  template <typename T>
+  static void RaDecToLM(T ra, T dec, T phaseCentreRa, T phaseCentreDec,
+                        T& destL, T& destM) {
+    const T deltaAlpha = ra - phaseCentreRa;
+    const T sinDeltaAlpha = std::sin(deltaAlpha);
+    const T cosDeltaAlpha = std::cos(deltaAlpha);
+    const T sinDec = std::sin(dec);
+    const T cosDec = std::cos(dec);
+    const T sinDec0 = std::sin(phaseCentreDec);
+    const T cosDec0 = std::cos(phaseCentreDec);
+
+    destL = cosDec * sinDeltaAlpha;
+    destM = sinDec * cosDec0 - cosDec * sinDec0 * cosDeltaAlpha;
+  }
+
+  template <typename T>
+  static T RaDecToN(T ra, T dec, T phaseCentreRa, T phaseCentreDec) {
+    const T cosDeltaAlpha = std::cos(ra - phaseCentreRa);
+    const T sinDec = std::sin(dec);
+    const T cosDec = std::cos(dec);
+    const T sinDec0 = std::sin(phaseCentreDec);
+    const T cosDec0 = std::cos(phaseCentreDec);
+
+    return sinDec * sinDec0 + cosDec * cosDec0 * cosDeltaAlpha;
+  }
+
+  template <typename T>
+  static void LMToRaDec(T l, T m, T phaseCentreRa, T phaseCentreDec, T& destRa,
+                        T& destDec) {
+    const T cosDec0 = std::cos(phaseCentreDec);
+    const T sinDec0 = std::sin(phaseCentreDec);
+    const T lmTerm = std::sqrt(T(1.0) - l * l - m * m);
+    const T deltaAlpha = std::atan2(l, lmTerm * cosDec0 - m * sinDec0);
+
+    destRa = deltaAlpha + phaseCentreRa;
+    destDec = std::asin(m * cosDec0 + lmTerm * sinDec0);
+  }
+
+  template <typename T>
+  static void XYToLM(size_t x, size_t y, T pixelSizeX, T pixelSizeY,
+                     size_t width, size_t height, T& l, T& m) {
+    const T midX = T(width) / 2.0;
+    const T midY = T(height) / 2.0;
+    l = (midX - (T)x) * pixelSizeX;
+    m = ((T)y - midY) * pixelSizeY;
+  }
+
+  template <typename T>
+  static void LMToXY(T l, T m, T pixelSizeX, T pixelSizeY, size_t width,
+                     size_t height, int& x, int& y) {
+    const T midX = T(width) / 2.0;
+    const T midY = T(height) / 2.0;
+    x = std::round(-l / pixelSizeX) + midX;
+    y = std::round(m / pixelSizeY) + midY;
+  }
+
+  template <typename T>
+  static void LMToXYfloat(T l, T m, T pixelSizeX, T pixelSizeY, size_t width,
+                          size_t height, T& x, T& y) {
+    const T midX = T(width) / 2.0;
+    const T midY = T(height) / 2.0;
+    x = -l / pixelSizeX + midX;
+    y = m / pixelSizeY + midY;
+  }
+
+  template <typename T>
+  static T AngularDistance(T ra1, T dec1, T ra2, T dec2) {
+    const T sinDec1 = std::sin(dec1);
+    const T cosDec1 = std::cos(dec1);
+    const T sinDec2 = std::sin(dec2);
+    const T cosDec2 = std::cos(dec2);
+    const T cosVal =
+        sinDec1 * sinDec2 + cosDec1 * cosDec2 * std::cos(ra1 - ra2);
+    // Rounding errors sometimes cause cosVal to be slightly larger than 1,
+    // which would cause a NaN return value.
+    return cosVal <= 1.0 ? std::acos(cosVal) : 0.0;
+  }
+
+  template <typename T>
+  static T MeanRA(const std::vector<T>& raValues) {
+    std::vector<T> sorted(raValues);
+    for (size_t i = 0; i != sorted.size(); ++i) {
+      while (sorted[i] >= 2 * M_PI) sorted[i] -= 2.0 * M_PI;
+      while (sorted[i] < 0.0) sorted[i] += 2.0 * M_PI;
+    }
+    std::sort(sorted.begin(), sorted.end());
+    T gapSize = 0.0;
+    T gapCentre = 0.0;
+    for (size_t i = 0; i != sorted.size(); ++i) {
+      double dist;
+      if (i == sorted.size() - 1)
+        dist = 2.0 * M_PI + sorted.front() - sorted.back();
+      else
+        dist = sorted[i + 1] - sorted[i];
+      if (dist > gapSize) {
+        gapSize = dist;
+        gapCentre = sorted[i] + gapSize * 0.5;
+      }
+    }
+    if (gapCentre >= 2.0 * M_PI) gapCentre -= 2.0 * M_PI;
+    T sum = 0.0;
+    for (size_t i = 0; i != sorted.size(); ++i) {
+      if (sorted[i] < gapCentre)
+        sum += sorted[i];
+      else
+        sum += sorted[i] - 2.0 * M_PI;
+    }
+    sum /= sorted.size();
+    if (sum < 0.0)
+      return sum + 2.0 * M_PI;
+    else
+      return sum;
+  }
+
+ private:
+  ImageCoordinates() = delete;
+};
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/io/serialistream.h b/external/aocommon/include/aocommon/io/serialistream.h
new file mode 100644
index 0000000..847f558
--- /dev/null
+++ b/external/aocommon/include/aocommon/io/serialistream.h
@@ -0,0 +1,216 @@
+#ifndef AOCOMMON_IO_SERIAL_ISTREAM_H_
+#define AOCOMMON_IO_SERIAL_ISTREAM_H_
+
+#include "../uvector.h"
+#include "serialostream.h"
+
+#include <complex>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+namespace aocommon {
+
+class SerialIStream {
+ public:
+  SerialIStream(UVector<unsigned char>&& buffer)
+      : _buffer(std::move(buffer)), _position(_buffer.begin()) {}
+
+  SerialIStream(SerialOStream&& oStream)
+      : _buffer(std::move(oStream._buffer)), _position(_buffer.begin()) {}
+
+  size_t size() const { return _buffer.size(); }
+
+  const unsigned char* data() const { return _buffer.data(); }
+
+  std::string ToString() const {
+    return std::string(reinterpret_cast<const char*>(_buffer.data()), size());
+  }
+
+  const unsigned char* Chunk(size_t size) {
+    const unsigned char* chunk = &*_position;
+    _position += size;
+    return chunk;
+  }
+
+  template <typename T>
+  SerialIStream& UInt64(T& value) {
+    value = (T)read<uint64_t>();
+    return *this;
+  }
+
+  uint64_t UInt64() { return read<uint64_t>(); }
+
+  template <typename T>
+  SerialIStream& UInt32(T& value) {
+    value = (T)read<uint32_t>();
+    return *this;
+  }
+
+  uint32_t UInt32() { return read<uint32_t>(); }
+
+  template <typename T>
+  SerialIStream& UInt16(T& value) {
+    value = (T)read<uint16_t>();
+    return *this;
+  }
+
+  uint16_t UInt16() { return read<uint16_t>(); }
+
+  template <typename T>
+  SerialIStream& UInt8(T& value) {
+    value = (T)read<uint8_t>();
+    return *this;
+  }
+
+  uint8_t UInt8() { return read<uint8_t>(); }
+
+  SerialIStream& Bool(bool& value) {
+    value = (UInt8() != 0);
+    return *this;
+  }
+
+  bool Bool() { return UInt8() != 0; }
+
+  SerialIStream& Float(float& value) { return read(value); }
+
+  float Float() { return read<float>(); }
+
+  SerialIStream& Double(double& value) { return read(value); }
+
+  double Double() { return read<double>(); }
+
+  SerialIStream& LDouble(long double& value) { return read(value); }
+
+  long double LDouble() { return read<long double>(); }
+
+  SerialIStream& CFloat(std::complex<float>& value) { return read(value); }
+
+  std::complex<float> CFloat() { return read<std::complex<float>>(); }
+
+  SerialIStream& CDouble(std::complex<double>& value) { return read(value); }
+
+  std::complex<double> CDouble() { return read<std::complex<double>>(); }
+
+  SerialIStream& CLDouble(std::complex<long double>& value) {
+    return read(value);
+  }
+
+  long double CLDouble() { return read<long double>(); }
+
+  SerialIStream& String(std::string& str) {
+    size_t n = UInt64();
+    const unsigned char* block = Chunk(n);
+    str.resize(n);
+    std::copy_n(block, n, str.begin());
+    return *this;
+  }
+
+  std::string String() {
+    size_t n = UInt64();
+    const unsigned char* block = Chunk(n);
+    std::string str(n, 0);
+    std::copy_n(block, n, str.begin());
+    return str;
+  }
+
+  /**
+   * Read a vector of fixed-size literal values from the stream.
+   * @tparam T A type whose size is fixed across architectures, e.g. int32_t.
+   */
+  template <typename T>
+  SerialIStream& Vector(std::vector<T>& values) {
+    uint64_t size = UInt64();
+    values.resize(size);
+    size_t n = size * sizeof(T);
+    const unsigned char* block = Chunk(n);
+    unsigned char* valuePtr = reinterpret_cast<unsigned char*>(values.data());
+    std::copy_n(block, n, valuePtr);
+    return *this;
+  }
+
+  /**
+   * Read a vector with 64-bit unsigned integers from the stream into a vector
+   * of non-fixed-sized literal values.
+   * @tparam T A literal type whose size may differ across architectures, e.g.
+   * size_t. The size should fit in 64 bits on all architectures.
+   */
+  template <typename T>
+  SerialIStream& VectorUInt64(std::vector<T>& values) {
+    static_assert(sizeof(T) <= sizeof(uint64_t),
+                  "Vector value type is larger than 64 bits");
+    uint64_t size = UInt64();
+    values.clear();
+    values.reserve(size);
+    for (size_t i = 0; i < size; ++i) {
+      values.push_back(UInt64());
+    }
+    return *this;
+  }
+
+  /**
+   * Read an object from the stream using its Unserialize function.
+   * @tparam T Object type, which must implement Unserialize(SerialIStream&).
+   * @param object The object instance that must be read.
+   * @return A reference to the stream, for chaining reads.
+   */
+  template <typename T>
+  SerialIStream& Object(T& object) {
+    object.Unserialize(*this);
+    return *this;
+  }
+
+  /**
+   * Read a vector of objects from the stream.
+   * @tparam T Object type, which must implement Unserialize(SerialIStream&).
+   */
+  template <typename T>
+  SerialIStream& ObjectVector(std::vector<T>& objects) {
+    uint64_t size = UInt64();
+    objects.resize(size);
+    for (T& object : objects) {
+      object.Unserialize(*this);
+    }
+    return *this;
+  }
+
+  template <typename T>
+  SerialIStream& Ptr(std::unique_ptr<T>& ptr) {
+    return readPtr(ptr);
+  }
+
+  template <typename T>
+  SerialIStream& Ptr(std::shared_ptr<T>& ptr) {
+    return readPtr(ptr);
+  }
+
+ private:
+  template <typename T>
+  SerialIStream& read(T& value) {
+    value = *reinterpret_cast<const T*>(Chunk(sizeof(T)));
+    return *this;
+  }
+
+  template <typename T>
+  T read() {
+    return *reinterpret_cast<const T*>(Chunk(sizeof(T)));
+  }
+
+  template <typename PtrT>
+  SerialIStream& readPtr(PtrT& ptr) {
+    if (Bool()) {
+      ptr.reset(new typename std::remove_reference<decltype(*ptr)>::type());
+      ptr->Unserialize(*this);
+    } else {
+      ptr.reset();
+    }
+    return *this;
+  }
+
+  UVector<unsigned char> _buffer;
+  UVector<unsigned char>::const_iterator _position;
+};
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/io/serialostream.h b/external/aocommon/include/aocommon/io/serialostream.h
new file mode 100644
index 0000000..7c53332
--- /dev/null
+++ b/external/aocommon/include/aocommon/io/serialostream.h
@@ -0,0 +1,165 @@
+#ifndef AOCOMMON_IO_SERIAL_OSTREAM_H_
+#define AOCOMMON_IO_SERIAL_OSTREAM_H_
+
+#include "../uvector.h"
+
+#include <complex>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+namespace aocommon {
+
+class SerialOStream {
+ public:
+  SerialOStream() {}
+
+  size_t size() const { return _buffer.size(); }
+
+  const unsigned char* data() const { return _buffer.data(); }
+  unsigned char* data() { return _buffer.data(); }
+
+  std::string ToString() const {
+    return std::string(reinterpret_cast<const char*>(_buffer.data()), size());
+  }
+
+  unsigned char* Chunk(size_t size) {
+    _buffer.resize(_buffer.size() + size);
+    return &*(_buffer.end() - size);
+  }
+
+  template <typename T>
+  SerialOStream& UInt64(T value) {
+    return write<uint64_t>(value);
+  }
+
+  template <typename T>
+  SerialOStream& UInt32(T value) {
+    return write<uint32_t>(value);
+  }
+
+  template <typename T>
+  SerialOStream& UInt16(T value) {
+    return write<uint16_t>(value);
+  }
+
+  template <typename T>
+  SerialOStream& UInt8(T value) {
+    return write<uint8_t>(value);
+  }
+
+  SerialOStream& Bool(bool value) { return UInt8(value ? 1 : 0); }
+
+  SerialOStream& Float(float value) { return write(value); }
+
+  SerialOStream& Double(double value) { return write(value); }
+
+  SerialOStream& LDouble(long double value) { return write(value); }
+
+  SerialOStream& CFloat(std::complex<float> value) { return write(value); }
+
+  SerialOStream& CDouble(std::complex<double> value) { return write(value); }
+
+  SerialOStream& CLDouble(std::complex<long double> value) {
+    return write(value);
+  }
+
+  SerialOStream& String(const std::string& str) {
+    UInt64(str.size());
+    unsigned char* block = Chunk(str.size());
+    std::copy(str.begin(), str.end(), block);
+    return *this;
+  }
+
+  /**
+   * Add a vector of fixed size values to the stream.
+   * @tparam T Value type. The value size must be equal on all architectures.
+   *         For example float and int32_t always use 32 bits.
+   */
+  template <typename T>
+  SerialOStream& Vector(const std::vector<T>& values) {
+    uint64_t size = values.size();
+    UInt64(size);
+    size_t n = values.size() * sizeof(T);
+    unsigned char* block = Chunk(n);
+    const unsigned char* valuePtr =
+        reinterpret_cast<const unsigned char*>(values.data());
+    std::copy_n(valuePtr, n, block);
+    return *this;
+  }
+
+  /**
+   * Add a vector of possibly varying size values to the stream. For example,
+   * sizeof(size_t) may differ between architectures. This function always
+   * uses 64 bits for encoding the values.
+   * @tparam T Value type. The value size may differ between architectures,
+   *         but should be at most 64 bits on all architectures.
+   */
+  template <typename T>
+  SerialOStream& VectorUInt64(const std::vector<T>& values) {
+    static_assert(sizeof(T) <= sizeof(uint64_t),
+                  "Vector value type is larger than 64 bits");
+    UInt64(values.size());
+    for (const T& v : values) UInt64(v);
+    return *this;
+  }
+
+  /**
+   * Write an object to the stream using its Serialize function.
+   * @tparam T Object type, which must implement Serialize(SerialOStream&).
+   * @param object The object instance that must be written.
+   * @return A reference to the stream, for chaining writes.
+   */
+  template <typename T>
+  SerialOStream& Object(const T& object) {
+    object.Serialize(*this);
+    return *this;
+  }
+
+  /**
+   * Write a vector of objects to the stream.
+   * @tparam T Object type, which must implement Serialize(SerialOStream&)
+   */
+  template <typename T>
+  SerialOStream& ObjectVector(const std::vector<T>& objects) {
+    UInt64(objects.size());
+    for (const T& o : objects) o.Serialize(*this);
+    return *this;
+  }
+
+  template <typename T>
+  SerialOStream& Ptr(const std::unique_ptr<T>& ptr) {
+    return writePtr(ptr);
+  }
+
+  template <typename T>
+  SerialOStream& Ptr(const std::shared_ptr<T>& ptr) {
+    return writePtr(ptr);
+  }
+
+ private:
+  friend class SerialIStream;
+
+  template <typename T>
+  SerialOStream& write(T value) {
+    *reinterpret_cast<T*>(Chunk(sizeof(T))) = value;
+    return *this;
+  }
+
+  template <typename PtrT>
+  SerialOStream& writePtr(const PtrT& ptr) {
+    if (ptr) {
+      Bool(true);
+      ptr->Serialize(*this);
+    } else {
+      Bool(false);
+    }
+    return *this;
+  }
+
+  UVector<unsigned char> _buffer;
+};
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/io/serialstreamfwd.h b/external/aocommon/include/aocommon/io/serialstreamfwd.h
new file mode 100644
index 0000000..eb45dfc
--- /dev/null
+++ b/external/aocommon/include/aocommon/io/serialstreamfwd.h
@@ -0,0 +1,11 @@
+#ifndef AOCOMMON_IO_SERIAL_STREAM_FWD_H_
+#define AOCOMMON_IO_SERIAL_STREAM_FWD_H_
+
+// This header contains the forward declarations for the streaming classes.
+
+namespace aocommon {
+class SerialIStream;
+class SerialOStream;
+}  // namespace aocommon
+
+#endif
\ No newline at end of file
diff --git a/external/aocommon/include/aocommon/lane.h b/external/aocommon/include/aocommon/lane.h
new file mode 100644
index 0000000..51e26f9
--- /dev/null
+++ b/external/aocommon/include/aocommon/lane.h
@@ -0,0 +1,572 @@
+#ifndef AOCOMMON_LANE_11_H_
+#define AOCOMMON_LANE_11_H_
+
+#include <condition_variable>
+#include <cstring>
+#include <deque>
+#include <mutex>
+
+/**
+ * @file
+ * Internal header file for the Lane.
+ * @headername{Lane.h}
+ */
+
+//#define LANE_DEBUG_MODE
+
+#ifdef LANE_DEBUG_MODE
+#include <cmath>
+#include <iostream>
+#include <sstream>
+#include <string>
+#endif
+
+namespace aocommon {
+
+#ifdef LANE_DEBUG_MODE
+#define set_lane_debug_name(lane, str) (lane).setDebugName(str)
+#define LANE_REGISTER_DEBUG_INFO registerDebugInfo()
+#define LANE_REGISTER_DEBUG_WRITE_WAIT registerDebugWriteWait()
+#define LANE_REGISTER_DEBUG_READ_WAIT registerDebugReadWait()
+#define LANE_REPORT_DEBUG_INFO reportDebugInfo()
+
+#else
+
+#define set_lane_debug_name(lane, str)
+#define LANE_REGISTER_DEBUG_INFO
+#define LANE_REGISTER_DEBUG_WRITE_WAIT
+#define LANE_REGISTER_DEBUG_READ_WAIT
+#define LANE_REPORT_DEBUG_INFO
+
+#endif
+
+/**
+ * @brief The Lane is an efficient cyclic buffer that is synchronized.
+ * @details
+ * A Lane can typically be used in a multi-threaded producer-consumer
+ * situation. The Lane also holds a state which allows for
+ * an ellegant way of communicating from producer(s) to
+ * consumer(s) that all data has been produced.
+ *
+ * A simple example:
+ * @code
+ * void producer(Lane<Task>* taskLane)
+ * {
+ *   while(moreTasks)
+ *     taskLane->write(nextTask());
+ *   taskLane->write_end();
+ * }
+ *
+ * void consumer(Lane<Task>* taskLane)
+ * {
+ *   Task task;
+ *   while(taskLane->read(task))
+ *     processTask(task);
+ * }
+ *
+ * void run()
+ * {
+ *   Lane<Task> taskLane;
+ *   std::thread consumerThread(&consumer(), &taskLane);
+ *   producer(&taskLane);
+ *   consumerThread.join();
+ * }
+ * @endcode
+ *
+ * The various read and write methods, as well as the empty(),
+ * capacity() and size() methods are always thread safe. The other
+ * methods are not: assignment, swap(), clear() and resize() can not
+ * be called from a different thread while another thread is also
+ * accessing the Lane. The same holds obviously for the constructors
+ * and destructor. This is chosen because these methods should almost never
+ * be called in parallel with other methods, and hence it is not worth
+ * to increase every call with extra locks to make this possible.
+ *
+ * With one reader and one writer, the order is guaranteed to be consistent.
+ * With multiple readers or writers in combination with multi-element
+ * write or read functions, a sequence of symbols might be interrupted. For
+ * example, if a multi-element write() won't fit completely in the buffer,
+ * the thread will wait for free space. Another thread might get now write
+ * access first, causing the single call to the multi-element write to be
+ * "split up".
+ *
+ * @author Andre Offringa
+ * @tparam Tp Type of elements to be stored in the Lane.
+ */
+template <typename Tp>
+class Lane {
+ public:
+  /** @brief Integer type used to store size types. */
+  typedef std::size_t size_type;
+
+  /** @brief Type of elements stored in the Lane. */
+  typedef Tp value_type;
+
+  /** @brief Construct a Lane with zero elements.
+   * @details A Lane with zero elements can not be written to or read to
+   * (both operations will wait forever).
+   *
+   * This constructor makes it easy to construct e.g. a container
+   * of Lanes. After the container is created, the Lanes can be
+   * resized with @ref resize().
+   */
+  Lane() noexcept
+      : _buffer(nullptr),
+        _capacity(0),
+        _write_position(0),
+        _free_write_space(0),
+        _status(status_normal) {}
+
+  /** @brief Construct a Lane with the given capacity.
+   * @details After construction, the Lane is ready for writing to and reading
+   * from.
+   * @param capacity Number of elements that the Lane can hold at once.
+   */
+  explicit Lane(size_t capacity)
+      : _buffer(new Tp[capacity]),
+        _capacity(capacity),
+        _write_position(0),
+        _free_write_space(_capacity),
+        _status(status_normal) {}
+
+  Lane(const Lane<Tp>& source) = delete;
+
+  /** @brief Move construct a Lane.
+   * @details This operation is not thread safe: the behaviour is undefined when
+   * other threads access the source Lane.
+   * @param source Original Lane to be moved from.
+   */
+  Lane(Lane<Tp>&& source) noexcept
+      : _buffer(nullptr),
+        _capacity(0),
+        _write_position(0),
+        _free_write_space(0),
+        _status(status_normal) {
+    swap(source);
+  }
+
+  /** @brief Destructor.
+   * @details The destructor is not synchronized.
+   */
+  ~Lane() {
+    LANE_REPORT_DEBUG_INFO;
+    delete[] _buffer;
+  }
+
+  Lane<Tp>& operator=(const Lane<Tp>& source) = delete;
+
+  /** @brief Move assignment.
+   * @details This operation is not thread safe: the behaviour is undefined when
+   * other threads access the source Lane.
+   * @param source Original Lane to be moved from.
+   * @returns This Lane.
+   */
+  Lane<Tp>& operator=(Lane<Tp>&& source) noexcept {
+    swap(source);
+    return *this;
+  }
+
+  /** @brief Swap the contents of this Lane with another.
+   * @details This operation is not thread safe: the behaviour is undefined when
+   * other threads access either Lane.
+   */
+  void swap(Lane<Tp>& other) noexcept {
+    std::swap(_buffer, other._buffer);
+    std::swap(_capacity, other._capacity);
+    std::swap(_write_position, other._write_position);
+    std::swap(_free_write_space, other._free_write_space);
+    std::swap(_status, other._status);
+  }
+
+  /** @brief Clear the contents and reset the state of the Lane.
+   * @details After calling clear(), the Lane is in the same state as after
+   * construction. This also means that after clearing the Lane, it
+   * is as if write_end() has not been called yet.
+   *
+   * This method is not thread safe.
+   */
+  void clear() noexcept {
+    _write_position = 0;
+    _free_write_space = _capacity;
+    _status = status_normal;
+  }
+
+  /** @brief Write a single element.
+   * @details This method is thread safe, and can be called together with
+   * other write and read methods from different threads.
+   *
+   * If this call comes after a call to write_end(), the call
+   * will be ignored.
+   * @param element Object to be copied into the cyclic buffer.
+   */
+  void write(const value_type& element) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    if (_status == status_normal) {
+      while (_free_write_space == 0) {
+        LANE_REGISTER_DEBUG_WRITE_WAIT;
+        _writing_possible_condition.wait(lock);
+      }
+
+      _buffer[_write_position] = element;
+      _write_position = (_write_position + 1) % _capacity;
+      --_free_write_space;
+      // Now that there is less free write space, there is more free read
+      // space and thus readers can possibly continue.
+      _reading_possible_condition.notify_all();
+    }
+  }
+
+  /** @brief Write a single element by constructing it.
+   * @details This method is thread safe, and can be called together with
+   * other write and read methods from different threads.
+   *
+   * If this call comes after a call to write_end(), the call
+   * will be ignored. The implementation does not construct the value
+   * in place, but rather constructs the value and then move assigns it.
+   * This is because the value that it is moved into has already been
+   * constructed (in the current implementation).
+   * @param element Object to be moved into the cyclic buffer.
+   */
+  template <typename... Args>
+  void emplace(Args&&... args) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    if (_status == status_normal) {
+      while (_free_write_space == 0) {
+        LANE_REGISTER_DEBUG_WRITE_WAIT;
+        _writing_possible_condition.wait(lock);
+      }
+
+      _buffer[_write_position] = value_type(std::forward<Args>(args)...);
+      _write_position = (_write_position + 1) % _capacity;
+      --_free_write_space;
+      // Now that there is less free write space, there is more free read
+      // space and thus readers can possibly continue.
+      _reading_possible_condition.notify_all();
+    }
+  }
+
+  /** @brief Write a single element by moving it in.
+   * @details This method is thread safe, and can be called together with
+   * other write and read methods from different threads.
+   *
+   * If this call comes after a call to write_end(), the call
+   * will be ignored.
+   * @param element Object to be moved into the cyclic buffer.
+   */
+  void write(value_type&& element) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    if (_status == status_normal) {
+      while (_free_write_space == 0) {
+        LANE_REGISTER_DEBUG_WRITE_WAIT;
+        _writing_possible_condition.wait(lock);
+      }
+
+      _buffer[_write_position] = std::move(element);
+      _write_position = (_write_position + 1) % _capacity;
+      --_free_write_space;
+      // Now that there is less free write space, there is more free read
+      // space and thus readers can possibly continue.
+      _reading_possible_condition.notify_all();
+    }
+  }
+
+  void write(const value_type* elements, size_t n) {
+    write_generic(elements, n);
+  }
+
+  void move_write(value_type* elements, size_t n) {
+    write_generic(elements, n);
+  }
+
+  bool read(value_type& destination) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+    while (free_read_space() == 0 && _status == status_normal) {
+      LANE_REGISTER_DEBUG_READ_WAIT;
+      _reading_possible_condition.wait(lock);
+    }
+    if (free_read_space() == 0)
+      return false;
+    else {
+      destination = std::move(_buffer[read_position()]);
+      ++_free_write_space;
+      // Now that there is more free write space, writers can possibly continue.
+      _writing_possible_condition.notify_all();
+      return true;
+    }
+  }
+
+  size_t read(value_type* destinations, size_t n) {
+    size_t n_left = n;
+
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    size_t free_space = free_read_space();
+    size_t read_size = free_space > n ? n : free_space;
+    immediate_read(destinations, read_size);
+    n_left -= read_size;
+
+    while (n_left != 0 && _status == status_normal) {
+      destinations += read_size;
+
+      do {
+        LANE_REGISTER_DEBUG_READ_WAIT;
+        _reading_possible_condition.wait(lock);
+      } while (free_read_space() == 0 && _status == status_normal);
+
+      free_space = free_read_space();
+      read_size = free_space > n_left ? n_left : free_space;
+      immediate_read(destinations, read_size);
+      n_left -= read_size;
+    }
+    return n - n_left;
+  }
+
+  /**
+   * This method does the same thing as read(buffer, n) but discards the data.
+   * This eliminates the requirement to specify a buffer if the data is not
+   * necessary anyway, and avoids a copy of the data.
+   */
+  size_t discard(size_t n) {
+    size_t n_left = n;
+
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    size_t free_space = free_read_space();
+    size_t read_size = free_space > n ? n : free_space;
+    immediate_discard(read_size);
+    n_left -= read_size;
+
+    while (n_left != 0 && _status == status_normal) {
+      do {
+        LANE_REGISTER_DEBUG_READ_WAIT;
+        _reading_possible_condition.wait(lock);
+      } while (free_read_space() == 0 && _status == status_normal);
+
+      free_space = free_read_space();
+      read_size = free_space > n_left ? n_left : free_space;
+      immediate_discard(read_size);
+      n_left -= read_size;
+    }
+    return n - n_left;
+  }
+
+  void write_end() {
+    std::lock_guard<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+    _status = status_end;
+    _writing_possible_condition.notify_all();
+    _reading_possible_condition.notify_all();
+  }
+
+  size_t capacity() const noexcept { return _capacity; }
+
+  size_t size() const {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _capacity - _free_write_space;
+  }
+
+  bool empty() const {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _capacity == _free_write_space;
+  }
+
+  /**
+   * Change the capacity of the Lane. This will erase all data in the Lane.
+   */
+  void resize(size_t new_capacity) {
+    Tp* new_buffer = new Tp[new_capacity];
+    delete[] _buffer;
+    _buffer = new_buffer;
+    _capacity = new_capacity;
+    _write_position = 0;
+    _free_write_space = new_capacity;
+    _status = status_normal;
+  }
+
+  /**
+   * Wait until this Lane is empty.
+   */
+  void wait_for_empty() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (_capacity != _free_write_space) {
+      _writing_possible_condition.wait(lock);
+    }
+  }
+
+#ifdef LANE_DEBUG_MODE
+  /**
+   * Change the name of this Lane to make it appear in the output along
+   * with statistics. Do not use this function directly; use the
+   * set_lane_debug_name() macro instead.
+   * @param nameStr New debug description of this Lane.
+   */
+  void setDebugName(const std::string& nameStr) { _debugName = nameStr; }
+#endif
+ private:
+  Tp* _buffer;
+
+  size_t _capacity;
+
+  size_t _write_position;
+
+  size_t _free_write_space;
+
+  enum { status_normal, status_end } _status;
+
+  mutable std::mutex _mutex;
+
+  std::condition_variable _writing_possible_condition,
+      _reading_possible_condition;
+
+  size_t read_position() const noexcept {
+    return (_write_position + _free_write_space) % _capacity;
+  }
+
+  size_t free_read_space() const noexcept {
+    return _capacity - _free_write_space;
+  }
+
+  // This is a template to allow const and non-const (to be able to move)
+  template <typename T>
+  void write_generic(T* elements, size_t n) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    if (_status == status_normal) {
+      size_t write_size = _free_write_space > n ? n : _free_write_space;
+      immediate_write(elements, write_size);
+      n -= write_size;
+
+      while (n != 0) {
+        elements += write_size;
+
+        do {
+          LANE_REGISTER_DEBUG_WRITE_WAIT;
+          _writing_possible_condition.wait(lock);
+        } while (_free_write_space == 0 && _status == status_normal);
+
+        write_size = _free_write_space > n ? n : _free_write_space;
+        immediate_write(elements, write_size);
+        n -= write_size;
+      }
+      while (n != 0)
+        ;
+    }
+  }
+
+  // This is a template to allow const and non-const (to be able to move)
+  template <typename T>
+  void immediate_write(T* elements, size_t n) noexcept {
+    // Split the writing in two ranges if needed. The first range fits in
+    // [_write_position, _capacity), the second range in [0, end). By doing
+    // so, we only have to calculate the modulo in the write position once.
+    if (n > 0) {
+      size_t nPart;
+      if (_write_position + n > _capacity) {
+        nPart = _capacity - _write_position;
+      } else {
+        nPart = n;
+      }
+      for (size_t i = 0; i < nPart; ++i, ++_write_position) {
+        _buffer[_write_position] = std::move(elements[i]);
+      }
+
+      _write_position = _write_position % _capacity;
+
+      for (size_t i = nPart; i < n; ++i, ++_write_position) {
+        _buffer[_write_position] = std::move(elements[i]);
+      }
+
+      _free_write_space -= n;
+
+      // Now that there is less free write space, there is more free read
+      // space and thus readers can possibly continue.
+      _reading_possible_condition.notify_all();
+    }
+  }
+
+  void immediate_read(value_type* elements, size_t n) noexcept {
+    // As with write, split in two ranges if needed. The first range fits in
+    // [read_position(), _capacity), the second range in [0, end).
+    if (n > 0) {
+      size_t nPart;
+      size_t position = read_position();
+      if (position + n > _capacity) {
+        nPart = _capacity - position;
+      } else {
+        nPart = n;
+      }
+      for (size_t i = 0; i < nPart; ++i, ++position) {
+        elements[i] = std::move(_buffer[position]);
+      }
+
+      position = position % _capacity;
+
+      for (size_t i = nPart; i < n; ++i, ++position) {
+        elements[i] = std::move(_buffer[position]);
+      }
+
+      _free_write_space += n;
+
+      // Now that there is more free write space, writers can possibly continue.
+      _writing_possible_condition.notify_all();
+    }
+  }
+
+  void immediate_discard(size_t n) noexcept {
+    if (n > 0) {
+      _free_write_space += n;
+
+      // Now that there is more free write space, writers can possibly continue.
+      _writing_possible_condition.notify_all();
+    }
+  }
+
+#ifdef LANE_DEBUG_MODE
+  void registerDebugInfo() noexcept {
+    _debugSummedSize += _capacity - _free_write_space;
+    _debugMeasureCount++;
+  }
+  void registerDebugReadWait() noexcept { ++_debugReadWaitCount; }
+  void registerDebugWriteWait() noexcept { ++_debugWriteWaitCount; }
+  void reportDebugInfo() {
+    if (!_debugName.empty()) {
+      std::stringstream str;
+      str << "*** Debug report for the following Lane: ***\n"
+          << "\"" << _debugName << "\"\n"
+          << "Capacity: " << _capacity << '\n'
+          << "Total read/write ops: " << _debugMeasureCount << '\n'
+          << "Average size of buffer, measured per read/write op.: "
+          << round(double(_debugSummedSize) * 100.0 / _debugMeasureCount) /
+                 100.0
+          << '\n'
+          << "Number of wait events during reading: " << _debugReadWaitCount
+          << '\n'
+          << "Number of wait events during writing: " << _debugWriteWaitCount
+          << '\n';
+      std::cout << str.str();
+    }
+  }
+  std::string _debugName;
+  size_t _debugSummedSize = 0, _debugMeasureCount = 0, _debugReadWaitCount = 0,
+         _debugWriteWaitCount = 0;
+#endif
+};
+
+template <typename Tp>
+void swap(aocommon::Lane<Tp>& first, aocommon::Lane<Tp>& second) noexcept {
+  first.swap(second);
+}
+
+}  // namespace aocommon
+
+#endif  // AO_LANE11_H
diff --git a/external/aocommon/include/aocommon/logger.h b/external/aocommon/include/aocommon/logger.h
new file mode 100644
index 0000000..2e0638f
--- /dev/null
+++ b/external/aocommon/include/aocommon/logger.h
@@ -0,0 +1,202 @@
+#ifndef AOCOMMON_LOGGER_H_
+#define AOCOMMON_LOGGER_H_
+
+#include <sstream>
+#include <iostream>
+
+#include <mutex>
+
+#include <boost/date_time/posix_time/posix_time.hpp>
+
+namespace aocommon {
+
+class Logger {
+ public:
+  enum LoggerLevel {
+    kNoLevel = 5,
+    kFatalLevel = 4,
+    kErrorLevel = 3,
+    kWarningLevel = 2,
+    kInfoLevel = 1,
+    kDebugLevel = 0
+  };
+
+  enum VerbosityLevel { kQuietVerbosity, kNormalVerbosity, kVerboseVerbosity };
+
+  template <LoggerLevel Level>
+  class LogWriter {
+   public:
+    /**
+     * @brief Construct a new Log Writer object. Requires explicitly specifying
+     * the output stream object, to enable testing. Internal to the @ref Logger
+     * class, only std::cout will be used.
+     */
+    explicit LogWriter(std::ostream& output)
+        : output_(output), at_new_line_(true) {}
+
+    LogWriter& operator<<(const std::string& str) {
+      std::lock_guard<std::mutex> lock(mutex_);
+      size_t start = 0;
+      size_t end;
+      while (std::string::npos != (end = str.find('\n', start))) {
+        OutputLinePart(str.substr(start, end - start + 1), true);
+        start = end + 1;
+      }
+      OutputLinePart(str.substr(start, str.size() - start), false);
+      return *this;
+    }
+    LogWriter& operator<<(const char* str) {
+      (*this) << std::string(str);
+      return *this;
+    }
+    LogWriter& operator<<(const char c) {
+      std::lock_guard<std::mutex> lock(mutex_);
+      OutputLinePart(std::string(1, c), c == '\n');
+      return *this;
+    }
+    template <typename S>
+    LogWriter& operator<<(const S& str) {
+      std::ostringstream stream;
+      stream << str;
+      (*this) << stream.str();
+      return *this;
+    }
+    void Flush() {
+      std::lock_guard<std::mutex> lock(mutex_);
+      output_.flush();
+    }
+
+   private:
+    std::mutex mutex_;
+    std::ostream& output_;
+    bool at_new_line_;
+
+    void OutputLinePart(const std::string& str, bool ends_with_cr) {
+      if ((int)cout_level_ <= (int)Level && !str.empty()) {
+        if (at_new_line_ && log_time_) OutputTime(output_);
+        output_ << str;
+        at_new_line_ = ends_with_cr;
+      }
+    }
+  };
+
+  static void SetVerbosity(VerbosityLevel verbosity_level) {
+    switch (verbosity_level) {
+      case kQuietVerbosity:
+        cout_level_ = kErrorLevel;
+        break;
+      case kNormalVerbosity:
+        cout_level_ = kInfoLevel;
+        break;
+      case kVerboseVerbosity:
+        cout_level_ = kDebugLevel;
+        break;
+    }
+  }
+
+  static bool IsVerbose() { return cout_level_ == kDebugLevel; }
+
+  static void SetLogTime(bool log_time) { log_time_ = log_time; }
+
+  static bool LogTime() { return log_time_; }
+
+  static inline LogWriter<kDebugLevel> Debug{std::cout};
+  static inline LogWriter<kInfoLevel> Info{std::cout};
+  static inline LogWriter<kWarningLevel> Warn{std::cout};
+  static inline LogWriter<kErrorLevel> Error{std::cout};
+  static inline LogWriter<kFatalLevel> Fatal{std::cout};
+
+ private:
+  Logger() = default;
+
+  static void OutputTime(std::ostream& output) {
+    boost::posix_time::ptime t(boost::posix_time::microsec_clock::local_time());
+    const std::string str = boost::posix_time::to_simple_string(t);
+    output << str << ' ';
+  }
+
+  static inline LoggerLevel cout_level_ = LoggerLevel::kInfoLevel;
+
+  static inline bool log_time_ = false;
+};
+
+class LogReceiver {
+ public:
+  LogReceiver()
+      : Fatal(this), Error(this), Warn(this), Info(this), Debug(this) {}
+
+  template <enum Logger::LoggerLevel Level>
+  class LevelReceiver {
+   public:
+    LevelReceiver(LogReceiver* parent) : parent_(parent) {}
+    LevelReceiver& operator<<(const std::string& str) {
+      size_t start = 0, end;
+      while (std::string::npos != (end = str.find('\n', start))) {
+        parent_->Output(Level, str.substr(start, end - start + 1));
+        start = end + 1;
+      }
+      parent_->Output(Level, str.substr(start, str.size() - start));
+      return *this;
+    }
+    LevelReceiver& operator<<(const char* str) {
+      (*this) << std::string(str);
+      return *this;
+    }
+    LevelReceiver& operator<<(const char c) {
+      parent_->Output(Level, std::string(1, c));
+      return *this;
+    }
+    template <typename S>
+    LevelReceiver& operator<<(const S& str) {
+      std::ostringstream stream;
+      stream << str;
+      (*this) << stream.str();
+      return *this;
+    }
+
+   private:
+    LogReceiver* parent_;
+  };  // end of class LevelReceiver
+
+  LevelReceiver<Logger::kFatalLevel> Fatal;
+  LevelReceiver<Logger::kErrorLevel> Error;
+  LevelReceiver<Logger::kWarningLevel> Warn;
+  LevelReceiver<Logger::kInfoLevel> Info;
+  LevelReceiver<Logger::kDebugLevel> Debug;
+
+ protected:
+  virtual void Output(enum Logger::LoggerLevel level,
+                      const std::string& str) = 0;
+
+  void Forward(enum Logger::LoggerLevel level, const std::string& str) {
+    switch (level) {
+      case Logger::kFatalLevel:
+        Logger::Fatal << str;
+        break;
+      case Logger::kErrorLevel:
+        Logger::Error << str;
+        break;
+      case Logger::kWarningLevel:
+        Logger::Warn << str;
+        break;
+      case Logger::kInfoLevel:
+        Logger::Info << str;
+        break;
+      case Logger::kDebugLevel:
+        Logger::Debug << str;
+        break;
+      case Logger::kNoLevel:
+        break;
+    }
+  }
+};
+
+class ForwardingLogReceiver final : public LogReceiver {
+ protected:
+  void Output(enum Logger::LoggerLevel level, const std::string& str) override {
+    Forward(level, str);
+  }
+};
+
+}  // namespace aocommon
+#endif
\ No newline at end of file
diff --git a/external/aocommon/include/aocommon/matrix2x2.h b/external/aocommon/include/aocommon/matrix2x2.h
new file mode 100644
index 0000000..8834d19
--- /dev/null
+++ b/external/aocommon/include/aocommon/matrix2x2.h
@@ -0,0 +1,1026 @@
+#ifndef AOCOMMON_MATRIX_2X2_H_
+#define AOCOMMON_MATRIX_2X2_H_
+
+#include <cmath>
+#include <complex>
+#include <limits>
+#include <sstream>
+
+namespace aocommon {
+
+template <typename T>
+class MC2x2DiagBase;
+
+/**
+ * Class implements a vector with length 4 of complex-valued doubles.
+ *
+ */
+class Vector4 {
+ public:
+  /**
+   * Default constructor
+   *
+   */
+  Vector4(){};
+
+  /**
+   * Construct a Vector4 object from four complex-valued numbers.
+   *
+   */
+  Vector4(std::complex<double> a, std::complex<double> b,
+          std::complex<double> c, std::complex<double> d) {
+    _data[0] = a;
+    _data[1] = b;
+    _data[2] = c;
+    _data[3] = d;
+  };
+
+  /**
+   * Index Vector4 object
+   */
+  std::complex<double>& operator[](size_t i) { return _data[i]; }
+  const std::complex<double>& operator[](size_t i) const { return _data[i]; }
+
+  /**
+   * Get pointer to underlying data
+   */
+  std::complex<double>* data() { return _data; }
+  const std::complex<double>* data() const { return _data; }
+
+ private:
+  std::complex<double> _data[4];
+};
+
+/**
+ * Class wraps functionality around a size 4 pointer
+ * as if it were a 2x2 matrix.
+ *
+ */
+class Matrix2x2 {
+ public:
+  /**
+   * Copy complex-valued source buffer to complex-valued dest buffer.
+   *
+   * TODO: seems redundant?
+   */
+  template <typename LHS_T, typename RHS_T>
+  static void Assign(std::complex<LHS_T>* dest,
+                     const std::complex<RHS_T>* source) {
+    for (size_t p = 0; p != 4; ++p) dest[p] = source[p];
+  }
+
+  /**
+   * Copy source buffer to dest buffer.
+   *
+   */
+  template <typename LHS_T, typename RHS_T>
+  static void Assign(LHS_T* dest, const RHS_T* source) {
+    for (size_t p = 0; p != 4; ++p) dest[p] = source[p];
+  }
+
+  /**
+   * Add assign rhs buffer to complex-valued dest buffer.
+   */
+  template <typename T, typename RHS_T>
+  static void Add(std::complex<T>* dest, const RHS_T* rhs) {
+    for (size_t p = 0; p != 4; ++p) dest[p] += rhs[p];
+  }
+
+  /**
+   * Subtract assign complex-valued rhs buffer to complex-valued dest buffer.
+   * Assumes that T and RHS_T admit an implicit conversion.
+   *
+   */
+  template <typename T>
+  static void Subtract(std::complex<T>* dest, const std::complex<T>* rhs) {
+    for (size_t p = 0; p != 4; ++p) dest[p] -= rhs[p];
+  }
+
+  /**
+   * Check if all entries in matrix are finite
+   */
+  template <typename T>
+  static bool IsFinite(const std::complex<T>* matrix) {
+    return std::isfinite(matrix[0].real()) && std::isfinite(matrix[0].imag()) &&
+           std::isfinite(matrix[1].real()) && std::isfinite(matrix[1].imag()) &&
+           std::isfinite(matrix[2].real()) && std::isfinite(matrix[2].imag()) &&
+           std::isfinite(matrix[3].real()) && std::isfinite(matrix[3].imag());
+  }
+
+  /**
+   * Scalar multiplication of matrix.
+   */
+  template <typename LHS_T, typename RHS_T>
+  static void ScalarMultiply(LHS_T* dest, RHS_T factor) {
+    for (size_t p = 0; p != 4; ++p) dest[p] *= factor;
+  }
+
+  /**
+   * Multiply rhs matrix with factor, then add assign to lhs matrix
+   */
+  template <typename T, typename RHS, typename FactorType>
+  static void MultiplyAdd(std::complex<T>* dest, const RHS* rhs,
+                          FactorType factor) {
+    for (size_t p = 0; p != 4; ++p) dest[p] += rhs[p] * factor;
+  }
+
+  /**
+   * Matrix multiplication
+   */
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void ATimesB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                      const RHS_T* rhs) {
+    dest[0] = lhs[0] * rhs[0] + lhs[1] * rhs[2];
+    dest[1] = lhs[0] * rhs[1] + lhs[1] * rhs[3];
+    dest[2] = lhs[2] * rhs[0] + lhs[3] * rhs[2];
+    dest[3] = lhs[2] * rhs[1] + lhs[3] * rhs[3];
+  }
+
+  /**
+   * Add assign matrix multiplication to destination buffer
+   *
+   * TODO: use templated type?
+   */
+  static void PlusATimesB(std::complex<double>* dest,
+                          const std::complex<double>* lhs,
+                          const std::complex<double>* rhs) {
+    dest[0] += lhs[0] * rhs[0] + lhs[1] * rhs[2];
+    dest[1] += lhs[0] * rhs[1] + lhs[1] * rhs[3];
+    dest[2] += lhs[2] * rhs[0] + lhs[3] * rhs[2];
+    dest[3] += lhs[2] * rhs[1] + lhs[3] * rhs[3];
+  }
+
+  /**
+   * Matrix multiplication of matrix a with the Hermitian transpose of matrix B,
+   * , i.e. A * B^H
+   *
+   * TODO: seems unnecessary to use three templated types
+   */
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void ATimesHermB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                          const RHS_T* rhs) {
+    dest[0] = lhs[0] * std::conj(rhs[0]) + lhs[1] * std::conj(rhs[1]);
+    dest[1] = lhs[0] * std::conj(rhs[2]) + lhs[1] * std::conj(rhs[3]);
+    dest[2] = lhs[2] * std::conj(rhs[0]) + lhs[3] * std::conj(rhs[1]);
+    dest[3] = lhs[2] * std::conj(rhs[2]) + lhs[3] * std::conj(rhs[3]);
+  }
+
+  /**
+   * Add assign matrix multiplication of matrix a with the
+   * Hermitian transpose of matrix B, i.e. A * B^H
+   *
+   * TODO: seems unnecessary to use three templated types
+   */
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void PlusATimesHermB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                              const RHS_T* rhs) {
+    dest[0] += lhs[0] * std::conj(rhs[0]) + lhs[1] * std::conj(rhs[1]);
+    dest[1] += lhs[0] * std::conj(rhs[2]) + lhs[1] * std::conj(rhs[3]);
+    dest[2] += lhs[2] * std::conj(rhs[0]) + lhs[3] * std::conj(rhs[1]);
+    dest[3] += lhs[2] * std::conj(rhs[2]) + lhs[3] * std::conj(rhs[3]);
+  }
+
+  /**
+   * Matrix multiplication of the Hermitian transpose of matrix A with matrix B,
+   * i.e. A^H * B
+   */
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void HermATimesB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                          const RHS_T* rhs) {
+    dest[0] = std::conj(lhs[0]) * rhs[0] + std::conj(lhs[2]) * rhs[2];
+    dest[1] = std::conj(lhs[0]) * rhs[1] + std::conj(lhs[2]) * rhs[3];
+    dest[2] = std::conj(lhs[1]) * rhs[0] + std::conj(lhs[3]) * rhs[2];
+    dest[3] = std::conj(lhs[1]) * rhs[1] + std::conj(lhs[3]) * rhs[3];
+  }
+
+  /**
+   * Matrix multiplication of the Hermitian transpose of matrix A with Hermitian
+   * transpose of B, i.e. A^H * B^H
+   */
+  static void HermATimesHermB(std::complex<double>* dest,
+                              const std::complex<double>* lhs,
+                              const std::complex<double>* rhs) {
+    dest[0] = std::conj(lhs[0]) * std::conj(rhs[0]) +
+              std::conj(lhs[2]) * std::conj(rhs[1]);
+    dest[1] = std::conj(lhs[0]) * std::conj(rhs[2]) +
+              std::conj(lhs[2]) * std::conj(rhs[3]);
+    dest[2] = std::conj(lhs[1]) * std::conj(rhs[0]) +
+              std::conj(lhs[3]) * std::conj(rhs[1]);
+    dest[3] = std::conj(lhs[1]) * std::conj(rhs[2]) +
+              std::conj(lhs[3]) * std::conj(rhs[3]);
+  }
+
+  /**
+   * Add assign matrix multiplication A^H * B to the destination buffer.
+   *
+   * TODO: seems redundant to template three types
+   */
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void PlusHermATimesB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                              const RHS_T* rhs) {
+    dest[0] += std::conj(lhs[0]) * rhs[0] + std::conj(lhs[2]) * rhs[2];
+    dest[1] += std::conj(lhs[0]) * rhs[1] + std::conj(lhs[2]) * rhs[3];
+    dest[2] += std::conj(lhs[1]) * rhs[0] + std::conj(lhs[3]) * rhs[2];
+    dest[3] += std::conj(lhs[1]) * rhs[1] + std::conj(lhs[3]) * rhs[3];
+  }
+
+  /**
+   * Compute matrix inverse
+   */
+  template <typename T>
+  static bool Invert(T* matrix) {
+    T d = ((matrix[0] * matrix[3]) - (matrix[1] * matrix[2]));
+    if (d == T(0.0)) return false;
+    T determinant_reciprocal = T(1.0) / d;
+    T temp;
+    temp = matrix[3] * determinant_reciprocal;
+    matrix[1] = -matrix[1] * determinant_reciprocal;
+    matrix[2] = -matrix[2] * determinant_reciprocal;
+    matrix[3] = matrix[0] * determinant_reciprocal;
+    matrix[0] = temp;
+    return true;
+  }
+
+  /**
+   * Compute conjugate transpose (a.k.a. Hermitian transpose) of matrix
+   */
+  template <typename T>
+  static void ConjugateTranspose(T* matrix) {
+    matrix[0] = std::conj(matrix[0]);
+    T temp = matrix[1];
+    matrix[1] = std::conj(matrix[2]);
+    matrix[2] = std::conj(temp);
+    matrix[3] = std::conj(matrix[3]);
+  }
+
+  /**
+   * Multiply lhs buffer with inverse of rhs buffer. Returns false if
+   * rhs not invertible.
+   */
+  static bool MultiplyWithInverse(std::complex<double>* lhs,
+                                  const std::complex<double>* rhs) {
+    std::complex<double> d = ((rhs[0] * rhs[3]) - (rhs[1] * rhs[2]));
+    if (d == 0.0) return false;
+    std::complex<double> determinant_reciprocal = 1.0 / d;
+    std::complex<double> temp[4];
+    temp[0] = rhs[3] * determinant_reciprocal;
+    temp[1] = -rhs[1] * determinant_reciprocal;
+    temp[2] = -rhs[2] * determinant_reciprocal;
+    temp[3] = rhs[0] * determinant_reciprocal;
+
+    std::complex<double> temp2 = lhs[0];
+    lhs[0] = lhs[0] * temp[0] + lhs[1] * temp[2];
+    lhs[1] = temp2 * temp[1] + lhs[1] * temp[3];
+
+    temp2 = lhs[2];
+    lhs[2] = lhs[2] * temp[0] + lhs[3] * temp[2];
+    lhs[3] = temp2 * temp[1] + lhs[3] * temp[3];
+    return true;
+  }
+
+  /**
+   * Compute singular values of the matrix buffer
+   */
+  static void SingularValues(const std::complex<double>* matrix, double& e1,
+                             double& e2) {
+    // This is not the ultimate fastest method, since we
+    // don't need to calculate the imaginary values of b,c at all.
+    // Calculate M M^H
+    std::complex<double> temp[4] = {
+        matrix[0] * std::conj(matrix[0]) + matrix[1] * std::conj(matrix[1]),
+        matrix[0] * std::conj(matrix[2]) + matrix[1] * std::conj(matrix[3]),
+        matrix[2] * std::conj(matrix[0]) + matrix[3] * std::conj(matrix[1]),
+        matrix[2] * std::conj(matrix[2]) + matrix[3] * std::conj(matrix[3])};
+    // Use quadratic formula, with a=1.
+    double b = -temp[0].real() - temp[3].real(),
+           c = temp[0].real() * temp[3].real() - (temp[1] * temp[2]).real(),
+           d = b * b - (4.0 * 1.0) * c, sqrtd = std::sqrt(d);
+
+    e1 = std::sqrt((-b + sqrtd) * 0.5);
+    e2 = std::sqrt((-b - sqrtd) * 0.5);
+  }
+
+  /**
+   * Compute eigen values of input matrix buffer. It assumes that the
+   * determinant > 0, so that eigenvalues are real.
+   */
+  static void EigenValues(const double* matrix, double& e1, double& e2) {
+    double tr = matrix[0] + matrix[3];
+    double d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    double term = std::sqrt(tr * tr * 0.25 - d);
+    double trHalf = tr * 0.5;
+    e1 = trHalf + term;
+    e2 = trHalf - term;
+  }
+
+  /**
+   * Compute the eigen values of a complex matrix.
+   *
+   * TODO: can probably be merged with previous method.
+   */
+  template <typename ValType>
+  static void EigenValues(const std::complex<ValType>* matrix,
+                          std::complex<ValType>& e1,
+                          std::complex<ValType>& e2) {
+    std::complex<ValType> tr = matrix[0] + matrix[3];
+    std::complex<ValType> d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    std::complex<ValType> term = std::sqrt(tr * tr * ValType(0.25) - d);
+    std::complex<ValType> trHalf = tr * ValType(0.5);
+    e1 = trHalf + term;
+    e2 = trHalf - term;
+  }
+
+  /**
+   * Compute eigen values and vectors for real matrix. Assumes
+   * the determinant > 0.
+   */
+  static void EigenValuesAndVectors(const double* matrix, double& e1,
+                                    double& e2, double* vec1, double* vec2) {
+    double tr = matrix[0] + matrix[3];
+    double d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    double term = std::sqrt(tr * tr * 0.25 - d);
+    double trHalf = tr * 0.5;
+    e1 = trHalf + term;
+    e2 = trHalf - term;
+    double limit = std::min(std::fabs(e1), std::fabs(e2)) * 1e-6;
+    if (std::fabs(matrix[2]) > limit) {
+      vec1[0] = matrix[3] - e1;
+      vec1[1] = -matrix[2];
+      vec2[0] = matrix[3] - e2;
+      vec2[1] = -matrix[2];
+    } else if (std::fabs(matrix[1]) > limit) {
+      vec1[0] = -matrix[1];
+      vec1[1] = matrix[0] - e1;
+      vec2[0] = -matrix[1];
+      vec2[1] = matrix[0] - e2;
+    } else {
+      // We know that A v = lambda v, and we know that v1 or v2 = [1, 0]:
+      double
+          // Evaluate for v = [1, 0] and see if the error is smaller for e1 than
+          // for e2
+          err1_0 = matrix[0] - e1,
+          err2_0 = matrix[0] - e2;
+      if (err1_0 * err1_0 < err2_0 * err2_0) {
+        vec1[0] = 1.0;
+        vec1[1] = 0.0;
+        vec2[0] = 0.0;
+        vec2[1] = 1.0;
+      } else {
+        vec1[0] = 0.0;
+        vec1[1] = 1.0;
+        vec2[0] = 1.0;
+        vec2[1] = 0.0;
+      }
+    }
+  }
+
+  /**
+   * Compute eigen values and vectors for complex-valued matrix. Assumes
+   * the determinant > 0.
+   *
+   * TODO: can probably be merged with previous method
+   */
+  static void EigenValuesAndVectors(const std::complex<double>* matrix,
+                                    std::complex<double>& e1,
+                                    std::complex<double>& e2,
+                                    std::complex<double>* vec1,
+                                    std::complex<double>* vec2) {
+    std::complex<double> tr = matrix[0] + matrix[3];
+    std::complex<double> d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    std::complex<double> term = std::sqrt(tr * tr * 0.25 - d);
+    std::complex<double> trHalf = tr * 0.5;
+    e1 = trHalf + term;
+    e2 = trHalf - term;
+    double limit = std::min(std::abs(e1), std::abs(e2)) * 1e-6;
+    if (std::abs(matrix[2]) > limit) {
+      vec1[0] = matrix[3] - e1;
+      vec1[1] = -matrix[2];
+      vec2[0] = matrix[3] - e2;
+      vec2[1] = -matrix[2];
+    } else if (std::abs(matrix[1]) > limit) {
+      vec1[0] = -matrix[1];
+      vec1[1] = matrix[0] - e1;
+      vec2[0] = -matrix[1];
+      vec2[1] = matrix[0] - e2;
+    } else {
+      // We know that A v = lambda v, and we know that v1 or v2 = [1, 0]:
+      auto
+          // Evaluate for v = [1, 0] and see if the error is smaller for e1 than
+          // for e2
+          err1_0 = std::norm(matrix[0] - e1),
+          err2_0 = std::norm(matrix[0] - e2);
+      if (err1_0 < err2_0) {
+        vec1[0] = 1.0;
+        vec1[1] = 0.0;
+        vec2[0] = 0.0;
+        vec2[1] = 1.0;
+      } else {
+        vec1[0] = 0.0;
+        vec1[1] = 1.0;
+        vec2[0] = 1.0;
+        vec2[1] = 0.0;
+      }
+    }
+  }
+
+  /**
+   * Computes the positive square root of a real-valued matrix buffer such that
+   * M = R * R. Assumes that determinant > 0. Note that matrix M might have more
+   * square roots.
+   */
+  static void SquareRoot(double* matrix) {
+    double tr = matrix[0] + matrix[3];
+    double d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    double s = /*+/-*/ std::sqrt(d);
+    double t = /*+/-*/ std::sqrt(tr + 2.0 * s);
+    if (t != 0.0) {
+      matrix[0] = (matrix[0] + s) / t;
+      matrix[1] = (matrix[1] / t);
+      matrix[2] = (matrix[2] / t);
+      matrix[3] = (matrix[3] + s) / t;
+    } else {
+      if (matrix[0] == 0.0 && matrix[1] == 0.0 && matrix[2] == 0.0 &&
+          matrix[3] == 0.0) {
+        // done: it's the zero matrix
+      } else {
+        for (size_t i = 0; i != 4; ++i)
+          matrix[i] = std::numeric_limits<double>::quiet_NaN();
+      }
+    }
+  }
+
+  /**
+   * Computes the positive square root of a complex-valued matrix buffer,
+   * such that M = R * R. Assumes that determinant > 0.
+   * Note that matrix M might have more square roots.
+   */
+  static void SquareRoot(std::complex<double>* matrix) {
+    std::complex<double> tr = matrix[0] + matrix[3];
+    std::complex<double> d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    std::complex<double> s = /*+/-*/ std::sqrt(d);
+    std::complex<double> t = /*+/-*/ std::sqrt(tr + 2.0 * s);
+    if (t != 0.0) {
+      matrix[0] = (matrix[0] + s) / t;
+      matrix[1] = (matrix[1] / t);
+      matrix[2] = (matrix[2] / t);
+      matrix[3] = (matrix[3] + s) / t;
+    } else {
+      if (matrix[0] == 0.0 && matrix[1] == 0.0 && matrix[2] == 0.0 &&
+          matrix[3] == 0.0) {
+        // done: it's the zero matrix
+      } else {
+        for (size_t i = 0; i != 4; ++i)
+          matrix[i] =
+              std::complex<double>(std::numeric_limits<double>::quiet_NaN(),
+                                   std::numeric_limits<double>::quiet_NaN());
+      }
+    }
+  }
+
+  /**
+   * Calculates L, the lower triangle of the Cholesky decomposition, such that
+   * L L^H = M. The result is undefined when the matrix is not positive
+   * definite.
+   */
+  static void UncheckedCholesky(std::complex<double>* matrix) {
+    // solve:
+    // ( a 0 ) ( a* b* ) = ( aa* ;    ab*    )
+    // ( b c ) ( 0  c* )   ( a*b ; bb* + cc* )
+    // With a and c necessarily real.
+    double a = std::sqrt(matrix[0].real());
+    std::complex<double> b = std::conj(matrix[1] / a);
+    double bbConj = b.real() * b.real() + b.imag() * b.imag();
+    double c = std::sqrt(matrix[3].real() - bbConj);
+    matrix[0] = a;
+    matrix[1] = 0.0;
+    matrix[2] = b;
+    matrix[3] = c;
+  }
+
+  /**
+   * Calculates L, the lower triangle of the Cholesky decomposition, such that
+   * L L^H = M. Return false when the result would not be finite.
+   */
+  static bool Cholesky(std::complex<double>* matrix) {
+    if (matrix[0].real() < 0.0) return false;
+    double a = std::sqrt(matrix[0].real());
+    std::complex<double> b = std::conj(matrix[1] / a);
+    double bbConj = b.real() * b.real() + b.imag() * b.imag();
+    double cc = matrix[3].real() - bbConj;
+    if (cc < 0.0) return false;
+    double c = std::sqrt(cc);
+    matrix[0] = a;
+    matrix[1] = 0.0;
+    matrix[2] = b;
+    matrix[3] = c;
+    return true;
+  }
+
+  /**
+   * Calculates L, the lower triangle of the Cholesky decomposition, such that
+   * L L^H = M. Return false when the matrix was not positive semi-definite.
+   */
+  static bool CheckedCholesky(std::complex<double>* matrix) {
+    if (matrix[0].real() <= 0.0 || matrix[0].imag() != 0.0 ||
+        matrix[3].real() <= 0.0 || matrix[3].imag() != 0.0 ||
+        matrix[1] != std::conj(matrix[2]))
+      return false;
+    UncheckedCholesky(matrix);
+    return true;
+  }
+
+  /**
+   * Calculates the rotation angle of a complex-valued matrix.
+   */
+  template <typename T>
+  static T RotationAngle(const std::complex<T>* matrix) {
+    return std::atan2((matrix[2].real() - matrix[1].real()) * 0.5,
+                      (matrix[0].real() + matrix[3].real()) * 0.5);
+  }
+
+  /**
+   * Calculates the rotation matrix, given a rotation angle \p alpha.
+   */
+  template <typename T>
+  static void RotationMatrix(std::complex<T>* matrix, double alpha) {
+    T cos_alpha = std::cos(alpha), sin_alpha = std::sin(alpha);
+    matrix[0] = cos_alpha;
+    matrix[1] = -sin_alpha;
+    matrix[2] = sin_alpha;
+    matrix[3] = cos_alpha;
+  }
+};
+
+/**
+ * Class implements a 2x2 complex-valued matrix.
+ */
+template <typename ValType>
+class MC2x2Base {
+ public:
+  MC2x2Base() {}
+
+  /**
+   * Copy constructor. Even though the template copy constructor below covers
+   * this case, the compiler declares this copy constructor implicitly, which
+   * is deprecated in C++11 -> Declare the copy constructor explicitly.
+   */
+  MC2x2Base(const MC2x2Base& source) = default;
+
+  template <typename OtherValType>
+  MC2x2Base(const MC2x2Base<OtherValType>& source) {
+    Matrix2x2::Assign(_values, source.Data());
+  }
+
+  /**
+   * Construct MC2x2Base object from (length 4) data buffer
+   */
+  template <typename T>
+  explicit MC2x2Base(const T source[4]) {
+    Matrix2x2::Assign(_values, source);
+  }
+
+  /**
+   * Construct MC2x2Base object from four input values. Internally, values are
+   * converted to complex type.
+   */
+  MC2x2Base(ValType m00, ValType m01, ValType m10, ValType m11) {
+    _values[0] = m00;
+    _values[1] = m01;
+    _values[2] = m10;
+    _values[3] = m11;
+  }
+
+  /**
+   * Construct MC2x2Base object from four complex-valued input values.
+   */
+  MC2x2Base(std::complex<ValType> m00, std::complex<ValType> m01,
+            std::complex<ValType> m10, std::complex<ValType> m11) {
+    _values[0] = m00;
+    _values[1] = m01;
+    _values[2] = m10;
+    _values[3] = m11;
+  }
+
+  /**
+   * Construct from a diagonal matrix
+   */
+  MC2x2Base(const MC2x2DiagBase<ValType>& diag);
+
+  /**
+   * Copy assignment operator
+   */
+  MC2x2Base<ValType>& operator=(const MC2x2Base<ValType>& source) {
+    Matrix2x2::Assign(_values, source._values);
+    return *this;
+  }
+
+  /**
+   * Addition operator
+   */
+  MC2x2Base<ValType> operator+(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> result(*this);
+    Matrix2x2::Add(result._values, rhs._values);
+    return result;
+  }
+
+  /**
+   * Addition assignment operator
+   */
+  MC2x2Base<ValType>& operator+=(const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::Add(_values, rhs._values);
+    return *this;
+  }
+
+  /**
+   * Subtraction assignment operator
+   */
+  MC2x2Base<ValType>& operator-=(const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::Subtract(_values, rhs._values);
+    return *this;
+  }
+
+  /**
+   * Matrix multiplication assignment operator
+   */
+  MC2x2Base<ValType>& operator*=(const MC2x2Base<ValType>& rhs) {
+    MC2x2Base<ValType> lhs(*this);
+    Matrix2x2::ATimesB(_values, lhs._values, rhs._values);
+    return *this;
+  }
+
+  /**
+   * Matrix multiplication operator
+   */
+  MC2x2Base<ValType> operator*(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::ATimesB(dest._values, _values, rhs._values);
+    return dest;
+  }
+
+  /**
+   * Matrix multiplication assignment operator given a length 4 rhs buffer
+   * of possibly different type
+   */
+  template <typename T>
+  MC2x2Base<ValType>& operator*=(const T* rhs) {
+    MC2x2Base<ValType> lhs(*this);
+    Matrix2x2::ATimesB(_values, lhs._values, rhs);
+    return *this;
+  }
+
+  /**
+   * Matrix multiplication given a length 4 rhs buffer of possibly different
+   * type
+   */
+  template <typename T>
+  MC2x2Base<ValType> operator*(const T* rhs) const {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::ATimesB(dest._values, _values, rhs);
+    return dest;
+  }
+
+  /**
+   * Scalar multiplication assignment operator
+   */
+  MC2x2Base<ValType>& operator*=(ValType rhs) {
+    Matrix2x2::ScalarMultiply(_values, rhs);
+    return *this;
+  }
+
+  /**
+   * Scalar multiplication operator
+   */
+  MC2x2Base<ValType> operator*(ValType rhs) const {
+    MC2x2Base<ValType> dest(*this);
+    Matrix2x2::ScalarMultiply(dest._values, rhs);
+    return dest;
+  }
+
+  /**
+   * Complex scalar multiplication
+   */
+  MC2x2Base<ValType> operator*(std::complex<ValType> rhs) const {
+    MC2x2Base<ValType> dest(*this);
+    Matrix2x2::ScalarMultiply(dest._values, rhs);
+    return dest;
+  }
+
+  /**
+   * Scalar division assignment operator
+   */
+  MC2x2Base<ValType>& operator/=(ValType rhs) {
+    Matrix2x2::ScalarMultiply(_values, ValType(1.0) / rhs);
+    return *this;
+  }
+
+  const std::complex<ValType>& operator[](size_t index) const {
+    return _values[index];
+  }
+  std::complex<ValType>& operator[](size_t index) { return _values[index]; }
+
+  /**
+   * Get real value at given index
+   */
+  const ValType& IndexReal(size_t index) const {
+    return reinterpret_cast<const ValType(&)[2]>(_values[index / 2])[index % 2];
+  }
+  ValType& IndexReal(size_t index) {
+    return reinterpret_cast<ValType(&)[2]>(_values[index / 2])[index % 2];
+  }
+
+  /**
+   * Return MC2x2Base matrix filled with zeros
+   */
+  static MC2x2Base<ValType> Zero() {
+    return MC2x2Base<ValType>(0.0, 0.0, 0.0, 0.0);
+  }
+
+  /**
+   * Return 2x2 identity matrix
+   */
+  static MC2x2Base<ValType> Unity() { return MC2x2Base(1.0, 0.0, 0.0, 1.0); }
+
+  /**
+   * Return 2x2 matrix filled with NaN values
+   */
+  static MC2x2Base<ValType> NaN() {
+    return MC2x2Base<ValType>(
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()),
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()),
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()),
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()));
+  }
+
+  /**
+   * Get pointer to underlying data
+   */
+  std::complex<ValType>* Data() { return _values; }
+  const std::complex<ValType>* Data() const { return _values; }
+
+  /**
+   * Assign data stored by 2x2 matrix to destination buffer
+   */
+  template <typename T>
+  void AssignTo(std::complex<T>* destination) const {
+    Matrix2x2::Assign(destination, _values);
+  }
+
+  /**
+   * Flatten 2x2 matrix to length 4 vector
+   */
+  Vector4 Vec() const {
+    return Vector4(_values[0], _values[2], _values[1], _values[3]);
+  }
+
+  /**
+   * Matrix multiplication, alias for the overloaded * operator
+   */
+  MC2x2Base<ValType> Multiply(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::ATimesB(dest._values, _values, rhs._values);
+    return dest;
+  }
+
+  /**
+   * Matrix multiplication of internal matrix with Hermitian transpose of input
+   * matrix, i.e. A * B^H
+   */
+  MC2x2Base<ValType> MultiplyHerm(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base dest;
+    Matrix2x2::ATimesHermB(dest._values, _values, rhs._values);
+    return dest;
+  }
+
+  /**
+   * Matrix multiplication Hermitian transpose of internal matrix with input
+   * matrix, i.e. A^H * B
+   */
+  MC2x2Base<ValType> HermThenMultiply(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::HermATimesB(dest._values, _values, rhs._values);
+    return dest;
+  }
+
+  /**
+   * Matrix multiplication of Hermitian transposes, i.e. A^H * B^H
+   */
+  MC2x2Base<ValType> HermThenMultiplyHerm(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::HermATimesHermB(dest._values, _values, rhs._values);
+    return dest;
+  }
+
+  /**
+   * Computes the double dot, i.e. A:B (A_ij Bij)
+   * See https://en.wikipedia.org/wiki/Dyadics#Double-dot_product
+   */
+  std::complex<ValType> DoubleDot(const MC2x2Base<ValType>& rhs) const {
+    return _values[0] * rhs[0] + _values[1] * rhs[1] + _values[2] * rhs[2] +
+           _values[3] * rhs[3];
+  }
+
+  /**
+   * Multiply input matrix with factor, then add assign to stored matrix
+   */
+  template <typename FactorType>
+  void AddWithFactorAndAssign(const MC2x2Base<ValType>& rhs,
+                              FactorType factor) {
+    Matrix2x2::MultiplyAdd(_values, rhs._values, factor);
+  }
+
+  /**
+   * Compute (regular) transpose of matrix
+   */
+  MC2x2Base<ValType> Transpose() const {
+    return MC2x2Base(_values[0], _values[2], _values[1], _values[3]);
+  }
+
+  /**
+   * Compute Hermitian transpose of matrix
+   */
+  MC2x2Base<ValType> HermTranspose() const {
+    return MC2x2Base(std::conj(_values[0]), std::conj(_values[2]),
+                     std::conj(_values[1]), std::conj(_values[3]));
+  }
+
+  /**
+   * Compute the elementwise conjugate of the matrix (without transposing!)
+   */
+  MC2x2Base<ValType> Conjugate() const {
+    return MC2x2Base(std::conj(_values[0]), std::conj(_values[1]),
+                     std::conj(_values[2]), std::conj(_values[3]));
+  }
+
+  /**
+   * Invert 2x2 matrix, returns false if matrix is not invertible
+   */
+  bool Invert() { return Matrix2x2::Invert(_values); }
+
+  /**
+   * Matrix multiplication, write result to MC2x2Base object
+   */
+  static void ATimesB(MC2x2Base<ValType>& dest, const MC2x2Base<ValType>& lhs,
+                      const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::ATimesB(dest._values, lhs._values, rhs._values);
+  }
+
+  /**
+   * Matrix multiplication, write result to buffer
+   */
+  static void ATimesB(std::complex<ValType>* dest,
+                      const MC2x2Base<ValType>& lhs,
+                      const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::ATimesB(dest, lhs._values, rhs._values);
+  }
+
+  /**
+   * Matrix multiplication of \p lhs with Hermitian transpose of \p rhs
+   */
+  static void ATimesHermB(MC2x2Base<ValType>& dest,
+                          const MC2x2Base<ValType>& lhs,
+                          const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::ATimesHermB(dest._values, lhs._values, rhs._values);
+  }
+
+  /**
+   * Matrix multiplication of Hermitian transpose of \p lhs with \p rhs
+   */
+  static void HermATimesB(MC2x2Base<ValType>& dest,
+                          const MC2x2Base<ValType>& lhs,
+                          const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::HermATimesB(dest._values, lhs._values, rhs._values);
+  }
+
+  /**
+   * Matrix multiplication of Hermitian transpose of \p lhs with Hermitian
+   * transpose \p rhs
+   */
+  static void HermATimesHermB(MC2x2Base<ValType>& dest,
+                              const MC2x2Base<ValType>& lhs,
+                              const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::HermATimesHermB(dest._values, lhs._values, rhs._values);
+  }
+
+  /**
+   * Convert matrix to pretty string
+   */
+  std::string ToString() const {
+    std::stringstream str;
+    str << _values[0] << ", " << _values[1] << "; " << _values[2] << ", "
+        << _values[3];
+    return str.str();
+  }
+
+  /**
+   * Copy values to buffer
+   */
+  void CopyValues(std::complex<ValType>* values) const {
+    Matrix2x2::Assign(values, _values);
+  }
+
+  /**
+   * Calculate eigen values
+   */
+  void EigenValues(std::complex<ValType>& e1, std::complex<ValType>& e2) const {
+    Matrix2x2::EigenValues(_values, e1, e2);
+  }
+
+  /**
+   * Check if matrix entries are finite
+   */
+  bool IsFinite() const {
+    return std::isfinite(_values[0].real()) &&
+           std::isfinite(_values[0].imag()) &&
+           std::isfinite(_values[1].real()) &&
+           std::isfinite(_values[1].imag()) &&
+           std::isfinite(_values[2].real()) &&
+           std::isfinite(_values[2].imag()) &&
+           std::isfinite(_values[3].real()) && std::isfinite(_values[3].imag());
+  }
+  /**
+   * Calculates L, the lower triangle of the Cholesky decomposition, such that
+   * L L^H = M.
+   */
+  bool Cholesky() { return Matrix2x2::Cholesky(_values); }
+
+  /**
+   * See Matrix2x2::CheckedCholesky
+   */
+  bool CheckedCholesky() { return Matrix2x2::CheckedCholesky(_values); }
+
+  /**
+   * See Matrix2x2::UncheckedCholesky
+   */
+  void UncheckedCholesky() { Matrix2x2::UncheckedCholesky(_values); }
+
+  /**
+   * Decompose a Hermitian matrix X into A A^H such that
+   *   X = A A^H = U D D^H U^H
+   *   with A = U D
+   * where D D^H = E is a diagonal matrix
+   *       with the eigen values of X, and U contains the eigen vectors.
+   */
+  MC2x2Base<ValType> DecomposeHermitianEigenvalue() {
+    std::complex<ValType> e1, e2, vec1[2], vec2[2];
+    Matrix2x2::EigenValuesAndVectors(_values, e1, e2, vec1, vec2);
+    ValType v1norm = std::norm(vec1[0]) + std::norm(vec1[1]);
+    vec1[0] /= std::sqrt(v1norm);
+    vec1[1] /= std::sqrt(v1norm);
+    ValType v2norm = std::norm(vec2[0]) + std::norm(vec2[1]);
+    vec2[0] /= std::sqrt(v2norm);
+    vec2[1] /= std::sqrt(v2norm);
+
+    return MC2x2Base<ValType>(
+        vec1[0] * std::sqrt(e1.real()), vec2[0] * std::sqrt(e2.real()),
+        vec1[1] * std::sqrt(e1.real()), vec2[1] * std::sqrt(e2.real()));
+  }
+
+ private:
+  std::complex<ValType> _values[4];
+};
+
+/**
+ * Calculate the Hermite transpose of a 2x2 matrix.
+ */
+template <typename ValType>
+MC2x2Base<ValType> HermTranspose(const MC2x2Base<ValType>& matrix) {
+  return MC2x2Base<ValType>(std::conj(matrix[0]), std::conj(matrix[2]),
+                            std::conj(matrix[1]), std::conj(matrix[3]));
+}
+
+/**
+ * Calculate the sum of the diagonal elements.
+ */
+template <typename ValType>
+std::complex<ValType> Trace(const MC2x2Base<ValType>& matrix) {
+  return matrix[0] + matrix[3];
+}
+
+/**
+ * Calculate the Frobenius norm of a matrix. This
+ * is the sum of squares over all the real and imaginary values
+ * in the matrix.
+ */
+template <typename ValType>
+ValType Norm(const MC2x2Base<ValType>& matrix) {
+  return std::norm(matrix[0]) + std::norm(matrix[1]) + std::norm(matrix[2]) +
+         std::norm(matrix[3]);
+}
+
+using MC2x2 = MC2x2Base<double>;
+using MC2x2F = MC2x2Base<float>;
+
+}  // namespace aocommon
+
+#include "matrix2x2diag.h"
+
+template <typename ValType>
+aocommon::MC2x2Base<ValType>::MC2x2Base(
+    const aocommon::MC2x2DiagBase<ValType>& diag)
+    : _values{diag[0], 0.0, 0.0, diag[1]} {}
+
+#endif
diff --git a/external/aocommon/include/aocommon/matrix2x2diag.h b/external/aocommon/include/aocommon/matrix2x2diag.h
new file mode 100644
index 0000000..08bd9cd
--- /dev/null
+++ b/external/aocommon/include/aocommon/matrix2x2diag.h
@@ -0,0 +1,228 @@
+#ifndef AOCOMMON_MATRIX_2X2_DIAG_H_
+#define AOCOMMON_MATRIX_2X2_DIAG_H_
+
+#include <cmath>
+#include <complex>
+#include <limits>
+#include <sstream>
+
+#include "matrix2x2.h"
+
+namespace aocommon {
+/**
+ * Class implements a 2x2 complex-valued diagonal matrix.
+ */
+template <typename ValType>
+class MC2x2DiagBase {
+ public:
+  MC2x2DiagBase() {}
+  MC2x2DiagBase(const MC2x2DiagBase<ValType>& source) {
+    _values[0] = source._values[0];
+    _values[1] = source._values[1];
+  }
+
+  /**
+   * Construct MC2x2Base object from (length 2) data buffer
+   */
+  template <typename T>
+  explicit MC2x2DiagBase(const T* source) {
+    _values[0] = source[0];
+    _values[1] = source[1];
+  }
+
+  /**
+   * Construct object from diagonal input values. Values are
+   * converted to complex type.
+   */
+  MC2x2DiagBase(ValType m00, ValType m11) {
+    _values[0] = m00;
+    _values[1] = m11;
+  }
+
+  /**
+   * Construct MC2x2Base object from two complex-valued input values.
+   */
+  MC2x2DiagBase(std::complex<ValType> m00, std::complex<ValType> m11) {
+    _values[0] = m00;
+    _values[1] = m11;
+  }
+
+  MC2x2DiagBase<ValType>& operator=(const MC2x2DiagBase<ValType>& source) {
+    _values[0] = source._values[0];
+    _values[1] = source._values[1];
+    return *this;
+  }
+
+  MC2x2DiagBase<ValType> operator*(const MC2x2DiagBase<ValType>& source) const {
+    return Multiply(source);
+  }
+
+  MC2x2DiagBase<ValType>& operator*=(const MC2x2DiagBase<ValType>& source) {
+    (*this) = (*this) * source;
+    return *this;
+  }
+
+  /**
+   * Scalar multiplication operator, real valued rhs
+   */
+  MC2x2DiagBase<ValType> operator*(ValType rhs) const {
+    MC2x2DiagBase<ValType> dest(*this);
+    MC2x2DiagBase::ScalarMultiply(dest._values, rhs);
+    return dest;
+  }
+
+  /**
+   * Scalar multiplication assignment operator, real valued rhs
+   */
+  MC2x2DiagBase<ValType>& operator*=(ValType rhs) {
+    MC2x2DiagBase::ScalarMultiply(_values, rhs);
+    return *this;
+  }
+
+  /**
+   * Scalar multiplication operator, complex valued rhs
+   */
+  MC2x2DiagBase<ValType> operator*(std::complex<ValType> rhs) const {
+    MC2x2DiagBase<ValType> dest(*this);
+    MC2x2DiagBase::ScalarMultiply(dest._values, rhs);
+    return dest;
+  }
+
+  /**
+   * Scalar multiplication assignment operator, complex valued rhs
+   */
+  MC2x2DiagBase<ValType>& operator*=(std::complex<ValType> rhs) {
+    MC2x2DiagBase::ScalarMultiply(_values, rhs);
+    return *this;
+  }
+
+  /**
+   * Scalar division operator
+   */
+  MC2x2DiagBase<ValType> operator/(ValType rhs) const {
+    MC2x2DiagBase<ValType> dest(*this);
+    MC2x2DiagBase::ScalarMultiply(dest._values, 1.0 / rhs);
+    return dest;
+  }
+
+  /**
+   * Scalar division assignment operator
+   */
+  MC2x2DiagBase<ValType>& operator/=(ValType rhs) {
+    MC2x2DiagBase::ScalarMultiply(_values, 1.0 / rhs);
+    return *this;
+  }
+
+  MC2x2DiagBase<ValType> operator+(const MC2x2DiagBase<ValType>& source) {
+    return MC2x2DiagBase<ValType>(_values[0] + source._values[0],
+                                  _values[1] + source._values[1]);
+  }
+
+  MC2x2DiagBase<ValType>& operator+=(const MC2x2DiagBase<ValType>& source) {
+    _values[0] += source._values[0];
+    _values[1] += source._values[1];
+    return *this;
+  }
+
+  const std::complex<ValType>& operator[](size_t index) const {
+    return _values[index];
+  }
+  std::complex<ValType>& operator[](size_t index) { return _values[index]; }
+
+  /**
+   * Return MC2x2Base matrix filled with zeros
+   */
+  static MC2x2DiagBase<ValType> Zero() {
+    return MC2x2DiagBase<ValType>(0.0, 0.0);
+  }
+
+  /**
+   * Return 2x2 identity matrix
+   */
+  static MC2x2DiagBase<ValType> Unity() { return MC2x2DiagBase(1.0, 1.0); }
+
+  /**
+   * Return 2x2 matrix filled with NaN values
+   */
+  static MC2x2DiagBase<ValType> NaN() {
+    return MC2x2DiagBase<ValType>(
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()),
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()));
+  }
+
+  /**
+   * Get pointer to underlying data
+   */
+  std::complex<ValType>* Data() { return _values; }
+  const std::complex<ValType>* Data() const { return _values; }
+
+  /**
+   * Matrix multiplication, alias for the overloaded * operator
+   */
+  MC2x2DiagBase<ValType> Multiply(const MC2x2DiagBase<ValType>& rhs) const {
+    return MC2x2DiagBase<ValType>(_values[0] * rhs[0], _values[1] * rhs[1]);
+  }
+
+  /**
+   * Scalar multiplication of diagonal matrix.
+   */
+  template <typename T>
+  static void ScalarMultiply(std::complex<T>* dest, T factor) {
+    for (size_t p = 0; p != 2; ++p) dest[p] *= factor;
+  }
+
+  /**
+   * Scalar multiplication of matrix.
+   */
+  template <typename T>
+  static void ScalarMultiply(T* dest, T factor) {
+    for (size_t p = 0; p != 2; ++p) dest[p] *= factor;
+  }
+
+  /**
+   * Compute Hermitian transpose of matrix
+   */
+  MC2x2DiagBase<ValType> HermTranspose() const {
+    return MC2x2DiagBase(std::conj(_values[0]), std::conj(_values[1]));
+  }
+
+ private:
+  std::complex<ValType> _values[2];
+};
+
+/**
+ * Diagonal - non-diagonal Matrix multiplication operator
+ */
+template <typename ValType>
+MC2x2Base<ValType> operator*(const MC2x2DiagBase<ValType>& lhs,
+                             const MC2x2Base<ValType>& rhs) {
+  return MC2x2Base<ValType>(lhs[0] * rhs[0], lhs[0] * rhs[1], lhs[1] * rhs[2],
+                            lhs[1] * rhs[3]);
+}
+
+/**
+ * Non-diagonal - diagonal Matrix multiplication operator
+ */
+template <typename ValType>
+MC2x2Base<ValType> operator*(const MC2x2Base<ValType>& lhs,
+                             const MC2x2DiagBase<ValType>& rhs) {
+  return MC2x2Base<ValType>(lhs[0] * rhs[0], lhs[1] * rhs[1], lhs[2] * rhs[0],
+                            lhs[3] * rhs[1]);
+}
+
+/**
+ * Obtain the diagonal of a 2x2 matrix
+ */
+template <typename ValType>
+MC2x2DiagBase<ValType> Diagonal(const MC2x2Base<ValType>& matrix) {
+  return MC2x2DiagBase<ValType>(matrix[0], matrix[3]);
+}
+
+using MC2x2Diag = MC2x2DiagBase<double>;
+using MC2x2FDiag = MC2x2DiagBase<float>;
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/matrix4x4.h b/external/aocommon/include/aocommon/matrix4x4.h
new file mode 100644
index 0000000..a8032c0
--- /dev/null
+++ b/external/aocommon/include/aocommon/matrix4x4.h
@@ -0,0 +1,179 @@
+#ifndef AOCOMMON_MATRIX_4X4_H_
+#define AOCOMMON_MATRIX_4X4_H_
+
+#include <complex>
+#include <string>
+#include <sstream>
+#include <stdexcept>
+
+#include <aocommon/matrix2x2.h>
+
+namespace aocommon {
+
+class Matrix4x4 {
+ public:
+  Matrix4x4() {}
+
+  Matrix4x4(std::initializer_list<std::complex<double>> list) {
+    if (list.size() != 16)
+      throw std::runtime_error(
+          "Matrix4x4 needs to be initialized with 16 items");
+    size_t index = 0;
+    for (const std::complex<double>& el : list) {
+      _data[index] = el;
+      ++index;
+    }
+  }
+
+  static Matrix4x4 Zero() { return Matrix4x4(); }
+
+  static Matrix4x4 Unit() {
+    Matrix4x4 unit;
+    unit[0] = 1.0;
+    unit[5] = 1.0;
+    unit[10] = 1.0;
+    unit[15] = 1.0;
+    return unit;
+  }
+
+  Matrix4x4 operator+(const Matrix4x4& rhs) const {
+    Matrix4x4 result;
+    for (size_t i = 0; i != 16; ++i) result[i] = this->_data[i] + rhs._data[i];
+    return result;
+  }
+
+  Matrix4x4& operator+=(const Matrix4x4& rhs) {
+    for (size_t i = 0; i != 16; ++i) _data[i] += rhs._data[i];
+    return *this;
+  }
+
+  Matrix4x4 operator*(const std::complex<double>& rhs) const {
+    Matrix4x4 m;
+    for (size_t i = 0; i != 16; ++i) m[i] = _data[i] * rhs;
+    return m;
+  }
+
+  Vector4 operator*(const Vector4& rhs) const {
+    Vector4 v(_data[0] * rhs[0], _data[4] * rhs[0], _data[8] * rhs[0],
+              _data[12] * rhs[0]);
+    for (size_t i = 1; i != 4; ++i) {
+      v[0] += _data[i] * rhs[i];
+      v[1] += _data[i + 4] * rhs[i];
+      v[2] += _data[i + 8] * rhs[i];
+      v[3] += _data[i + 12] * rhs[i];
+    }
+    return v;
+  }
+
+  bool Invert() {
+    std::complex<double> inv[16];
+    const std::complex<double>* m = _data;
+
+    inv[0] = m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] +
+             m[9] * m[7] * m[14] + m[13] * m[6] * m[11] - m[13] * m[7] * m[10];
+
+    inv[4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] +
+             m[8] * m[6] * m[15] - m[8] * m[7] * m[14] - m[12] * m[6] * m[11] +
+             m[12] * m[7] * m[10];
+
+    inv[8] = m[4] * m[9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] +
+             m[8] * m[7] * m[13] + m[12] * m[5] * m[11] - m[12] * m[7] * m[9];
+
+    inv[12] = -m[4] * m[9] * m[14] + m[4] * m[10] * m[13] +
+              m[8] * m[5] * m[14] - m[8] * m[6] * m[13] - m[12] * m[5] * m[10] +
+              m[12] * m[6] * m[9];
+
+    inv[1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] +
+             m[9] * m[2] * m[15] - m[9] * m[3] * m[14] - m[13] * m[2] * m[11] +
+             m[13] * m[3] * m[10];
+
+    inv[5] = m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] +
+             m[8] * m[3] * m[14] + m[12] * m[2] * m[11] - m[12] * m[3] * m[10];
+
+    inv[9] = -m[0] * m[9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] -
+             m[8] * m[3] * m[13] - m[12] * m[1] * m[11] + m[12] * m[3] * m[9];
+
+    inv[13] = m[0] * m[9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] +
+              m[8] * m[2] * m[13] + m[12] * m[1] * m[10] - m[12] * m[2] * m[9];
+
+    inv[2] = m[1] * m[6] * m[15] - m[1] * m[7] * m[14] - m[5] * m[2] * m[15] +
+             m[5] * m[3] * m[14] + m[13] * m[2] * m[7] - m[13] * m[3] * m[6];
+
+    inv[6] = -m[0] * m[6] * m[15] + m[0] * m[7] * m[14] + m[4] * m[2] * m[15] -
+             m[4] * m[3] * m[14] - m[12] * m[2] * m[7] + m[12] * m[3] * m[6];
+
+    inv[10] = m[0] * m[5] * m[15] - m[0] * m[7] * m[13] - m[4] * m[1] * m[15] +
+              m[4] * m[3] * m[13] + m[12] * m[1] * m[7] - m[12] * m[3] * m[5];
+
+    inv[14] = -m[0] * m[5] * m[14] + m[0] * m[6] * m[13] + m[4] * m[1] * m[14] -
+              m[4] * m[2] * m[13] - m[12] * m[1] * m[6] + m[12] * m[2] * m[5];
+
+    inv[3] = -m[1] * m[6] * m[11] + m[1] * m[7] * m[10] + m[5] * m[2] * m[11] -
+             m[5] * m[3] * m[10] - m[9] * m[2] * m[7] + m[9] * m[3] * m[6];
+
+    inv[7] = m[0] * m[6] * m[11] - m[0] * m[7] * m[10] - m[4] * m[2] * m[11] +
+             m[4] * m[3] * m[10] + m[8] * m[2] * m[7] - m[8] * m[3] * m[6];
+
+    inv[11] = -m[0] * m[5] * m[11] + m[0] * m[7] * m[9] + m[4] * m[1] * m[11] -
+              m[4] * m[3] * m[9] - m[8] * m[1] * m[7] + m[8] * m[3] * m[5];
+
+    inv[15] = m[0] * m[5] * m[10] - m[0] * m[6] * m[9] - m[4] * m[1] * m[10] +
+              m[4] * m[2] * m[9] + m[8] * m[1] * m[6] - m[8] * m[2] * m[5];
+
+    std::complex<double> det =
+        m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];
+
+    if (det == 0.0) return false;
+
+    det = 1.0 / det;
+
+    for (size_t i = 0; i < 16; i++) _data[i] = inv[i] * det;
+
+    return true;
+  }
+
+  std::complex<double>& operator[](size_t i) { return _data[i]; }
+
+  const std::complex<double>& operator[](size_t i) const { return _data[i]; }
+
+  double Norm() const {
+    double n = 0.0;
+    for (size_t i = 0; i != 16; ++i) {
+      n += std::norm(_data[i]);
+    }
+    return n;
+  }
+
+  std::string String() const {
+    std::ostringstream str;
+    for (size_t y = 0; y != 4; ++y) {
+      for (size_t x = 0; x != 3; ++x) {
+        str << _data[x + y * 4] << '\t';
+      }
+      str << _data[3 + y * 4] << '\n';
+    }
+    return str.str();
+  }
+
+  static Matrix4x4 KroneckerProduct(const MC2x2& veca, const MC2x2& vecb) {
+    Matrix4x4 result;
+    const size_t posa[4] = {0, 2, 8, 10};
+    for (size_t i = 0; i != 4; ++i) {
+      result[posa[i]] = veca[i] * vecb[0];
+      result[posa[i] + 1] = veca[i] * vecb[1];
+      result[posa[i] + 4] = veca[i] * vecb[2];
+      result[posa[i] + 5] = veca[i] * vecb[3];
+    }
+    return result;
+  }
+
+ private:
+  std::complex<double> _data[16];
+};
+
+// typedef Matrix4x4<std::complex<double>> MC4x4;
+typedef Matrix4x4 MC4x4;
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/multibanddata.h b/external/aocommon/include/aocommon/multibanddata.h
new file mode 100644
index 0000000..dce55b6
--- /dev/null
+++ b/external/aocommon/include/aocommon/multibanddata.h
@@ -0,0 +1,238 @@
+#ifndef AOCOMMON_MULTIBANDDATA_H_
+#define AOCOMMON_MULTIBANDDATA_H_
+
+#include <aocommon/banddata.h>
+
+#include <casacore/ms/MeasurementSets/MeasurementSet.h>
+
+#include <casacore/tables/Tables/ArrayColumn.h>
+#include <casacore/tables/Tables/ScalarColumn.h>
+
+#include <algorithm>
+#include <stdexcept>
+
+namespace aocommon {
+/**
+ * Contains information about a set of bands. This follows the CASA Measurement
+ * Set model; one MultiBandData instance can contain the band information
+ * contained in the CASA Measurement Set.
+ */
+class MultiBandData {
+ public:
+  using iterator = std::vector<BandData>::iterator;
+  using const_iterator = std::vector<BandData>::const_iterator;
+
+  /**
+   * Construct an empty MultiBandData.
+   */
+  MultiBandData() = default;
+
+  /**
+   * Construct a MultiBandData from a Measurement Set.
+   * @param ms A measurement set. MultiBandData reads the spectral window table
+   * and the data description table of this measurement set.
+   */
+  explicit MultiBandData(const casacore::MeasurementSet& ms)
+      : MultiBandData(ms.spectralWindow(), ms.dataDescription()) {}
+
+  /**
+   * Construct a MultiBandData from the Measurement Set tables.
+   * @param spw_table The spectral window table of a measurement set.
+   * @param data_desc_table The data description table of a measurement set.
+   */
+  MultiBandData(const casacore::MSSpectralWindow& spw_table,
+                const casacore::MSDataDescription& data_desc_table)
+      : data_desc_to_band_(data_desc_table.nrow()),
+        band_data_(spw_table.nrow()) {
+    for (size_t spw = 0; spw != band_data_.size(); ++spw) {
+      band_data_[spw] = BandData(spw_table, spw);
+    }
+
+    casacore::ScalarColumn<int> spw_column(
+        data_desc_table,
+        casacore::MSDataDescription::columnName(
+            casacore::MSDataDescriptionEnums::SPECTRAL_WINDOW_ID));
+    for (size_t id = 0; id != data_desc_to_band_.size(); ++id)
+      data_desc_to_band_[id] = spw_column(id);
+  }
+
+  /**
+   * Construct a MultiBandData from another instance but only select a part of
+   * each band data. This function also works when not all bands have the
+   * same number of channels. If end_channel is larger than the number of
+   * channels for one of the bands, the band is selected up to its last channel.
+   * @param source Other instance that will be partially copied.
+   * @param start_channel Start of channel range to initialize this instance
+   * with.
+   * @param end_channel End of channel range (exclusive) to initialize this
+   * instance with.
+   */
+  MultiBandData(const MultiBandData& source, size_t start_channel,
+                size_t end_channel)
+      : data_desc_to_band_(source.data_desc_to_band_),
+        band_data_(source.BandCount()) {
+    for (size_t spw = 0; spw != source.BandCount(); ++spw) {
+      // In case end_channel is beyond the nr of channels in this band,
+      // set end_channel to the last channel of this band.
+      const size_t band_end_channel =
+          std::min(source.band_data_[spw].ChannelCount(), end_channel);
+      if (start_channel > band_end_channel)
+        throw std::runtime_error(
+            "Invalid band selection: MultiBandData constructed with "
+            "start_channel=" +
+            std::to_string(start_channel) + ", nr of channels is " +
+            std::to_string(band_end_channel) + ", source bandwidth = " +
+            std::to_string(source.LowestFrequency() / 1e6) + " - " +
+            std::to_string(source.HighestFrequency() / 1e6) + " MHz.");
+      band_data_[spw] =
+          BandData(source.band_data_[spw], start_channel, band_end_channel);
+    }
+  }
+
+  /**
+   * Index operator to retrieve a band data given a data_desc_id.
+   * @param data_desc_id A valid data description ID for which the band is
+   * returned.
+   * @returns The BandData for the requested band.
+   */
+  const BandData& operator[](size_t data_desc_id) const {
+    return band_data_[data_desc_to_band_[data_desc_id]];
+  }
+
+  /**
+   * Get number of bands stored.
+   * @returns Number of bands.
+   */
+  size_t BandCount() const { return band_data_.size(); }
+
+  /**
+   * Returns the unique number of data description IDs.
+   * @returns Unique number of data desc IDs.
+   */
+  size_t DataDescCount() const { return data_desc_to_band_.size(); }
+
+  /**
+   * Get lowest frequency.
+   * @returns The channel frequency of the channel with lowest frequency.
+   */
+  double LowestFrequency() const {
+    if (band_data_.empty()) return 0.0;
+    double freq = band_data_[0].LowestFrequency();
+    for (size_t i = 0; i != band_data_.size(); ++i)
+      freq = std::min(freq, band_data_[i].LowestFrequency());
+    return freq;
+  }
+
+  /**
+   * Get centre frequency.
+   * @returns (BandStart() + BandEnd()) * 0.5.
+   */
+  double CentreFrequency() const { return (BandStart() + BandEnd()) * 0.5; }
+
+  /**
+   * Get highest frequency.
+   * @returns The channel frequency of the channel with highest frequency.
+   */
+  double HighestFrequency() const {
+    if (band_data_.empty()) return 0.0;
+    double freq = band_data_[0].HighestFrequency();
+    for (size_t i = 0; i != band_data_.size(); ++i)
+      freq = std::max(freq, band_data_[i].HighestFrequency());
+    return freq;
+  }
+
+  /**
+   * Get total bandwidth covered.
+   * @returns BandEnd() - BandStart().
+   */
+  double Bandwidth() const { return BandEnd() - BandStart(); }
+
+  /**
+   * Get the start frequency of the lowest frequency channel.
+   * @return Start of covered bandwidth.
+   */
+  double BandStart() const {
+    if (band_data_.empty()) return 0.0;
+    double freq = std::min(band_data_[0].BandStart(), band_data_[0].BandEnd());
+    for (size_t i = 0; i != band_data_.size(); ++i)
+      freq = std::min(
+          freq, std::min(band_data_[i].BandStart(), band_data_[i].BandEnd()));
+    return freq;
+  }
+
+  /**
+   * Get the end frequency of the highest frequency channel.
+   * @return End of covered bandwidth.
+   */
+  double BandEnd() const {
+    if (band_data_.empty()) return 0.0;
+    double freq = std::max(band_data_[0].BandStart(), band_data_[0].BandEnd());
+    for (size_t i = 0; i != band_data_.size(); ++i)
+      freq = std::max(
+          freq, std::max(band_data_[i].BandStart(), band_data_[i].BandEnd()));
+    return freq;
+  }
+
+  /**
+   * Map a data_desc_id to the corresponding band index.
+   * @param data_desc_id A data_desc_id as e.g. used in a main table.
+   * @returns The band index, which is equal to the row index in the spw
+   * table that describes the band in a measurement set.
+   */
+  size_t GetBandIndex(size_t data_desc_id) const {
+    return data_desc_to_band_[data_desc_id];
+  }
+
+  /**
+   * Compose a list of dataDescIds that are used in the measurement set.
+   * "Used" here means it is references from the main table.
+   * @param main_table the measurement set.
+   * @returns Set of used dataDescIds.
+   */
+  std::set<size_t> GetUsedDataDescIds(
+      casacore::MeasurementSet& main_table) const {
+    // If there is only one band, we assume it is used so as to avoid
+    // scanning through the measurement set
+    std::set<size_t> used_data_desc_ids;
+    if (band_data_.size() == 1)
+      used_data_desc_ids.insert(0);
+    else {
+      casacore::ScalarColumn<int> dataDescIdCol(
+          main_table, casacore::MeasurementSet::columnName(
+                          casacore::MSMainEnums::DATA_DESC_ID));
+      for (size_t row = 0; row != main_table.nrow(); ++row) {
+        size_t data_desc_id = dataDescIdCol(row);
+        if (used_data_desc_ids.find(data_desc_id) == used_data_desc_ids.end())
+          used_data_desc_ids.insert(data_desc_id);
+      }
+    }
+    return used_data_desc_ids;
+  }
+
+  /**
+   * Adds a new band at the end of the list of bands.
+   * The band will be linked to the first available data_desc_id, which
+   * is the number returned by @ref DataDescCount().
+   * @returns the data_desc_id of this band.
+   */
+  size_t AddBand(const BandData& data) {
+    const size_t data_desc_id = data_desc_to_band_.size();
+    const size_t band_id = band_data_.size();
+    data_desc_to_band_.emplace_back(band_id);
+    band_data_.emplace_back(data);
+    return data_desc_id;
+  }
+
+  iterator begin() { return band_data_.begin(); }
+  const_iterator begin() const { return band_data_.begin(); }
+
+  iterator end() { return band_data_.end(); }
+  const_iterator end() const { return band_data_.end(); }
+
+ private:
+  std::vector<size_t> data_desc_to_band_;
+  std::vector<BandData> band_data_;
+};
+
+}  // namespace aocommon
+#endif  // AOCOMMON_MULTIBANDDATA_H_
diff --git a/external/aocommon/include/aocommon/parallelfor.h b/external/aocommon/include/aocommon/parallelfor.h
new file mode 100644
index 0000000..edca87a
--- /dev/null
+++ b/external/aocommon/include/aocommon/parallelfor.h
@@ -0,0 +1,193 @@
+#ifndef AOCOMMON_PARALLEL_FOR_H_
+#define AOCOMMON_PARALLEL_FOR_H_
+
+#include "barrier.h"
+
+#include <atomic>
+#include <condition_variable>
+#include <cstring>
+#include <mutex>
+#include <thread>
+#include <vector>
+
+namespace aocommon {
+
+/**
+ * Run a loop in parallel. In this class, loops are "load balanced", i.e.,
+ * if the iteration of one thread takes more time, other threads will perform
+ * more iterations (this is sometimes called "dynamic" timing).
+ *
+ * The downside of load balancing is that every iteration involves a virtual
+ * call, which may be relatively expensive when iterations themselves involve
+ * very little work. In those cases, either use the @ref StaticFor class
+ * or increase the load per iteration (thereby decreasing the nr of iterations).
+ *
+ * Once started, the threads are reused in second calls of Run(), and are kept
+ * alive until the ParallelFor is destructed.
+ */
+template <typename IterType>
+class ParallelFor {
+ public:
+  ParallelFor(size_t n_threads)
+      : n_threads_(n_threads),
+        barrier_(n_threads, [&]() { has_tasks_ = false; }),
+        stop_(false),
+        has_tasks_(false) {}
+
+  ~ParallelFor() {
+    std::unique_lock<std::mutex> lock(mutex_);
+    if (!threads_.empty()) {
+      stop_ = true;
+      has_tasks_ = true;
+      condition_changed_.notify_all();
+      lock.unlock();
+      for (std::thread& thr : threads_) thr.join();
+    }
+  }
+
+  /**
+   * Iteratively call a function in parallel (with thread id).
+   *
+   * The provided function is expected to accept two parameters, the loop
+   * index and the thread id, e.g.:
+   *   void loopFunction(size_t iteration, size_t threadID);
+   * It is called (end-start) times.
+   *
+   * This function is very similar to ThreadPool::For(), but does not
+   * support recursion. For non-recursive loop, this function will be
+   * faster. The function will block until all iterations have been
+   * performed.
+   */
+  void Run(IterType start, IterType end,
+           std::function<void(IterType, size_t)> function) {
+    if (end == start + 1 || n_threads_ == 1) {
+      for (IterType iter = start; iter != end; ++iter) function(iter, 0);
+    } else {
+      std::unique_lock<std::mutex> lock(mutex_);
+      current_ = start;
+      end_ = end;
+      loop_function_1_parameter_ = {};
+      loop_function_2_parameters_ = std::move(function);
+      has_tasks_ = true;
+      if (threads_.empty()) StartThreads();
+      condition_changed_.notify_all();
+      lock.unlock();
+      Loop(0);
+      barrier_.wait();
+    }
+  }
+
+  /**
+   * Iteratively call a function in parallel (without thread id).
+   *
+   * The provided function is expected to take only the loop index
+   * as parameter. If the thread ID is required, use the other overload.
+   * This function behaves otherwise equal to the other overload.
+   * @see Run(IterType, IterType, std::function<void(IterType, size_t)>)
+   */
+  void Run(IterType start, IterType end,
+           std::function<void(IterType)> function) {
+    if (end == start + 1 || n_threads_ == 1) {
+      for (IterType iter = start; iter != end; ++iter) function(iter);
+    } else {
+      std::unique_lock<std::mutex> lock(mutex_);
+      has_tasks_ = true;
+      current_ = start;
+      end_ = end;
+      loop_function_1_parameter_ = std::move(function);
+      loop_function_2_parameters_ = {};
+      if (threads_.empty()) StartThreads();
+      condition_changed_.notify_all();
+      lock.unlock();
+      Loop(0);
+      barrier_.wait();
+    }
+  }
+
+  size_t NThreads() const { return n_threads_; }
+
+  /**
+   * This method is only allowed to be called before Run() is
+   * called.
+   */
+  void SetNThreads(size_t n_threads) {
+    if (threads_.empty()) {
+      n_threads_ = n_threads;
+      barrier_ = Barrier(n_threads, [&]() { has_tasks_ = false; });
+    } else {
+      throw std::runtime_error("Can not set NThreads after calling Run()");
+    }
+  }
+
+ private:
+  ParallelFor(const ParallelFor&) = delete;
+
+  /**
+   * Keep doing iterations until there are no more iterations necessary.
+   */
+  void Loop(size_t thread) {
+    IterType iter;
+    while (Next(iter)) {
+      if (loop_function_2_parameters_) {
+        loop_function_2_parameters_(iter, thread);
+      } else {
+        loop_function_1_parameter_(iter);
+      }
+    }
+  }
+
+  /**
+   * Keep running loops until the class is destructed.
+   */
+  void RunLoops(size_t thread) {
+    while (!stop_) {
+      Loop(thread);
+      barrier_.wait();
+      WaitForTasks();
+    }
+  }
+
+  /**
+   * Obtain the next iteration number. Method is safe to call from multiple
+   * threads.
+   * @returns false if there are no more iterations necessary.
+   */
+  bool Next(IterType& iter) {
+    std::lock_guard<std::mutex> lock(mutex_);
+    if (current_ == end_) {
+      return false;
+    } else {
+      iter = current_;
+      ++current_;
+      return true;
+    }
+  }
+
+  void WaitForTasks() {
+    std::unique_lock<std::mutex> lock(mutex_);
+    while (!has_tasks_) condition_changed_.wait(lock);
+  }
+
+  void StartThreads() {
+    if (n_threads_ > 1) {
+      threads_.reserve(n_threads_ - 1);
+      for (size_t t = 1; t != n_threads_; ++t)
+        threads_.emplace_back(&ParallelFor::RunLoops, this, t);
+    }
+  }
+
+  IterType current_;
+  IterType end_;
+  std::mutex mutex_;
+  size_t n_threads_;
+  Barrier barrier_;
+  std::atomic<bool> stop_;
+  bool has_tasks_;
+  std::condition_variable condition_changed_;
+  std::vector<std::thread> threads_;
+  std::function<void(size_t, size_t)> loop_function_2_parameters_;
+  std::function<void(size_t)> loop_function_1_parameter_;
+};
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/polarization.h b/external/aocommon/include/aocommon/polarization.h
new file mode 100644
index 0000000..451935c
--- /dev/null
+++ b/external/aocommon/include/aocommon/polarization.h
@@ -0,0 +1,554 @@
+#ifndef AOCOMMON_POLARIZATION_H_
+#define AOCOMMON_POLARIZATION_H_
+
+#include <complex>
+#include <set>
+#include <stdexcept>
+#include <vector>
+
+namespace aocommon {
+
+/**
+ * Class for various simple polarization related values.
+ *
+ * The visibility relations for converting polarizations are:
+ *
+ *   RR = I + V  ;   I = (RR + LL)/2
+ *   RL = Q + iU ;   Q = (RL + LR)/2
+ *   LR = Q - iU ;   U = -i (RL - LR)/2
+ *   LL = I - V  ;   V = (RR - LL)/2
+ *
+ *   XX = I + Q  ;   I = (XX + YY)/2
+ *   XY = U + iV ;   Q = (XX - YY)/2
+ *   YX = U - iV ;   U = (XY + YX)/2
+ *   YY = I - Q  ;   V = -i(XY - YX)/2
+ *
+ * These definitions assume that 'X' and 'Y' are labelled as they are in
+ * CASA measurement sets: X is North-South.
+ *
+ * Note that uv-fits files have the polarizations labelled such that X
+ * is East-West, confusingly. We have also observed that at present (2016)
+ * CASA's importuvfits does not swap the polarizations, hence Measurement
+ * Sets exist that have the polarizations labelled wrong.
+ * The IEEE definition is to have X be N-S.
+ * See also: http://adsabs.harvard.edu/abs/1996A%26AS..117..161H
+ */
+class Polarization {
+ public:
+  enum PolarizationEnum {
+    StokesI,
+    StokesQ,
+    StokesU,
+    StokesV,
+    RR,
+    RL,
+    LR,
+    LL,
+    XX,
+    XY,
+    YX,
+    YY,
+    /**
+     * FullStokes is a special value representing that all four Stokes
+     * polarizations (I, Q, U, V) are stored.
+     */
+    FullStokes,
+    /**
+     * Instrumental is a special value representing that four polarizations are
+     * stored, and these are the 'raw' measurement set polarizations, e.g. XX,
+     * XY, YX, YY. It is used as a special value that e.g. can be passed to a
+     * WSClean's MSProvider, which would mean all values are gridded at once, as
+     * required for an a-term correcting gridder.
+     */
+    Instrumental,
+    /**
+     * DiagonalInstrumental is similar to @ref Instrumental, but refers to
+     * situations where only the diagonal instrumental values are of concern.
+     * It can for example refer to XX and YY; or LL and RR. For WSClean, this
+     * value is used when imaging Stokes I with diagonal a-term corrections,
+     * such that only the XX and YY visibilities are required.
+     */
+    DiagonalInstrumental
+  };
+
+  static size_t TypeToIndex(enum PolarizationEnum polarization,
+                            size_t polCountInSet) {
+    switch (polCountInSet) {
+      case 1:
+        if (polarization != StokesI)
+          throw std::runtime_error(
+              "TypeTo4PolIndex(): can't convert given polarization to index");
+        else
+          return 0;
+      case 2:
+        switch (polarization) {
+          case XX:
+            return 0;
+          case YY:
+            return 1;
+          default:
+            throw std::runtime_error(
+                "TypeTo4PolIndex(): can't convert given polarization to index");
+        }
+      case 4:
+        switch (polarization) {
+          case XX:
+            return 0;
+          case XY:
+            return 1;
+          case YX:
+            return 2;
+          case YY:
+            return 3;
+          default:
+            throw std::runtime_error(
+                "TypeTo4PolIndex(): can't convert given polarization to index");
+        }
+      default:
+        throw std::runtime_error(
+            "TypeTo4PolIndex(): can't convert given polarization to index");
+    }
+  }
+
+  static enum PolarizationEnum AipsIndexToEnum(int index) {
+    switch (index) {
+      case 1:
+        return StokesI;
+      case 2:
+        return StokesQ;
+      case 3:
+        return StokesU;
+      case 4:
+        return StokesV;
+      case 5:
+        return RR;
+      case 6:
+        return RL;
+      case 7:
+        return LR;
+      case 8:
+        return LL;
+      case 9:
+        return XX;
+      case 10:
+        return XY;
+      case 11:
+        return YX;
+      case 12:
+        return YY;
+      default:
+        throw std::runtime_error(
+            "AipsIndexToEnum(): unknown aips polarization index");
+    }
+  }
+
+  static int EnumToAipsIndex(enum PolarizationEnum pol) {
+    switch (pol) {
+      case StokesI:
+        return 1;
+      case StokesQ:
+        return 2;
+      case StokesU:
+        return 3;
+      case StokesV:
+        return 4;
+      case RR:
+        return 5;
+      case RL:
+        return 6;
+      case LR:
+        return 7;
+      case LL:
+        return 8;
+      case XX:
+        return 9;
+      case XY:
+        return 10;
+      case YX:
+        return 11;
+      case YY:
+        return 12;
+      default:
+        throw std::runtime_error("EnumToAipsIndex(): unknown polarization");
+    }
+  }
+
+  static bool TypeToIndex(enum PolarizationEnum polarization,
+                          const std::vector<PolarizationEnum>& polList,
+                          size_t& index) {
+    for (size_t i = 0; i != polList.size(); ++i) {
+      if (polList[i] == polarization) {
+        index = i;
+        return true;
+      }
+    }
+    return false;
+  }
+
+  template <typename Range>
+  static bool TypeToIndex(enum PolarizationEnum polarization,
+                          const Range& polList, size_t& index) {
+    size_t curIndex = 0;
+    for (typename Range::const_iterator i = polList.begin(); i != polList.end();
+         ++i, ++curIndex) {
+      if (*i == polarization) {
+        index = curIndex;
+        return true;
+      }
+    }
+    return false;
+  }
+
+  static size_t StokesToIndex(enum PolarizationEnum polarization) {
+    switch (polarization) {
+      default:
+      case StokesI:
+        return 0;
+      case StokesQ:
+        return 1;
+      case StokesU:
+        return 2;
+      case StokesV:
+        return 3;
+    }
+  }
+
+  static PolarizationEnum IndexToStokes(size_t index) {
+    const static PolarizationEnum arr[4] = {StokesI, StokesQ, StokesU, StokesV};
+    return arr[index];
+  }
+
+  static bool IsStokes(enum PolarizationEnum polarization) {
+    return polarization == StokesI || polarization == StokesQ ||
+           polarization == StokesU || polarization == StokesV;
+  }
+
+  static size_t TypeTo4PolIndex(enum PolarizationEnum polarization) {
+    switch (polarization) {
+      case XX:
+        return 0;
+      case XY:
+        return 1;
+      case YX:
+        return 2;
+      case YY:
+        return 3;
+      default:
+        throw std::runtime_error(
+            "TypeTo4PolIndex(): can't convert given polarization to index");
+    }
+  }
+
+  static std::string TypeToShortString(enum PolarizationEnum polarization) {
+    switch (polarization) {
+      case XX:
+        return "XX";
+      case XY:
+        return "XY";
+      case YX:
+        return "YX";
+      case YY:
+        return "YY";
+      case StokesI:
+        return "I";
+      case StokesQ:
+        return "Q";
+      case StokesU:
+        return "U";
+      case StokesV:
+        return "V";
+      case RR:
+        return "RR";
+      case RL:
+        return "RL";
+      case LR:
+        return "LR";
+      case LL:
+        return "LL";
+      case FullStokes:
+        return "stokes";
+      case Instrumental:
+        return "instr";
+      case DiagonalInstrumental:
+        return "diag_instr";
+    }
+    return "";
+  }
+
+  static std::string TypeToFullString(enum PolarizationEnum polarization) {
+    switch (polarization) {
+      case XX:
+        return "XX";
+      case XY:
+        return "XY";
+      case YX:
+        return "YX";
+      case YY:
+        return "YY";
+      case StokesI:
+        return "Stokes I";
+      case StokesQ:
+        return "Stokes Q";
+      case StokesU:
+        return "Stokes U";
+      case StokesV:
+        return "Stokes V";
+      case RR:
+        return "RR";
+      case RL:
+        return "RL";
+      case LR:
+        return "LR";
+      case LL:
+        return "LL";
+      case FullStokes:
+        return "Full Stokes";
+      case Instrumental:
+        return "instrumental";
+      case DiagonalInstrumental:
+        return "diagonal instrumental";
+    }
+    return "Unknown polarization";
+  }
+
+  static bool HasFullPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return HasFullLinearPolarization(polarizations) ||
+           HasFullStokesPolarization(polarizations) ||
+           (polarizations.count(RR) > 0 && polarizations.count(RL) > 0 &&
+            polarizations.count(LR) > 0 && polarizations.count(LL) > 0);
+  }
+
+  static bool HasFullLinearPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return (polarizations.count(XX) > 0 && polarizations.count(XY) > 0 &&
+            polarizations.count(YX) > 0 && polarizations.count(YY) > 0);
+  }
+
+  static bool HasFullCircularPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return (polarizations.count(LL) > 0 && polarizations.count(LR) > 0 &&
+            polarizations.count(RL) > 0 && polarizations.count(RR) > 0);
+  }
+
+  static bool HasFullStokesPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return (
+        polarizations.count(StokesI) > 0 && polarizations.count(StokesQ) > 0 &&
+        polarizations.count(StokesU) > 0 && polarizations.count(StokesV) > 0);
+  }
+
+  static bool HasDualPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return HasDualLinearPolarization(polarizations) ||
+           (polarizations.count(RR) > 0 && polarizations.count(LL) > 0);
+  }
+
+  static bool HasDualLinearPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return (polarizations.count(XX) > 0 && polarizations.count(YY) > 0);
+  }
+
+  static bool IsComplex(PolarizationEnum polarization) {
+    return polarization == XY || polarization == YX;
+  }
+
+  static PolarizationEnum ParseString(const std::string& str) {
+    if (str == "XX")
+      return XX;
+    else if (str == "XY")
+      return XY;
+    else if (str == "YX")
+      return YX;
+    else if (str == "YY")
+      return YY;
+    else if (str == "I")
+      return StokesI;
+    else if (str == "Q")
+      return StokesQ;
+    else if (str == "U")
+      return StokesU;
+    else if (str == "V")
+      return StokesV;
+    else if (str == "RR")
+      return RR;
+    else if (str == "RL")
+      return RL;
+    else if (str == "LR")
+      return LR;
+    else if (str == "LL")
+      return LL;
+    else
+      throw std::runtime_error(
+          std::string("Could not parse polarization string: ") + str);
+  }
+
+  static std::set<PolarizationEnum> ParseList(const std::string& listStr) {
+    std::set<PolarizationEnum> list;
+    enum {
+      StartSt,
+      GotXSt,
+      GotYSt,
+      GotLSt,
+      GotRSt,
+      GotSeperatorSt
+    } state = StartSt;
+    for (std::string::const_iterator i = listStr.begin(); i != listStr.end();
+         ++i) {
+      char c = (*i >= 'a' && *i <= 'z') ? *i - ('a' - 'A') : *i;
+      switch (c) {
+        case 'X':
+          if (state == StartSt || state == GotSeperatorSt)
+            state = GotXSt;
+          else {
+            if (state == GotXSt)
+              list.insert(XX);
+            else if (state == GotYSt)
+              list.insert(YX);
+            else
+              throw std::runtime_error(
+                  "Invalid polarization list: parse error near 'X'");
+            state = StartSt;
+          }
+          break;
+        case 'Y':
+          if (state == StartSt || state == GotSeperatorSt)
+            state = GotYSt;
+          else {
+            if (state == GotXSt)
+              list.insert(XY);
+            else if (state == GotYSt)
+              list.insert(YY);
+            else
+              throw std::runtime_error(
+                  "Invalid polarization list: parse error near 'Y'");
+            state = StartSt;
+          }
+          break;
+        case 'R':
+          if (state == StartSt || state == GotSeperatorSt)
+            state = GotRSt;
+          else {
+            if (state == GotRSt)
+              list.insert(RR);
+            else if (state == GotLSt)
+              list.insert(LR);
+            else
+              throw std::runtime_error(
+                  "Invalid polarization list: parse error near 'R'");
+            state = StartSt;
+          }
+          break;
+        case 'L':
+          if (state == StartSt || state == GotSeperatorSt)
+            state = GotLSt;
+          else {
+            if (state == GotRSt)
+              list.insert(RL);
+            else if (state == GotLSt)
+              list.insert(LL);
+            else
+              throw std::runtime_error(
+                  "Invalid polarization list: parse error near 'L'");
+            state = StartSt;
+          }
+          break;
+        case 'I':
+          if (state == StartSt || state == GotSeperatorSt)
+            list.insert(StokesI);
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near 'I'");
+          state = StartSt;
+          break;
+        case 'Q':
+          if (state == StartSt || state == GotSeperatorSt)
+            list.insert(StokesQ);
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near 'Q'");
+          state = StartSt;
+          break;
+        case 'U':
+          if (state == StartSt || state == GotSeperatorSt)
+            list.insert(StokesU);
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near 'U'");
+          state = StartSt;
+          break;
+        case 'V':
+          if (state == StartSt || state == GotSeperatorSt)
+            list.insert(StokesV);
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near 'V'");
+          state = StartSt;
+          break;
+        case ',':
+        case ' ':
+        case '/':
+          if (state == StartSt)
+            state = GotSeperatorSt;
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near seperator");
+      }
+    }
+    if (state != StartSt)
+      throw std::runtime_error(
+          "Invalid polarization list: parse error near string end");
+    return list;
+  }
+
+  template <typename NumType>
+  static void LinearToStokes(const std::complex<NumType>* linear,
+                             NumType* stokes) {
+    // Note comments about X and Y at the top of this file!
+    stokes[0] = 0.5 * (linear[0].real() + linear[3].real());
+    stokes[1] = 0.5 * (linear[0].real() - linear[3].real());
+    stokes[2] = 0.5 * (linear[1].real() + linear[2].real());
+    stokes[3] = 0.5 * (linear[1].imag() - linear[2].imag());
+  }
+
+  template <typename NumType>
+  static void StokesToLinear(const NumType* stokes,
+                             std::complex<NumType>* linear) {
+    linear[0] = stokes[0] + stokes[1];
+    linear[1] = std::complex<NumType>(stokes[2], stokes[3]);
+    linear[2] = std::complex<NumType>(stokes[2], -stokes[3]);
+    linear[3] = stokes[0] - stokes[1];
+  }
+
+  template <typename NumType>
+  static void CircularToStokes(const std::complex<NumType>* circular,
+                               NumType* stokes) {
+    stokes[0] = (circular[0] + circular[3]).real() * 0.5;
+    stokes[1] = (circular[1] + circular[2]).real() * 0.5;
+    stokes[2] = (circular[1] - circular[2]).imag() * 0.5;
+    stokes[3] = (circular[0] - circular[3]).real() * 0.5;
+  }
+
+  /**
+   * Get the number of visibilities that are required to store this
+   * polarization. For the special polarization values @ref Instrument and @ref
+   * DiagonalInstrument, 4 and 2 are returned respectively. For other
+   * polarizations, the value 1 is returned.
+   */
+  static size_t GetVisibilityCount(PolarizationEnum polarization) {
+    switch (polarization) {
+      case aocommon::Polarization::Instrumental:
+        return 4;
+      case aocommon::Polarization::DiagonalInstrumental:
+        return 2;
+      default:
+        return 1;
+    }
+  }
+};
+
+typedef Polarization::PolarizationEnum PolarizationEnum;
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/queue.h b/external/aocommon/include/aocommon/queue.h
new file mode 100644
index 0000000..71e98ff
--- /dev/null
+++ b/external/aocommon/include/aocommon/queue.h
@@ -0,0 +1,110 @@
+#ifndef AOCOMMON_QUEUE_H_
+#define AOCOMMON_QUEUE_H_
+
+#include <boost/circular_buffer.hpp>
+
+namespace aocommon {
+
+/**
+ * Defines a simple FIFO queue. Properties:
+ * - Expands automatically when it is full and a new element is added.
+ * - Has similar complexity and performance as std::vector, since it
+ *   is implemented using a circular queue.
+ * @tparam T type of the elements of the queue.
+ */
+template <typename T>
+class Queue {
+ public:
+  using iterator = typename boost::circular_buffer<T>::iterator;
+  using const_iterator = typename boost::circular_buffer<T>::const_iterator;
+
+  /**
+   * Constructor
+   * Allocates room for a single element so ResizeIfNeeded can always simply
+   * multiply the size by 2.
+   */
+  Queue() : buffer_(1) {}
+
+  /**
+   * Adds a value to the end of the queue.
+   * @param value An lvalue or rvalue reference to a value.
+   * @return A reference to the newly added element.
+   * @{
+   */
+  T& PushBack(T&& value) {
+    ResizeIfNeeded();
+    buffer_.push_back(std::move(value));
+    return buffer_.back();
+  }
+  T& PushBack(const T& value) {
+    ResizeIfNeeded();
+    buffer_.push_back(value);
+    return buffer_.back();
+  }
+  /** @} */
+
+  /**
+   * Removes the least recently added value from the queue.
+   */
+  void PopFront() { buffer_.pop_front(); }
+
+  /**
+   * Removes all elements from the queue.
+   * Does not change the capacity of the queue.
+   */
+  void Clear() { buffer_.clear(); }
+
+  /**
+   * @return An iterator for the first element of the queue. The iterator
+   * remains valid as long as the queue is not modified.
+   * @{
+   */
+  iterator begin() { return buffer_.begin(); }
+  const_iterator begin() const { return buffer_.begin(); }
+  /** @} */
+
+  /**
+   * @return An iterator for the end of the queue. The iterator remains valid as
+   * long as the queue is not modified.
+   * @{
+   */
+  iterator end() { return buffer_.end(); }
+  const_iterator end() const { return buffer_.end(); }
+  /** @} */
+
+  /**
+   * Get an element at an index position.
+   * @param i index. The least recently added value has index 0.
+   * @returns A reference to the element at the given index.
+   * @{
+   */
+  T& operator[](size_t i) { return buffer_[i]; };
+  const T& operator[](size_t i) const { return buffer_[i]; };
+  /** @} */
+
+  /**
+   * @return True if the queue is empty, false if it has one or more elements.
+   */
+  bool Empty() const { return buffer_.empty(); }
+
+  /**
+   * @return The number of elements in the queue.
+   */
+  std::size_t Size() const { return buffer_.size(); }
+
+  /**
+   * @return The current capacity of the queue, in number of elements.
+   */
+  std::size_t Capacity() const { return buffer_.capacity(); }
+
+ private:
+  inline void ResizeIfNeeded() {
+    if (buffer_.full()) buffer_.set_capacity(buffer_.capacity() * 2);
+  }
+
+  boost::circular_buffer<T> buffer_;
+};
+
+}  // namespace aocommon
+
+#endif
\ No newline at end of file
diff --git a/external/aocommon/include/aocommon/radeccoord.h b/external/aocommon/include/aocommon/radeccoord.h
new file mode 100644
index 0000000..40b9780
--- /dev/null
+++ b/external/aocommon/include/aocommon/radeccoord.h
@@ -0,0 +1,271 @@
+#ifndef AOCOMMON_RADECCOORD_H_
+#define AOCOMMON_RADECCOORD_H_
+
+#include <string>
+#include <sstream>
+#include <stdexcept>
+#include <cstdlib>
+#include <cmath>
+
+#ifndef M_PIl
+#define M_PIl 3.141592653589793238462643383279502884L
+#endif
+
+namespace aocommon {
+class RaDecCoord {
+ private:
+  static bool isRASeparator(char c) { return c == ':' || c == ' '; }
+  static bool isDecSeparator(char c) { return c == '.' || c == ' '; }
+
+ public:
+  static long double ParseRA(const std::string& str) {
+    char* cstr;
+    bool sign = false;
+    for (size_t i = 0; i != str.size(); ++i) {
+      if (str[i] == '-') {
+        sign = true;
+        break;
+      } else if (str[i] != ' ') {
+        sign = false;
+        break;
+      }
+    }
+    long double secs = 0.0, mins = 0.0, hrs = strtol(str.c_str(), &cstr, 10);
+    // Parse format '00h00m00.0s'
+    if (*cstr == 'h') {
+      ++cstr;
+      mins = strtol(cstr, &cstr, 10);
+      if (*cstr == 'm') {
+        ++cstr;
+        secs = strtold(cstr, &cstr);
+        if (*cstr == 's')
+          ++cstr;
+        else
+          throw std::runtime_error("Missing 's'");
+      } else
+        throw std::runtime_error("Missing 'm'");
+    }
+    // Parse format '00:00:00.0'
+    else if (isRASeparator(*cstr)) {
+      ++cstr;
+      mins = strtol(cstr, &cstr, 10);
+      if (isRASeparator(*cstr)) {
+        ++cstr;
+        secs = strtold(cstr, &cstr);
+      } else
+        throw std::runtime_error("Missing ':' after minutes");
+    } else
+      throw std::runtime_error("Missing 'h' or ':' in string '" + str + "'");
+    if (*cstr != 0)
+      throw std::runtime_error("Could not parse RA '" + str +
+                               "' (string contains more tokens than expected)");
+    if (sign)
+      return (hrs / 24.0 - mins / (24.0 * 60.0) - secs / (24.0 * 60.0 * 60.0)) *
+             2.0 * M_PIl;
+    else
+      return (hrs / 24.0 + mins / (24.0 * 60.0) + secs / (24.0 * 60.0 * 60.0)) *
+             2.0 * M_PIl;
+  }
+
+  static long double ParseDec(const std::string& str) {
+    char* cstr;
+    bool sign = false;
+    for (size_t i = 0; i != str.size(); ++i) {
+      if (str[i] == '-') {
+        sign = true;
+        break;
+      } else if (str[i] != ' ') {
+        sign = false;
+        break;
+      }
+    }
+    long double secs = 0.0, mins = 0.0, degs = strtol(str.c_str(), &cstr, 10);
+    // Parse format '00d00m00.0s'
+    if (*cstr == 'd') {
+      ++cstr;
+      mins = strtol(cstr, &cstr, 10);
+      if (*cstr == 'm') {
+        ++cstr;
+        secs = strtold(cstr, &cstr);
+        if (*cstr == 's')
+          ++cstr;
+        else
+          throw std::runtime_error("Missing 's'");
+      } else
+        throw std::runtime_error("Missing 'm'");
+    }
+    // Parse format '00.00.00.0'
+    else if (isDecSeparator(*cstr)) {
+      ++cstr;
+      mins = strtol(cstr, &cstr, 10);
+      if (isDecSeparator(*cstr)) {
+        ++cstr;
+        secs = strtold(cstr, &cstr);
+      } else
+        throw std::runtime_error("Missing '.' after minutes");
+    } else
+      throw std::runtime_error("Missing 'd' or '.' after degrees");
+    if (*cstr != 0)
+      throw std::runtime_error(
+          "Could not parse Dec (string contains more tokens than expected)");
+    else if (sign)
+      return (degs / 360.0 - mins / (360.0 * 60.0) -
+              secs / (360.0 * 60.0 * 60.0)) *
+             2.0 * M_PIl;
+    else
+      return (degs / 360.0 + mins / (360.0 * 60.0) +
+              secs / (360.0 * 60.0 * 60.0)) *
+             2.0 * M_PIl;
+  }
+
+  static std::string RAToString(long double ra) {
+    const long double partsPerHour = 60.0L * 60.0L * 1000.0L;
+    long double hrs = fmodl(ra * (12.0L / M_PIl), 24.0L);
+    hrs = roundl(hrs * partsPerHour) / partsPerHour;
+    std::stringstream s;
+    if (hrs < 0.0L) {
+      hrs += 24.0L;
+    }
+    hrs = (roundl(hrs * partsPerHour) + 0.5) / partsPerHour;
+    int hrsInt = int(floorl(hrs)),
+        minInt = int(floorl(fmodl(hrs, 1.0L) * 60.0L)),
+        secInt = int(floorl(fmodl(hrs * 60.0L, 1.0L) * (60.0L))),
+        subSecInt = int(floorl(fmodl(hrs * (60.0L * 60.0L), 1.0L) * (1000.0L)));
+    s << (char)((hrsInt / 10) + '0') << (char)((hrsInt % 10) + '0') << 'h'
+      << (char)((minInt / 10) + '0') << (char)((minInt % 10) + '0') << 'm'
+      << (char)((secInt / 10) + '0') << (char)((secInt % 10) + '0');
+    s << '.' << (char)(subSecInt / 100 + '0');
+    if (subSecInt % 100 != 0) {
+      s << (char)((subSecInt % 100) / 10 + '0');
+      if (subSecInt % 10 != 0) s << (char)((subSecInt % 10) + '0');
+    }
+    s << 's';
+    return s.str();
+  }
+
+  static std::string RAToString(long double ra, char delimiter) {
+    const long double partsPerHour = 60.0L * 60.0L * 1000.0L;
+    long double hrs = fmodl(ra * (12.0L / M_PIl), 24.0L);
+    hrs = roundl(hrs * partsPerHour) / partsPerHour;
+    std::stringstream s;
+    if (hrs < 0) {
+      hrs = -hrs;
+      s << '-';
+    }
+    hrs = (roundl(hrs * partsPerHour) + 0.5) / partsPerHour;
+    int hrsInt = int(floorl(hrs)),
+        minInt = int(floorl(fmodl(hrs, 1.0L) * 60.0L)),
+        secInt = int(floorl(fmodl(hrs * 60.0L, 1.0L) * (60.0L))),
+        subSecInt = int(floorl(fmodl(hrs * (60.0L * 60.0L), 1.0L) * (1000.0L)));
+    s << (char)((hrsInt / 10) + '0') << (char)((hrsInt % 10) + '0') << delimiter
+      << (char)((minInt / 10) + '0') << (char)((minInt % 10) + '0') << delimiter
+      << (char)((secInt / 10) + '0') << (char)((secInt % 10) + '0');
+    s << '.' << (char)(subSecInt / 100 + '0');
+    if (subSecInt % 100 != 0) {
+      s << (char)((subSecInt % 100) / 10 + '0');
+      if (subSecInt % 10 != 0) s << (char)((subSecInt % 10) + '0');
+    }
+    return s.str();
+  }
+
+  static std::string RaDecToString(long double ra, long double dec) {
+    return RAToString(ra) + ' ' + DecToString(dec);
+  }
+
+  static void RAToHMS(long double ra, int& hrs, int& min, double& sec) {
+    const long double partsPerHour = 60.0L * 60.0L * 100.0L;
+    long double hrsf = fmodl(ra * (12.0L / M_PIl), 24.0L);
+    hrsf = roundl(hrsf * partsPerHour) / partsPerHour;
+    bool negate = hrsf < 0;
+    if (negate) {
+      hrsf = -hrsf;
+    }
+    hrsf = (roundl(hrsf * partsPerHour) + 0.5) / partsPerHour;
+    if (negate)
+      hrs = -int(floorl(hrsf));
+    else
+      hrs = int(floorl(hrsf));
+    min = int(floorl(fmodl(hrsf, 1.0L) * 60.0L));
+    sec = floorl(100.0L * fmodl(hrsf * 60.0L, 1.0L) * 60.0L) / 100.0L;
+  }
+
+  static std::string DecToString(long double dec) {
+    const long double partsPerDeg = 60.0L * 60.0L * 1000.0L;
+    long double deg = dec * (180.0L / M_PIl);
+    deg = round(deg * partsPerDeg) / partsPerDeg;
+    std::stringstream s;
+    if (deg < 0) {
+      deg = -deg;
+      s << '-';
+    }
+    deg = (round(deg * partsPerDeg) + 0.5L) / partsPerDeg;
+    int degInt = int(floorl(deg)),
+        minInt = int(floorl(fmodl(deg, 1.0L) * 60.0L)),
+        secInt = int(floorl(fmodl(deg, 1.0L / 60.0L) * (60.0L * 60.0L))),
+        subSecInt = int(floorl(fmodl(deg, 1.0L / 60.0L / 60.0L) *
+                               (60.0L * 60.0L * 1000.0L)));
+    s << (char)((degInt / 10) + '0') << (char)((degInt % 10) + '0') << 'd'
+      << (char)((minInt / 10) + '0') << (char)((minInt % 10) + '0') << 'm'
+      << (char)((secInt / 10) + '0') << (char)((secInt % 10) + '0');
+    if (subSecInt != 0) {
+      s << '.' << (char)(subSecInt / 100 + '0');
+      if (subSecInt % 100 != 0) {
+        s << (char)((subSecInt / 10) % 10 + '0');
+        if (subSecInt % 10 != 0) s << (char)(subSecInt % 10 + '0');
+      }
+    }
+    s << 's';
+    return s.str();
+  }
+
+  static std::string DecToString(long double dec, char delimiter) {
+    const long double partsPerDeg = 60.0L * 60.0L * 1000.0L;
+    long double deg = dec * (180.0L / M_PIl);
+    deg = roundl(deg * partsPerDeg) / partsPerDeg;
+    std::stringstream s;
+    if (deg < 0) {
+      deg = -deg;
+      s << '-';
+    }
+    deg = (roundl(deg * partsPerDeg) + 0.5L) / partsPerDeg;
+    int degInt = int(floorl(deg)),
+        minInt = int(floorl(fmodl(deg, 1.0L) * 60.0L)),
+        secInt = int(floorl(fmodl(deg, 1.0L / 60.0L) * (60.0L * 60.0L))),
+        subSecInt = int(floorl(fmodl(deg, 1.0L / 60.0L / 60.0L) *
+                               (60.0L * 60.0L * 1000.0L)));
+    s << (char)((degInt / 10) + '0') << (char)((degInt % 10) + '0') << delimiter
+      << (char)((minInt / 10) + '0') << (char)((minInt % 10) + '0') << delimiter
+      << (char)((secInt / 10) + '0') << (char)((secInt % 10) + '0');
+    if (subSecInt != 0) {
+      s << '.' << (char)(subSecInt / 100 + '0');
+      if (subSecInt % 100 != 0) {
+        s << (char)((subSecInt / 10) % 10 + '0');
+        if (subSecInt % 10 != 0) s << (char)(subSecInt % 10 + '0');
+      }
+    }
+    return s.str();
+  }
+
+  static void DecToDMS(long double dec, int& deg, int& min, double& sec) {
+    const long double partsPerDeg = 60.0L * 60.0L * 100.0L;
+    long double degf = dec * (180.0 / M_PIl);
+    degf = round(degf * partsPerDeg) / partsPerDeg;
+    bool negate = degf < 0;
+    if (negate) {
+      degf = -degf;
+    }
+    degf = (round(degf * partsPerDeg) + 0.5) / partsPerDeg;
+
+    if (negate)
+      deg = -int(floor(degf));
+    else
+      deg = int(floor(degf));
+    min = int(floor(fmod(degf, 1.0) * 60.0)),
+    sec = floor(100. * fmod(degf, 1.0 / 60.0) * (60.0 * 60.0)) / 100.0;
+  }
+
+ private:
+  RaDecCoord() {}
+};
+}  // namespace aocommon
+#endif
diff --git a/external/aocommon/include/aocommon/staticfor.h b/external/aocommon/include/aocommon/staticfor.h
new file mode 100644
index 0000000..8625991
--- /dev/null
+++ b/external/aocommon/include/aocommon/staticfor.h
@@ -0,0 +1,196 @@
+#ifndef AOCOMMON_STATIC_FOR_H_
+#define AOCOMMON_STATIC_FOR_H_
+
+#include "barrier.h"
+
+#include <atomic>
+#include <condition_variable>
+#include <cstring>
+#include <mutex>
+#include <thread>
+#include <vector>
+
+#include <sched.h>
+
+namespace aocommon {
+
+/**
+ * The StaticFor class implements a parallel for loop that
+ * is statically distributed over all threads. It is suitable
+ * for large loops that approximately take an equal amount of
+ * time per iteration. If one thread finishes its chunk
+ * earlier, it won't be rescheduled to more.
+ *
+ * The advantage of this is that it doesn't require communication
+ * between iterations, and thus the loop is faster, as long as
+ * iterations take similar time.
+ *
+ * An example to count to 1000 with 4 threads:
+ * StaticFor<size_t> loop(4);
+ * loop.Run(0, 1000, [&](size_t a, size_t b) {
+ *   for(size_t i=a; i!=b; ++i) {
+ *     std::cout << i << '\n';
+ *   }
+ * }
+ *
+ * It is also possible to acquire the thread index, by providing
+ * a function with 3 parameters:
+ * StaticFor<size_t> loop(4);
+ * loop.Run(0, 1000, [&](size_t a, size_t b, size_t thread) {
+ *   for(size_t i=a; i!=b; ++i) {
+ *     std::cout << i << " from thread " << thread << '\n';
+ *   }
+ * }
+ */
+template <typename Iter>
+class StaticFor {
+ public:
+  /**
+   * Construct class with given nr of threads.
+   */
+  StaticFor(size_t nThreads)
+      : _nThreads(nThreads),
+        _barrier(nThreads, [&]() { _hasTasks = false; }),
+        _stop(false),
+        _hasTasks(false) {}
+
+  /**
+   * Destructor will wait for all threads to be finished.
+   */
+  ~StaticFor() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    if (!_threads.empty()) {
+      _stop = true;
+      _hasTasks = true;
+      _conditionChanged.notify_all();
+      lock.unlock();
+      for (std::thread& thr : _threads) thr.join();
+    }
+  }
+
+  /**
+   * Iteratively call a function in parallel.
+   *
+   * The provided function is expected to accept two size_t parameters, the
+   * start and end indices of this thread, e.g.: void loopFunction(size_t
+   * chunkStart, size_t chunkEnd);
+   */
+  void Run(Iter start, Iter end, std::function<void(Iter, Iter)> function) {
+    _loopFunction = std::move(function);
+    run(start, end);
+    _loopFunction = nullptr;
+  }
+
+  /**
+   * Iteratively call a function in parallel with thread id.
+   *
+   * The provided function is expected to accept three parameters, the start
+   * and end indices of this thread, e.g.:
+   *   void loopFunction(size_t chunkStart, size_t chunkEnd, size_t threadId);
+   */
+  void Run(Iter start, Iter end,
+           std::function<void(Iter, Iter, size_t)> function) {
+    _loopFunctionEx = std::move(function);
+    run(start, end);
+    _loopFunctionEx = nullptr;
+  }
+
+  /**
+   * Number of threads
+   */
+  size_t NThreads() const { return _nThreads; }
+
+  /**
+   * This method is only allowed to be called before Run() is
+   * called.
+   */
+  void SetNThreads(size_t nThreads) {
+    if (_threads.empty()) {
+      _nThreads = nThreads;
+      _barrier = Barrier(nThreads, [&]() { _hasTasks = false; });
+    } else {
+      throw std::runtime_error("Can not set NThreads after calling Run()");
+    }
+  }
+
+ private:
+  StaticFor(const StaticFor&) = delete;
+
+  void run(Iter start, Iter end) {
+    if (end == start + 1 || _nThreads <= 1) {
+      callFunction(start, end, 0);
+    } else {
+      if (_threads.empty()) startThreads();
+      std::unique_lock<std::mutex> lock(_mutex);
+      _iterStart = start;
+      _iterEnd = end;
+      _currentChunk = 0;
+      _nChunks = std::min(_nThreads, end - start);
+      _hasTasks = true;
+      _conditionChanged.notify_all();
+      lock.unlock();
+
+      // To avoid one extra thread-spawn, this thread also performs
+      // the iterations for one chunk: (with thread id 0)
+      loop(0);
+
+      _barrier.wait();
+    }
+  }
+
+  void callFunction(Iter start, Iter end, size_t threadId) const {
+    if (_loopFunction)
+      _loopFunction(start, end);
+    else
+      _loopFunctionEx(start, end, threadId);
+  }
+
+  void loop(size_t threadId) {
+    if (threadId < _nChunks) {
+      Iter chunkStart =
+          _iterStart + (_iterEnd - _iterStart) * threadId / _nChunks;
+      Iter chunkEnd =
+          _iterStart + (_iterEnd - _iterStart) * (threadId + 1) / _nChunks;
+
+      callFunction(chunkStart, chunkEnd, threadId);
+    }
+  }
+
+  void threadLoop(size_t threadId) {
+    waitForTasks();
+    while (!_stop) {
+      loop(threadId);
+      _barrier.wait();
+      waitForTasks();
+    }
+  }
+
+  void waitForTasks() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (!_hasTasks) _conditionChanged.wait(lock);
+  }
+
+  void startThreads() {
+    if (_nThreads > 1) {
+      _threads.reserve(_nThreads - 1);
+      for (unsigned t = 1; t != _nThreads; ++t)
+        _threads.emplace_back(&StaticFor::threadLoop, this, t);
+    }
+  }
+
+  size_t _currentChunk, _nChunks;
+  Iter _iterStart, _iterEnd;
+  std::mutex _mutex;
+  size_t _nThreads;
+  Barrier _barrier;
+  std::atomic<bool> _stop;
+  bool _hasTasks;
+  std::condition_variable _conditionChanged;
+  std::vector<std::thread> _threads;
+  std::function<void(Iter, Iter)> _loopFunction;
+  std::function<void(Iter, Iter, size_t)> _loopFunctionEx;
+};
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/system.h b/external/aocommon/include/aocommon/system.h
new file mode 100644
index 0000000..a572e17
--- /dev/null
+++ b/external/aocommon/include/aocommon/system.h
@@ -0,0 +1,57 @@
+#ifndef AOCOMMON_SYSTEM_H_
+#define AOCOMMON_SYSTEM_H_
+
+#include <unistd.h>
+#include <sched.h>
+
+#include <cstring>
+#include <stdexcept>
+
+namespace aocommon {
+namespace system {
+
+inline long TotalMemory() {
+  // Solution from
+  // https://stackoverflow.com/questions/2513505/how-to-get-available-memory-c-g
+  return sysconf(_SC_PHYS_PAGES) * sysconf(_SC_PAGE_SIZE);
+}
+
+inline size_t ProcessorCount() {
+#ifdef __APPLE__
+  return sysconf(_SC_NPROCESSORS_ONLN);
+#else
+  cpu_set_t cs;
+  CPU_ZERO(&cs);
+  sched_getaffinity(0, sizeof(cs), &cs);
+  return CPU_COUNT(&cs);
+#endif
+}
+
+namespace detail {
+inline char* HandleStrReturn(int value) {
+  if (value != 0) throw std::runtime_error("strerror_r() reported an error");
+  return nullptr;
+}
+inline char* HandleStrReturn(char* value) { return value; }
+}  // namespace detail
+
+/**
+ * @brief Convert a Posix \c errno error number to a string. This function is
+ * thread safe.
+ */
+inline std::string GetErrorString(int errnum) {
+  // Because strerror_r() has different return values on different platforms,
+  // two overloads of handle_strerror are used to make this compile and work
+  // in either case of int or char*.
+  char buffer[1024];
+  char* ret = detail::HandleStrReturn(strerror_r(errnum, buffer, 1024));
+  if (ret == nullptr) {
+    return std::string(buffer);
+  } else {
+    return std::string(ret);
+  }
+}
+
+}  // namespace system
+}  // namespace aocommon
+#endif
diff --git a/external/aocommon/include/aocommon/threadpool.h b/external/aocommon/include/aocommon/threadpool.h
new file mode 100644
index 0000000..e772c7a
--- /dev/null
+++ b/external/aocommon/include/aocommon/threadpool.h
@@ -0,0 +1,188 @@
+#ifndef AOCOMMON_THREAD_POOL_H_
+#define AOCOMMON_THREAD_POOL_H_
+
+#include "system.h"
+
+#include <sched.h>
+
+#include <condition_variable>
+#include <functional>
+#include <map>
+#include <mutex>
+#include <thread>
+#include <vector>
+
+namespace aocommon {
+
+/// \brief Defines a class for managing threads.
+class ThreadPool {
+ public:
+  /**
+   * Create a thread pool with NThreads()==system::ProcessorCount().
+   */
+  ThreadPool() : ThreadPool(aocommon::system::ProcessorCount()){};
+
+  /**
+   * Create a thread pool with the specified number of threads.
+   */
+  ThreadPool(size_t nthreads) : _isStopped(false), _priority(0) {
+    if (nthreads == 0)
+      throw std::runtime_error("A ThreadPool was created with nthreads=0");
+    // We reserve one thread less, because we always want a new For loop
+    // to be able to add a new thread (with index 0).
+    _threads.reserve(nthreads - 1);
+    for (size_t i = 1; i != nthreads; ++i)
+      _threads.emplace_back(&ThreadPool::threadFunc, this, i);
+  }
+
+  ThreadPool(const ThreadPool&) = delete;
+  ThreadPool& operator=(const ThreadPool&) = delete;
+
+  ~ThreadPool() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    _isStopped = true;
+    _onProgress.notify_all();
+    lock.unlock();
+    for (std::thread& t : _threads) t.join();
+  }
+
+  size_t NThreads() const { return _threads.size() + 1; }
+
+  void SetNThreads(size_t nThreads) {
+    if (nThreads != NThreads()) {
+      std::unique_lock<std::mutex> lock(_mutex);
+      _isStopped = true;
+      _onProgress.notify_all();
+      lock.unlock();
+      for (std::thread& t : _threads) t.join();
+
+      _threads.clear();
+      _isStopped = false;
+      _priority = 0;
+
+      _threads.reserve(nThreads - 1);
+      for (size_t i = 1; i != nThreads; ++i)
+        _threads.emplace_back(&ThreadPool::threadFunc, this, i);
+    }
+  }
+
+  /**
+   * Iteratively call a function in parallel.
+   *
+   * The function is expected to accept two size_t parameters, the loop
+   * index and the thread id, e.g.:
+   *   void loopFunction(size_t iteration, size_t threadID);
+   * It is called (end-start) times.
+   */
+  template <typename Func>
+  void For(size_t start, size_t end, Func func) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    size_t thisPriority = _priority;
+    ++_priority;
+    lock.unlock();
+
+    size_t progress = end - start;
+
+    std::thread localThread(&ThreadPool::threadSpecificPriorityFunc, this, 0,
+                            thisPriority, &progress);
+
+    // Queue tasks for all iterations
+    while (start != end) {
+      write(thisPriority, std::bind(func, start, std::placeholders::_1),
+            &progress);
+      ++start;
+    }
+
+    localThread.join();
+  }
+
+  [[deprecated(
+      "aocommon::ThreadPool::NCPUs is deprecated, use "
+      "aocommon::system::ProcessorCount() instead")]] static unsigned
+  NCPUs() {
+    return system::ProcessorCount();
+  }
+
+ private:
+  void threadFunc(size_t threadId) {
+    std::pair<std::function<void(size_t)>, size_t*> func;
+    while (read_highest_priority(func)) {
+      func.first(threadId);
+
+      std::unique_lock<std::mutex> lock(_mutex);
+      --(*func.second);  // decrease progress counter (requires lock)
+      _onProgress.notify_all();
+    }
+  }
+
+  void threadSpecificPriorityFunc(size_t threadId, size_t priority,
+                                  size_t* progressPtr) {
+    std::pair<std::function<void(size_t)>, size_t*> func;
+    while (read_specific_priority(priority, func, progressPtr)) {
+      func.first(threadId);
+
+      std::unique_lock<std::mutex> lock(_mutex);
+      --(*progressPtr);
+      _onProgress.notify_all();
+    }
+  }
+
+  bool read_highest_priority(
+      std::pair<std::function<void(size_t)>, size_t*>& func) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (!_isStopped && _tasks.empty()) _onProgress.wait(lock);
+    if (!_tasks.empty()) {
+      func = std::move(_tasks.begin()->second);
+      _tasks.erase(_tasks.begin());
+      _onProgress.notify_all();
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  bool read_specific_priority(
+      size_t priority, std::pair<std::function<void(size_t)>, size_t*>& func,
+      size_t* progress) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    auto iter = _tasks.find(priority);
+    while (!_isStopped && (*progress) > 0 && iter == _tasks.end()) {
+      _onProgress.wait(lock);
+      iter = _tasks.find(priority);
+    }
+    if (iter != _tasks.end()) {
+      func = std::move(iter->second);
+      _tasks.erase(iter);
+      _onProgress.notify_all();
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  void write(size_t priority, std::function<void(size_t)>&& func,
+             size_t* progressPtr) {
+    // Wait until there is space in the map (so that the map
+    // doesn't get too large)
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (_tasks.count(priority) >= NThreads()) {
+      _onProgress.wait(lock);
+    }
+    _tasks.emplace(priority, std::make_pair(std::move(func), progressPtr));
+    _onProgress.notify_all();
+  }
+
+  // Priority, (function, progress*)
+  bool _isStopped;
+  size_t _priority;
+  std::multimap<size_t, std::pair<std::function<void(size_t)>, size_t*>,
+                std::greater<size_t>>
+      _tasks;
+  std::vector<std::thread> _threads;
+  std::mutex _mutex;
+  std::condition_variable _onProgress;
+};
+
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/throwruntimeerror.h b/external/aocommon/include/aocommon/throwruntimeerror.h
new file mode 100644
index 0000000..4d84c7d
--- /dev/null
+++ b/external/aocommon/include/aocommon/throwruntimeerror.h
@@ -0,0 +1,41 @@
+#ifndef AOCOMMON_THROWRUNTIMEERROR_H_
+#define AOCOMMON_THROWRUNTIMEERROR_H_
+
+#include <sstream>
+#include <stdexcept>
+
+namespace aocommon {
+
+#if __cplusplus < 201703L
+namespace detail {
+
+inline void Stream(std::stringstream&) {}
+
+template <class T, class... Args>
+void Stream(std::stringstream& sstr, const T& value, const Args&... args) {
+  sstr << value;
+  Stream(sstr, args...);
+}
+}  // namespace detail
+#endif
+
+/**
+ * Helper function to throw a @c std::runtime_error.
+ *
+ * The function concatenates the @a args to a string and uses that message as
+ * error message for the exception.
+ */
+template <class... Args>
+[[noreturn]] void ThrowRuntimeError(const Args&... args) {
+  std::stringstream sstr;
+#if __cplusplus > 201402L
+  ((sstr << args), ...);
+#else
+  detail::Stream(sstr, args...);
+#endif
+  throw std::runtime_error(sstr.str());
+}
+
+}  // namespace aocommon
+
+#endif  // AO_THROW_RUNTIME_ERROR_H
diff --git a/external/aocommon/include/aocommon/transform_if.h b/external/aocommon/include/aocommon/transform_if.h
new file mode 100644
index 0000000..772f32e
--- /dev/null
+++ b/external/aocommon/include/aocommon/transform_if.h
@@ -0,0 +1,46 @@
+#ifndef AOCOMMON_TRANSFORM_IF_H_
+#define AOCOMMON_TRANSFORM_IF_H_
+
+namespace aocommon {
+
+/**
+ * A combination of std::copy_if and std::transform.
+ *
+ * There's no standard algorithm that can do a filtering transformation. This
+ * function implements that.
+ *
+ * @param first The first element to transform.
+ * @param last  Points one beyond the last element to transform.
+ * @param out   The beginning of the output range.
+ * @param pred  The unary predicate which returns @c true for the required
+ *              arguments.
+ * @param op    The unary operation to be applied to the required elements.
+ *
+ * @returns     One beyond the last element written to.
+ *
+ * Complexity:
+ * - Exactly std::distance(first, last) applications of \a pred
+ * - At most std::distance(first, last) applications of \a op
+ */
+template <class InputIt, class OutputIt, class UnaryPredicate,
+          class UnaryOperation>
+#if __cplusplus > 201402L
+constexpr
+#endif
+    OutputIt
+    transform_if(InputIt first, InputIt last, OutputIt out, UnaryPredicate pred,
+                 UnaryOperation op) {
+  while (first != last) {
+    if (pred(*first)) {
+      *out = op(*first);
+      ++out;
+    }
+    ++first;
+  }
+
+  return out;
+}
+
+}  // namespace aocommon
+
+#endif  // AO_TRANSFORM_IF_H
diff --git a/external/aocommon/include/aocommon/units/angle.h b/external/aocommon/include/aocommon/units/angle.h
new file mode 100644
index 0000000..bb499c4
--- /dev/null
+++ b/external/aocommon/include/aocommon/units/angle.h
@@ -0,0 +1,130 @@
+#ifndef AOCOMMON_UNITS_ANGLE_H_
+#define AOCOMMON_UNITS_ANGLE_H_
+
+#include <string>
+#include <sstream>
+#include <stdexcept>
+#include <cmath>
+
+namespace aocommon {
+namespace units {
+class Angle {
+ public:
+  enum Unit { kRadians, kDegrees, kArcminutes, kArcseconds, kMilliarcseconds };
+  /**
+   * Parse the string as an angle, possibly with unit specification, and return
+   * in radians.
+   * @return The angle (rad)
+   */
+  static double Parse(const std::string& s,
+                      const std::string& value_description,
+                      Unit default_unit = Unit::kRadians);
+
+  static std::string ToNiceString(double angle_rad);
+
+ private:
+  static size_t FindNumberEnd(const std::string& s);
+  static bool IsDigit(const char c) { return c >= '0' && c <= '9'; }
+  static bool IsWhitespace(const char c) { return c == ' ' || c == '\t'; }
+};
+
+inline std::string Angle::ToNiceString(double angle_rad) {
+  std::ostringstream str;
+  double angle_deg = angle_rad * 180.0 / M_PI;
+  if (angle_deg < 0.0) {
+    str << "-";
+    angle_deg = -angle_deg;
+  }
+  if (angle_deg >= 2.0) {
+    str << std::round(angle_deg * 100.0) / 100.0 << " deg";
+  } else {
+    const double angle_arcmin = angle_rad * 180.0 * 60.0 / M_PI;
+    if (angle_arcmin >= 2.0) {
+      str << std::round(angle_arcmin * 100.0) / 100.0 << "'";
+    } else {
+      const double angle_arcsec = angle_rad * 180.0 * 60.0 * 60.0 / M_PI;
+      if (angle_arcsec >= 1.0) {
+        str << std::round(angle_arcsec * 100.0) / 100.0 << "''";
+      } else {
+        str << std::round(angle_arcsec * 100.0 * 1000.0) / 100.0 << " masec";
+      }
+    }
+  }
+  return str.str();
+}
+
+inline double Angle::Parse(const std::string& s,
+                           const std::string& value_description,
+                           Unit default_unit) {
+  size_t end = FindNumberEnd(s);
+  if (end == 0) throw std::runtime_error("Error parsing " + value_description);
+  std::string number = s.substr(0, end);
+  const double val = std::atof(number.c_str());
+  // Skip whitespace after number
+  const char* c = s.c_str();
+  while (IsWhitespace(c[end])) ++end;
+  std::string unit_string = std::string(&c[end]);
+  std::for_each(unit_string.begin(), unit_string.end(),
+                [](char& c) { c = std::tolower(c); });
+
+  // Unit string empty? Than use default unit.
+  if (unit_string.empty()) {
+    switch (default_unit) {
+      case Unit::kRadians:
+        return val;
+      case Unit::kDegrees:
+        return val * M_PI / 180.0;
+      case Unit::kArcminutes:
+        return val * M_PI / (180.0 * 60.0);
+      case Unit::kArcseconds:
+        return val * M_PI / (180.0 * 60.0 * 60.0);
+      case Unit::kMilliarcseconds:
+        return val * M_PI / (180.0 * 60.0 * 60.0 * 1000.0);
+    }
+  }
+
+  // In degrees?
+  else if (unit_string == "deg" || unit_string == "degrees")
+    return val * M_PI / 180.0;
+
+  // In arcmin?
+  else if (unit_string == "amin" || unit_string == "arcmin" ||
+           unit_string == "\'")
+    return val * M_PI / (180.0 * 60.0);
+
+  // In arcsec?
+  else if (unit_string == "asec" || unit_string == "arcsec" ||
+           unit_string == "\'\'")
+    return val * M_PI / (180.0 * 60.0 * 60.0);
+
+  // In marcsec?
+  else if (unit_string == "mas" || unit_string == "masec" ||
+           unit_string == "marcsec")
+    return val * M_PI / (180.0 * 60.0 * 60.0 * 1000.0);
+
+  // In radians
+  else if (unit_string == "rad" || unit_string == "radians")
+    return val;
+
+  throw std::runtime_error("Invalid unit specification in angle given for " +
+                           value_description);
+}
+
+inline size_t Angle::FindNumberEnd(const std::string& s) {
+  const char* c = s.c_str();
+  size_t pos = 0;
+  while (IsWhitespace(c[pos])) ++pos;
+  if (c[pos] == '-') ++pos;
+  while (IsDigit(c[pos])) ++pos;
+  if (c[pos] == '.') ++pos;
+  while (IsDigit(c[pos])) ++pos;
+  if (c[pos] == 'e' || c[pos] == 'E') {
+    ++pos;
+    if (c[pos] == '-' || c[pos] == '+') ++pos;
+    while (IsDigit(c[pos])) ++pos;
+  }
+  return pos;
+}
+}  // namespace units
+}  // namespace aocommon
+#endif
diff --git a/external/aocommon/include/aocommon/units/fluxdensity.h b/external/aocommon/include/aocommon/units/fluxdensity.h
new file mode 100644
index 0000000..0fcfaf6
--- /dev/null
+++ b/external/aocommon/include/aocommon/units/fluxdensity.h
@@ -0,0 +1,127 @@
+#ifndef AOCOMMON_UNITS_FLUX_DENSITY_H_
+#define AOCOMMON_UNITS_FLUX_DENSITY_H_
+
+#include <string>
+#include <sstream>
+#include <stdexcept>
+#include <cmath>
+
+namespace aocommon {
+namespace units {
+class FluxDensity {
+ public:
+  enum Unit { kKiloJansky, kJansky, kMilliJansky, kMicroJansky, kNanoJansky };
+  /**
+   * Parse the string to a flux density, possibly with unit specification, and
+   * return in Jansky.
+   * @return The flux density (Jy)
+   */
+  static double Parse(const std::string& s,
+                      const std::string& value_description,
+                      Unit default_unit = Unit::kJansky);
+
+  static std::string ToNiceString(double value_jansky);
+
+ private:
+  static size_t FindNumberEnd(const std::string& s);
+  static bool IsDigit(const char c) { return c >= '0' && c <= '9'; }
+  static bool IsWhitespace(const char c) { return c == ' ' || c == '\t'; }
+};
+
+inline std::string FluxDensity::ToNiceString(double value_jansky) {
+  std::ostringstream str;
+  if (value_jansky == 0.0)
+    return "0 Jy";
+  else {
+    if (value_jansky < 0.0) {
+      str << "-";
+      value_jansky = -value_jansky;
+    }
+    if (value_jansky >= 1000.0)
+      str << std::round(value_jansky * 0.1) / 100.0 << " KJy";
+    else if (value_jansky >= 1.0)
+      str << std::round(value_jansky * 1e2) / 100.0 << " Jy";
+    else if (value_jansky >= 1e-3)
+      str << std::round(value_jansky * 1e5) / 100.0 << " mJy";
+    else if (value_jansky >= 1e-6)
+      str << std::round(value_jansky * 1e8) / 100.0 << " µJy";
+    else if (value_jansky >= 1e-9)
+      str << std::round(value_jansky * 1e11) / 100.0 << " nJy";
+    else
+      str << value_jansky << " Jy";
+    return str.str();
+  }
+}
+
+inline double FluxDensity::Parse(const std::string& s,
+                                 const std::string& value_description,
+                                 Unit default_unit) {
+  size_t end = FindNumberEnd(s);
+  if (end == 0) {
+    throw std::runtime_error("Error parsing " + value_description);
+  }
+  std::string number = s.substr(0, end);
+  const double val = std::atof(number.c_str());
+  // Skip whitespace after number
+  const char* c = s.c_str();
+  while (IsWhitespace(c[end])) {
+    ++end;
+  }
+  const std::string unit_string = std::string(&c[end]);
+  std::string unit_string_lower = unit_string;
+  std::for_each(unit_string_lower.begin(), unit_string_lower.end(),
+                [](char& c) { c = std::tolower(c); });
+
+  // Unit string empty? Than use default unit.
+  if (unit_string.empty()) {
+    switch (default_unit) {
+      case Unit::kKiloJansky:
+        return val * 1000.0;
+      case Unit::kJansky:
+        return val;
+      case Unit::kMilliJansky:
+        return val / 1e3;
+      case Unit::kMicroJansky:
+        return val / 1e6;
+      case Unit::kNanoJansky:
+        return val / 1e9;
+    }
+  } else if (unit_string_lower == "jy" || unit_string_lower == "jansky")
+    return val;
+  else if (unit_string == "mjy" || unit_string == "mJy" ||
+           unit_string_lower == "millijansky")
+    return val * 1e-3;
+  else if (unit_string == "KJy" || unit_string == "kjy" ||
+           unit_string_lower == "kilojansky")
+    return val * 1e3;
+  else if (unit_string == "µJy" || unit_string == "µjy" ||
+           unit_string_lower == "microjansky")
+    return val * 1e-6;
+  else if (unit_string == "njy" || unit_string == "nJy" ||
+           unit_string_lower == "nanojansky")
+    return val * 1e-9;
+
+  throw std::runtime_error(
+      "Invalid unit specification in flux density given for " +
+      value_description);
+}
+
+inline size_t FluxDensity::FindNumberEnd(const std::string& s) {
+  const char* c = s.c_str();
+  size_t pos = 0;
+  while (IsWhitespace(c[pos])) ++pos;
+  if (c[pos] == '-') ++pos;
+  while (IsDigit(c[pos])) ++pos;
+  if (c[pos] == '.') ++pos;
+  while (IsDigit(c[pos])) ++pos;
+  if (c[pos] == 'e' || c[pos] == 'E') {
+    ++pos;
+    if (c[pos] == '-' || c[pos] == '+') ++pos;
+    while (IsDigit(c[pos])) ++pos;
+  }
+  return pos;
+}
+}  // namespace units
+}  // namespace aocommon
+
+#endif
diff --git a/external/aocommon/include/aocommon/uvector.h b/external/aocommon/include/aocommon/uvector.h
new file mode 100644
index 0000000..e7760f1
--- /dev/null
+++ b/external/aocommon/include/aocommon/uvector.h
@@ -0,0 +1,1207 @@
+#ifndef AOCOMMON_UVECTOR_11_H_
+#define AOCOMMON_UVECTOR_11_H_
+
+#include <algorithm>
+#include <cstring>
+#include <iterator>
+#include <memory>
+#include <stdexcept>
+#include <utility>
+
+/**
+ * @file uvector.h
+ * Header file for UVector and its relational and swap functions.
+ * @author André Offringa
+ * @copyright André Offringa, 2013, distributed under the GPL license version 3.
+ */
+
+namespace aocommon {
+
+/**
+ * @defgroup UVector Class UVector and related functions.
+ * @{
+ */
+
+/**
+ * @brief A container similar to std::vector, but one that allows construction
+ * without initializing its elements.
+ * @details This container is similar to a std::vector, except that it can be
+ * constructed without initializing its elements. This saves the overhead of
+ * initialization, hence the constructor @ref UVector(size_t) is significantly
+ * faster than the corresponding std::vector constructor, and has no overhead
+ * compared to a manually allocated array.
+ *
+ * Probably its greatest strength lies in the construction of containers with a
+ * number of elements that is runtime defined, but that will be initialized
+ * later. For example:
+ *
+ * @code
+ * // Open a file
+ * ifstream file("myfile.bin");
+ *
+ * // Construct a buffer for this file
+ * UVector<char> buffer(buffer_size);
+ *
+ * // Read some data into the buffer
+ * file.read(&buffer[0], buffer_size);
+ * @endcode
+ *
+ * However, it has a few more use-cases with improved performance over
+ * std::vector. This is possible because of more strengent requirements on the
+ * element's type.
+ *
+ * The container will behave correctly with any trivial type, but will not work
+ * for almost all non-trivial types.
+ *
+ * The methods with different semantics compared to std::vector are:
+ * * @ref UVector(size_t n)
+ * * @ref resize(size_t n)
+ *
+ * Also the following new members are introduced:
+ * * @ref insert_uninitialized(const_iterator position, size_t n)
+ * * @ref push_back(InputIterator first, InputIterator last)
+ * * @ref push_back(size_t n, const Tp& val)
+ * * @ref push_back(std::initializer_list<Tp> initlist)
+ * * @ref push_back_uninitialized(size_t n)
+ *
+ * All other members work exactly like std::vector's members, although some are
+ * slightly faster because of the stricter requirements on the element type.
+ *
+ * @tparam Tp Container's element type
+ * @tparam Alloc Allocator type. Default is to use the std::allocator.
+ *
+ * @author André Offringa
+ * @copyright André Offringa, 2013, distributed under the GPL license version 3.
+ */
+template <typename Tp, typename Alloc = std::allocator<Tp>>
+class UVector : private Alloc {
+  static_assert(std::is_standard_layout<Tp>(),
+                "A UVector can only hold classes with standard layout");
+
+ public:
+  /// Element type
+  typedef Tp value_type;
+  /// Type of allocator used to allocate and deallocate space
+  typedef Alloc allocator_type;
+  /// Reference to element type
+  typedef Tp& reference;
+  /// Constant reference to element type
+  typedef const Tp& const_reference;
+  /// Pointer to element type
+  typedef Tp* pointer;
+  /// Pointer to constant element type
+  typedef const Tp* const_pointer;
+  /// Iterator type
+  typedef Tp* iterator;
+  /// Iterator type of constant elements
+  typedef const Tp* const_iterator;
+  /// Reverse iterator type
+  typedef std::reverse_iterator<iterator> reverse_iterator;
+  /// Reverse iterator of constant elements
+  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+  /// Difference between to iterators
+  typedef std::ptrdiff_t difference_type;
+  /// Type used for indexing elements
+  typedef std::size_t size_t;
+  /// Type used for indexing elements
+  typedef std::size_t size_type;
+
+ private:
+#if __cplusplus > 201402L
+  typedef typename std::allocator_traits<allocator_type>::is_always_equal
+      allocator_is_always_equal;
+#else
+  typedef std::false_type allocator_is_always_equal;
+#endif
+  pointer _begin, _end, _endOfStorage;
+
+ public:
+  /** @brief Construct an empty UVector.
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  explicit UVector(const allocator_type& allocator = Alloc()) noexcept
+      : Alloc(allocator),
+        _begin(nullptr),
+        _end(nullptr),
+        _endOfStorage(nullptr) {}
+
+  /** @brief Construct a vector with given amount of elements, without
+   * initializing these.
+   * @details This constructor deviates from std::vector's behaviour, because it
+   * will not value construct its elements. It is therefore faster than the
+   * corresponding constructor of std::vector.
+   * @param n Number of elements that the UVector will be initialized with.
+   */
+  explicit UVector(size_t n)
+      : _begin(allocate(n)), _end(_begin + n), _endOfStorage(_end) {}
+
+  /** @brief Construct a vector with given amount of elements and set these to a
+   * specific value.
+   * @details This constructor will initialize its members with the given value.
+   * @param n Number of elements that the UVector will be initialized with.
+   * @param val Value to initialize all elements with
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  UVector(size_t n, const value_type& val,
+          const allocator_type& allocator = Alloc())
+      : Alloc(allocator),
+        _begin(allocate(n)),
+        _end(_begin + n),
+        _endOfStorage(_end) {
+    std::uninitialized_fill_n<Tp*, size_t>(_begin, n, val);
+  }
+
+  /** @brief Construct a vector by copying elements from a range.
+   * @param first Iterator to range start
+   * @param last Iterator to range end
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  template <class InputIterator>
+  UVector(InputIterator first, InputIterator last,
+          const allocator_type& allocator = Alloc())
+      : Alloc(allocator) {
+    construct_from_range<InputIterator>(first, last,
+                                        std::is_integral<InputIterator>());
+  }
+
+  /** @brief Copy construct a UVector.
+   * @details The allocator of the new UVector will be initialized from
+   * @c
+   * std::allocator_traits<Alloc>::select_on_container_copy_construction(other).
+   * @param other Source UVector to be copied from.
+   */
+  UVector(const UVector<Tp, Alloc>& other)
+      : Alloc(
+            std::allocator_traits<Alloc>::select_on_container_copy_construction(
+                static_cast<allocator_type>(other))),
+        _begin(allocate(other.size())),
+        _end(_begin + other.size()),
+        _endOfStorage(_end) {
+    std::copy(other._begin, other._end, _begin);
+  }
+
+  /** @brief Copy construct a UVector with custom allocator.
+   * @param other Source UVector to be copied from.
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  UVector(const UVector<Tp, Alloc>& other, const allocator_type& allocator)
+      : Alloc(allocator),
+        _begin(allocate(other.size())),
+        _end(_begin + other.size()),
+        _endOfStorage(_end) {
+    std::copy(other._begin, other._end, _begin);
+  }
+
+  /** @brief Move construct a UVector.
+   * @param other Source UVector to be moved from.
+   */
+  UVector(UVector<Tp, Alloc>&& other) noexcept
+      : Alloc(std::move(other)),
+        _begin(other._begin),
+        _end(other._end),
+        _endOfStorage(other._endOfStorage) {
+    other._begin = nullptr;
+    other._end = nullptr;
+    other._endOfStorage = nullptr;
+  }
+
+  /** @brief Move construct a UVector with custom allocator.
+   * @param other Source UVector to be moved from.
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  UVector(UVector<Tp, Alloc>&& other, const allocator_type& allocator) noexcept
+      : Alloc(allocator),
+        _begin(other._begin),
+        _end(other._end),
+        _endOfStorage(other._endOfStorage) {
+    other._begin = nullptr;
+    other._end = nullptr;
+    other._endOfStorage = nullptr;
+  }
+
+  /** @brief Construct a UVector from a initializer list.
+   * @param initlist Initializer list used for initializing the new UVector.
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  UVector(std::initializer_list<Tp> initlist,
+          const allocator_type& allocator = Alloc())
+      : Alloc(allocator),
+        _begin(allocate(initlist.size())),
+        _end(_begin + initlist.size()),
+        _endOfStorage(_end) {
+    iterator destIter = _begin;
+    for (typename std::initializer_list<Tp>::const_iterator i =
+             initlist.begin();
+         i != initlist.end(); ++i) {
+      *destIter = *i;
+      ++destIter;
+    }
+  }
+
+  /** @brief Destructor. */
+  ~UVector() noexcept { deallocate(); }
+
+  /** @brief Assign another UVector to this UVector.
+   * @details The allocator of the UVector will be assigned to @p other when
+   * std::allocator_traits<Alloc>::propagate_on_container_copy_assignment() is
+   * of true_type.
+   */
+  UVector& operator=(const UVector<Tp, Alloc>& other) {
+    return assign_copy_from(
+        other, typename std::allocator_traits<
+                   Alloc>::propagate_on_container_copy_assignment());
+  }
+
+  /** @brief Assign another UVector to this UVector.
+   * @details The allocator of the UVector will be assigned to @p other when
+   * std::allocator_traits<Alloc>::propagate_on_container_move_assignment() is
+   * of true_type.
+   */
+  UVector& operator=(UVector<Tp, Alloc>&& other) noexcept(
+      std::allocator_traits<
+          Alloc>::propagate_on_container_move_assignment::value ||
+      allocator_is_always_equal::value) {
+    return assign_move_from(
+        std::move(other), typename std::allocator_traits<
+                              Alloc>::propagate_on_container_move_assignment());
+  }
+
+  /** @brief Get iterator to first element. */
+  iterator begin() noexcept { return _begin; }
+
+  /** @brief Get constant iterator to first element. */
+  const_iterator begin() const noexcept { return _begin; }
+
+  /** @brief Get iterator to element past last element. */
+  iterator end() noexcept { return _end; }
+
+  /** @brief Get constant iterator to element past last element. */
+  const_iterator end() const noexcept { return _end; }
+
+  /** @brief Get reverse iterator to last element. */
+  reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
+
+  /** @brief Get constant reverse iterator to last element. */
+  const_reverse_iterator rbegin() const noexcept {
+    return const_reverse_iterator(end());
+  }
+
+  /** @brief Get reverse iterator to element before first element. */
+  reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
+
+  /** @brief Get constant reverse iterator to element before first element. */
+  const_reverse_iterator rend() const noexcept {
+    return const_reverse_iterator(begin());
+  }
+
+  /** @brief Get constant iterator to first element. */
+  const_iterator cbegin() const noexcept { return _begin; }
+
+  /** @brief Get constant iterator to element past last element. */
+  const_iterator cend() const noexcept { return _end; }
+
+  /** @brief Get constant reverse iterator to last element. */
+  const_reverse_iterator crbegin() const noexcept {
+    return const_reverse_iterator(end());
+  }
+
+  /** @brief Get constant reverse iterator to element before first element. */
+  const_reverse_iterator crend() const noexcept {
+    return const_reverse_iterator(begin());
+  }
+
+  /** @brief Get number of elements in container. */
+  size_t size() const noexcept { return _end - _begin; }
+
+  /** @brief Get maximum number of elements that this container can hold. */
+  size_t max_size() const noexcept { return Alloc::max_size(); }
+
+  /** @brief Change the number of elements in the container.
+   * @details If the new size is larger than the current size, new values will
+   * be left uninitialized. Therefore, it is more efficient than @c
+   * resize(size_t) in
+   * @c std::vector, as well as @ref resize(size_t, const Tp&).
+   * If the new size is smaller than the current size, the container will be
+   * truncated and elements past the new size will be removed. No destructor of
+   * the removed elements will be called.
+   * @param n The new size of the container.
+   */
+  void resize(size_t n) {
+    if (capacity() < n) {
+      size_t newSize = enlarge_size(n);
+      pointer newStorage = allocate(newSize);
+      std::move(_begin, _end, newStorage);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + newSize;
+    }
+    _end = _begin + n;
+  }
+
+  /** @brief Change the number of elements in the container.
+   * @details If the new size is larger than the current size, new values will
+   * be initialized by the given value. If the new size is smaller than the
+   * current size, the container will be truncated and elements past the new
+   * size will be removed. No destructor of the removed elements will be called.
+   * @param n The new size of the container.
+   * @param val New value of elements that get added to the container.
+   */
+  void resize(size_t n, const Tp& val) {
+    size_t oldSize = size();
+    if (capacity() < n) {
+      pointer newStorage = allocate(n);
+      std::move(_begin, _end, newStorage);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + n;
+    }
+    _end = _begin + n;
+    if (oldSize < n)
+      std::uninitialized_fill<Tp*, size_t>(_begin + oldSize, _end, val);
+  }
+
+  /** @brief Get the number of elements the container can currently hold without
+   * reallocating storage. */
+  size_t capacity() const noexcept { return _endOfStorage - _begin; }
+
+  /** @brief Determine if the container is currently empty.
+   * @returns @c true if @ref size() == 0. */
+  bool empty() const noexcept { return _begin == _end; }
+
+  /** @brief Reserve space for a number of elements, to prevent the overhead of
+   * extra reallocations.
+   * @details This has no effect on the working of the UVector, except that it
+   * might change the current capacity. This can enhance performance when a
+   * large number of elements are added, and an approximate size is known a
+   * priori.
+   *
+   * This method might cause a reallocation, causing iterators to be
+   * invalidated.
+   * @param n Number of elements to reserve space for.
+   */
+  void reserve(size_t n) {
+    if (capacity() < n) {
+      const size_t curSize = size();
+      pointer newStorage = allocate(n);
+      std::move(_begin, _begin + curSize, newStorage);
+      deallocate();
+      _begin = newStorage;
+      _end = newStorage + curSize;
+      _endOfStorage = _begin + n;
+    }
+  }
+
+  /** @brief Change the capacity of the container such that no extra space is
+   * hold.
+   * @details This has no effect on the working of the UVector, except that it
+   * might change the current capacity. This can reduce the current memory usage
+   * of the container.
+   *
+   * This method might cause a reallocation, causing iterators to be
+   * invalidated.
+   */
+  void shrink_to_fit() {
+    const size_t curSize = size();
+    if (curSize == 0) {
+      deallocate();
+      _begin = nullptr;
+      _end = nullptr;
+      _endOfStorage = nullptr;
+    } else if (curSize < capacity()) {
+      pointer newStorage = allocate(curSize);
+      std::move(_begin, _begin + curSize, newStorage);
+      deallocate();
+      _begin = newStorage;
+      _end = newStorage + curSize;
+      _endOfStorage = _begin + curSize;
+    }
+  }
+
+  /** @brief Get a reference to the element at the given index. */
+  Tp& operator[](size_t index) noexcept { return _begin[index]; }
+
+  /** @brief Get a constant reference to the element at the given index. */
+  const Tp& operator[](size_t index) const noexcept { return _begin[index]; }
+
+  /** @brief Get a reference to the element at the given index with bounds
+   * checking.
+   * @throws std::out_of_range when given index is past the last element.
+   */
+  Tp& at(size_t index) {
+    check_bounds(index);
+    return _begin[index];
+  }
+
+  /** @brief Get a constant reference to the element at the given index with
+   * bounds checking.
+   * @throws std::out_of_range when given index is past the last element.
+   */
+  const Tp& at(size_t index) const {
+    check_bounds(index);
+    return _begin[index];
+  }
+
+  /** @brief Get reference to first element in container. */
+  Tp& front() noexcept { return *_begin; }
+
+  /** @brief Get constant reference to first element in container. */
+  const Tp& front() const noexcept { return *_begin; }
+
+  /** @brief Get reference to last element in container. */
+  Tp& back() noexcept { return *(_end - 1); }
+
+  /** @brief Get constant reference to last element in container. */
+  const Tp& back() const noexcept { return *(_end - 1); }
+
+  /** @brief Get pointer to internal storage. */
+  Tp* data() noexcept { return _begin; }
+
+  /** @brief Get constant pointer to internal storage. */
+  const Tp* data() const noexcept { return _begin; }
+
+  /** @brief Assign this container to be equal to the given range.
+   * @details The container will be resized to fit the length of the given
+   * range. Iterators are invalidated.
+   * @param first Iterator to the beginning of the range.
+   * @param last Iterator past the end of the range.
+   */
+  template <class InputIterator>
+  void assign(InputIterator first, InputIterator last) {
+    assign_from_range<InputIterator>(first, last,
+                                     std::is_integral<InputIterator>());
+  }
+
+  /** @brief Resize the container and assign the given value to all elements.
+   * @details Iterators are invalidated.
+   * @param n New size of container
+   * @param val Value to be assigned to all elements.
+   */
+  void assign(size_t n, const Tp& val) {
+    if (n > capacity()) {
+      iterator newStorage = allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + n;
+    }
+    _end = _begin + n;
+    std::uninitialized_fill_n<Tp*, size_t>(_begin, n, val);
+  }
+
+  /** @brief Assign this container to an initializer list.
+   * @details The container will be resized to fit the length of the given
+   * initializer list. Iterators are invalidated.
+   * @param initlist List of values to assign to the container.
+   */
+  void assign(std::initializer_list<Tp> initlist) {
+    if (initlist.size() > capacity()) {
+      iterator newStorage = allocate(initlist.size());
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + initlist.size();
+    }
+    _end = _begin + initlist.size();
+    iterator destIter = _begin;
+    for (typename std::initializer_list<Tp>::const_iterator i =
+             initlist.begin();
+         i != initlist.end(); ++i) {
+      *destIter = *i;
+      ++destIter;
+    }
+  }
+
+  /** @brief Add the given value to the end of the container.
+   * @details Iterators are invalidated.
+   * @param item Value of new element.
+   */
+  void push_back(const Tp& item) {
+    if (_end == _endOfStorage) enlarge(enlarge_size(1));
+    *_end = item;
+    ++_end;
+  }
+
+  /** @brief Add the given value to the end of the container by moving it in.
+   * @details Iterators are invalidated.
+   *
+   * Note that this container can only hold simple types that do not perform
+   * allocations. Therefore, there is probably no benefit in moving the new item
+   * in over copying it in with @ref push_back(const Tp&).
+   * @param item Value of new element.
+   */
+  void push_back(Tp&& item) {
+    if (_end == _endOfStorage) enlarge(enlarge_size(1));
+    *_end = std::move(item);
+    ++_end;
+  }
+
+  /** @brief Remove the last element from the container. */
+  void pop_back() { --_end; }
+
+  /** @brief Insert an element at a given position.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new element. The new element will be added
+   * before the old element at that position.
+   * @param item Value of the new item.
+   * @return Position of the new element.
+   */
+  iterator insert(const_iterator position, const Tp& item) {
+    if (_end == _endOfStorage) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(1), index, 1);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + 1);
+      ++_end;
+    }
+    *const_cast<iterator>(position) = item;
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Insert elements at a given position and initialize them with a
+   * value.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new elements. The new elements will be
+   * added before the old element at that position.
+   * @param n Number of elements to add.
+   * @param val Value of the new item.
+   * @return Position of the first new element.
+   */
+  iterator insert(const_iterator position, size_t n, const Tp& val) {
+    if (capacity() < size() + n) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(n), index, n);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + n);
+      _end += n;
+    }
+    std::uninitialized_fill_n<Tp*, size_t>(const_cast<iterator>(position), n,
+                                           val);
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Insert elements at a given position and initialize them from a
+   * range.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new elements. The new elements will be
+   * added before the old element at that position.
+   * @param first Iterator to the beginning of the range.
+   * @param last Iterator past the end of the range.
+   * @return Position of the first new element.
+   */
+  template <class InputIterator>
+  iterator insert(const_iterator position, InputIterator first,
+                  InputIterator last) {
+    return insert_from_range<InputIterator>(position, first, last,
+                                            std::is_integral<InputIterator>());
+  }
+
+  /** @brief Insert an element at a given position by moving it in.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   *
+   * Note that this container can only hold simple types that do not perform
+   * allocations. Therefore, there is probably no benefit in moving the new item
+   * in over copying it in with
+   * @ref insert(const_iterator, const Tp&).
+   * @param position Position of the new element. The new element will be added
+   * before the old element at that position.
+   * @param item Value of the new item.
+   * @return Position of the new element.
+   */
+  iterator insert(const_iterator position, Tp&& item) {
+    if (_end == _endOfStorage) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(1), index, 1);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + 1);
+      ++_end;
+    }
+    *const_cast<iterator>(position) = std::move(item);
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Insert elements at a given position and initialize them from a
+   * initializer list.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new elements. The new elements will be
+   * added before the old element at that position.
+   * @param initlist List of items to insert.
+   * @return Position of the first new element.
+   */
+  iterator insert(const_iterator position, std::initializer_list<Tp> initlist) {
+    if (capacity() < size() + initlist.size()) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(initlist.size()), index, initlist.size());
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end,
+                         _end + initlist.size());
+      _end += initlist.size();
+    }
+    iterator destIter = const_cast<iterator>(position);
+    for (typename std::initializer_list<Tp>::const_iterator i =
+             initlist.begin();
+         i != initlist.end(); ++i) {
+      *destIter = *i;
+      ++destIter;
+    }
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Delete an element from the container.
+   * @details This operation moves all elements past the removed element, and
+   * can therefore be expensive.
+   * @param position Position of element to be removed.
+   * @return Iterator pointing to the first element past the delete element.
+   */
+  iterator erase(const_iterator position) {
+    std::move(const_cast<iterator>(position) + 1, _end,
+              const_cast<iterator>(position));
+    --_end;
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Delete a range of elements from the container.
+   * @details This operation moves all elements past the removed elements, and
+   * can therefore be expensive.
+   * @param first Position of first element to be removed.
+   * @param last Position past last element to be removed.
+   * @return Iterator pointing to the first element past the delete element.
+   */
+  iterator erase(const_iterator first, const_iterator last) {
+    std::move(const_cast<iterator>(last), _end, const_cast<iterator>(first));
+    _end -= last - first;
+    return const_cast<iterator>(first);
+  }
+
+  /** @brief Swap the contents of this UVector with the given UVector.
+   * @details Iterators to both vectors will remain valid and will point into
+   * to the swapped container afterwards. This function will never reallocate
+   * space.
+   *
+   * The allocator will be swapped when the @c propagate_on_container_swap
+   * of the respective @c allocator_trait is @c true_type.
+   * Its behaviour is undefined when the allocators do not compare equal and
+   * @c propagate_on_container_swap is false.
+   * @param other Other UVector whose contents it to be swapped with this.
+   */
+  void swap(UVector<Tp, Alloc>& other) noexcept {
+    swap(other,
+         typename std::allocator_traits<Alloc>::propagate_on_container_swap());
+  }
+
+  /** @brief Remove all elements from the container. */
+  void clear() { _end = _begin; }
+
+  /** @brief Insert an element at a given position by constructing it in place.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new element. The new element will be added
+   * before the old element at that position.
+   * @param args List of arguments to be forwarded to construct the new element.
+   * @return Position of the new element.
+   */
+  template <typename... Args>
+  iterator emplace(const_iterator position, Args&&... args) {
+    if (_end == _endOfStorage) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(1), index, 1);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + 1);
+      ++_end;
+    }
+    *const_cast<iterator>(position) = Tp(std::forward<Args>(args)...);
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Add the given value to the end of the container by constructing it
+   * in place.
+   * @details Iterators are invalidated.
+   * @param args List of arguments to be forwarded to construct the new element.
+   */
+  template <typename... Args>
+  void emplace_back(Args&&... args) {
+    if (_end == _endOfStorage) enlarge(enlarge_size(1));
+    *_end = Tp(std::forward<Args>(args)...);
+    ++_end;
+  }
+
+  /** @brief Get a copy of the allocator. */
+  allocator_type get_allocator() const noexcept { return *this; }
+
+  // --- NON STANDARD METHODS ---
+
+  /** @brief Insert elements at a given position without initializing them.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive. It will
+   * not initialize the new elements, and is therefore faster than @ref
+   * insert(const_iterator, size_t, const Tp&).
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param position Position of the new elements. The new elements will be
+   * added before the old element at that position.
+   * @param n Number of elements to add.
+   * @returns Iterator pointing to the start position of the written sequence
+   */
+  iterator insert_uninitialized(const_iterator position, size_t n) {
+    if (capacity() < size() + n) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(n), index, n);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + n);
+      _end += n;
+    }
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Add a range of items to the end of the container.
+   * @details All iterators will be invalidated.
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param first Iterator to the beginning of the range.
+   * @param last Iterator past the end of the range.
+   */
+  template <class InputIterator>
+  void push_back(InputIterator first, InputIterator last) {
+    push_back_range<InputIterator>(first, last,
+                                   std::is_integral<InputIterator>());
+  }
+
+  /** @brief Add elements at the end and initialize them with a value.
+   * @details All iterators will be invalidated.
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param n Number of elements to add.
+   * @param val Value of the new items.
+   */
+  void push_back(size_t n, const Tp& val) {
+    if (capacity() - size() < n) {
+      enlarge(enlarge_size(n));
+    }
+    std::uninitialized_fill_n<Tp*, size_t>(_end, n, val);
+    _end += n;
+  }
+
+  /** @brief Add elements from an initializer list to the end of the container.
+   * @details All iterators will be invalidated.
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param initlist The list with values to add.
+   */
+  void push_back(std::initializer_list<Tp> initlist) {
+    if (capacity() - size() < initlist.size()) {
+      enlarge(enlarge_size(initlist.size()));
+    }
+    for (typename std::initializer_list<Tp>::iterator i = initlist.begin();
+         i != initlist.end(); ++i) {
+      *_end = *i;
+      ++_end;
+    }
+  }
+
+  /** @brief Add elements at the end without initializing them.
+   * @details All iterators will be invalidated.
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param n Number of elements to add.
+   */
+  void push_back_uninitialized(size_t n) { resize(size() + n); }
+
+ private:
+  pointer allocate(size_t n) { return Alloc::allocate(n); }
+
+  void deallocate() noexcept { deallocate(_begin, capacity()); }
+
+  void deallocate(pointer begin, size_t n) noexcept {
+    if (begin != nullptr) Alloc::deallocate(begin, n);
+  }
+
+  template <typename InputIterator>
+  void construct_from_range(InputIterator first, InputIterator last,
+                            std::false_type) {
+    construct_from_range<InputIterator>(
+        first, last,
+        typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  template <typename Integral>
+  void construct_from_range(Integral n, Integral val, std::true_type) {
+    _begin = allocate(n);
+    _end = _begin + n;
+    _endOfStorage = _end;
+    std::uninitialized_fill_n<Tp*, size_t>(_begin, n, val);
+  }
+
+  template <typename InputIterator>
+  void construct_from_range(InputIterator first, InputIterator last,
+                            std::forward_iterator_tag) {
+    size_t n = std::distance(first, last);
+    _begin = allocate(n);
+    _end = _begin + n;
+    _endOfStorage = _begin + n;
+    Tp* destIter = _begin;
+    while (first != last) {
+      *destIter = *first;
+      ++destIter;
+      ++first;
+    }
+  }
+
+  template <typename InputIterator>
+  void assign_from_range(InputIterator first, InputIterator last,
+                         std::false_type) {
+    assign_from_range<InputIterator>(
+        first, last,
+        typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  // This function is called from assign(iter,iter) when Tp is an integral. In
+  // that case, the user tried to call assign(n, &val), but it got caught by the
+  // wrong overload.
+  template <typename Integral>
+  void assign_from_range(Integral n, Integral val, std::true_type) {
+    if (size_t(n) > capacity()) {
+      iterator newStorage = allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + n;
+    }
+    _end = _begin + n;
+    std::uninitialized_fill_n<Tp*, size_t>(_begin, n, val);
+  }
+
+  template <typename InputIterator>
+  void assign_from_range(InputIterator first, InputIterator last,
+                         std::forward_iterator_tag) {
+    size_t n = std::distance(first, last);
+    if (n > capacity()) {
+      iterator newStorage = allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + n;
+    }
+    _end = _begin + n;
+    Tp* destIter = _begin;
+    while (first != last) {
+      *destIter = *first;
+      ++destIter;
+      ++first;
+    }
+  }
+
+  template <typename InputIterator>
+  iterator insert_from_range(const_iterator position, InputIterator first,
+                             InputIterator last, std::false_type) {
+    return insert_from_range<InputIterator>(
+        position, first, last,
+        typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  template <typename Integral>
+  iterator insert_from_range(const_iterator position, Integral n, Integral val,
+                             std::true_type) {
+    if (capacity() < size() + n) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(n), index, n);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + n);
+      _end += n;
+    }
+    std::uninitialized_fill_n<Tp*, size_t>(const_cast<iterator>(position), n,
+                                           val);
+    return const_cast<iterator>(position);
+  }
+
+  template <typename InputIterator>
+  iterator insert_from_range(const_iterator position, InputIterator first,
+                             InputIterator last, std::forward_iterator_tag) {
+    size_t n = std::distance(first, last);
+    if (capacity() < size() + n) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(n), index, n);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + n);
+      _end += n;
+    }
+    Tp* destIter = const_cast<iterator>(position);
+    while (first != last) {
+      *destIter = *first;
+      ++destIter;
+      ++first;
+    }
+    return const_cast<iterator>(position);
+  }
+
+  void check_bounds(size_t index) const {
+    if (index >= size())
+      throw std::out_of_range("Access to element in UVector past end");
+  }
+
+  size_t enlarge_size(size_t extra_space_needed) const noexcept {
+    return size() + std::max(size(), extra_space_needed);
+  }
+
+  void enlarge(size_t newSize) {
+    pointer newStorage = allocate(newSize);
+    std::copy(_begin, _end, newStorage);
+    deallocate();
+    _end = newStorage + size();
+    _begin = newStorage;
+    _endOfStorage = _begin + newSize;
+  }
+
+  void enlarge_for_insert(size_t newSize, size_t insert_position,
+                          size_t insert_count) {
+    pointer newStorage = allocate(newSize);
+    std::copy(_begin, _begin + insert_position, newStorage);
+    std::copy(_begin + insert_position, _end,
+              newStorage + insert_position + insert_count);
+    deallocate();
+    _end = newStorage + size() + insert_count;
+    _begin = newStorage;
+    _endOfStorage = _begin + newSize;
+  }
+
+  // implementation of operator=(const&) without
+  // propagate_on_container_copy_assignment
+  UVector& assign_copy_from(const UVector<Tp, Alloc>& other, std::false_type) {
+    const size_t n = other.size();
+    if (n > capacity()) {
+      iterator newStorage = allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _end = _begin + n;
+      _endOfStorage = _end;
+    }
+    std::copy(other._begin, other._begin + n, _begin);
+    return *this;
+  }
+
+  // implementation of operator=(const&) with
+  // propagate_on_container_copy_assignment
+  UVector& assign_copy_from(const UVector<Tp, Alloc>& other, std::true_type) {
+    if (allocator_is_always_equal() ||
+        static_cast<Alloc&>(other) == static_cast<Alloc&>(*this)) {
+      assign_copy_from(other, std::false_type());
+    } else {
+      const size_t n = other.size();
+      iterator newStorage = static_cast<Alloc&>(other).allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _end = _begin + n;
+      _endOfStorage = _end;
+      std::copy(other._begin, other._begin + n, _begin);
+      Alloc::operator=(static_cast<Alloc&>(other));
+    }
+    return *this;
+  }
+
+  // implementation of operator=() without
+  // propagate_on_container_move_assignment
+  UVector& assign_move_from(
+      UVector<Tp, Alloc>&& other,
+      std::false_type) noexcept(allocator_is_always_equal::value) {
+    if (allocator_is_always_equal::value ||
+        static_cast<Alloc&>(other) == static_cast<Alloc&>(*this)) {
+      deallocate();
+      _begin = other._begin;
+      _end = other._end;
+      _endOfStorage = other._endOfStorage;
+      other._begin = nullptr;
+      other._end = nullptr;
+      other._endOfStorage = nullptr;
+    } else {
+      // We should not propagate the allocator and the allocators are different.
+      // This means we can not swap the allocated space, since then we would
+      // deallocate the space with a different allocator type. Therefore, we
+      // need to copy:
+      assign_copy_from(other, std::false_type());
+    }
+    return *this;
+  }
+
+  // implementation of operator=() with propagate_on_container_move_assignment
+  UVector& assign_move_from(UVector<Tp, Alloc>&& other,
+                            std::true_type) noexcept {
+    deallocate();
+    Alloc::operator=(std::move(static_cast<Alloc&>(other)));
+    _begin = other._begin;
+    _end = other._end;
+    _endOfStorage = other._endOfStorage;
+    other._begin = nullptr;
+    other._end = nullptr;
+    other._endOfStorage = nullptr;
+    return *this;
+  }
+
+  // implementation of swap with propagate_on_container_swap
+  void swap(UVector<Tp, Alloc>& other, std::true_type) noexcept {
+    std::swap(_begin, other._begin);
+    std::swap(_end, other._end);
+    std::swap(_endOfStorage, other._endOfStorage);
+    std::swap(static_cast<Alloc&>(other), static_cast<Alloc&>(*this));
+  }
+
+  // implementation of swap without propagate_on_container_swap
+  void swap(UVector<Tp, Alloc>& other, std::false_type) noexcept {
+    std::swap(_begin, other._begin);
+    std::swap(_end, other._end);
+    std::swap(_endOfStorage, other._endOfStorage);
+    /**
+     * We have two choices here:
+     * - Do not swap the allocators. For stateful allocators, we would need to
+     *   reallocate memory, and iterators would not be valid UNLESS
+     *   they were stored as indices. However, containers with stateful
+     * allocators are not allowed to be swapped unless the allocators are equal,
+     * in which case swapping is not necessary.
+     * - Swap the allocators. This would not reallocate memory and
+     *   iterators remain valid, but the trait ignores
+     * propagate_on_container_swap.
+     *
+     * The standard says:
+     * "Allocator replacement is performed by copy assignment, move assignment,
+     * or swapping of the allocator only if allocator_traits<allocatortype>::
+     * propagate_on_container_copy_assignment::value,
+     * allocator_traits<allocatortype>::propagate_on_container_move_assignment::value,
+     * or allocator_traits<allocatortype>::propagate_on_container_swap::value is
+     * true within the implementation of the corresponding container operation.
+     * The behavior of a call to a container’s swap function is undefined unless
+     * the objects being swapped have allocators that compare equal or
+     * allocator_traits<allocatortype>::propagate_on_container_swap::value is
+     * true."
+     */
+  }
+
+  template <typename InputIterator>
+  void push_back_range(InputIterator first, InputIterator last,
+                       std::false_type) {
+    push_back_range<InputIterator>(
+        first, last,
+        typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  // This function is called from push_back(iter,iter) when Tp is an integral.
+  // In that case, the user tried to call push_back(n, &val), but it got caught
+  // by the wrong overload.
+  template <typename Integral>
+  void push_back_range(Integral n, Integral val, std::true_type) {
+    if (capacity() - size() < size_t(n)) {
+      enlarge(enlarge_size(n));
+    }
+    std::uninitialized_fill_n<Tp*, size_t>(_end, n, val);
+    _end += n;
+  }
+
+  template <typename InputIterator>
+  void push_back_range(InputIterator first, InputIterator last,
+                       std::forward_iterator_tag) {
+    size_t n = std::distance(first, last);
+    if (n > capacity() - size()) {
+      enlarge(enlarge_size(n));
+    }
+    while (first != last) {
+      *_end = *first;
+      ++_end;
+      ++first;
+    }
+  }
+};
+
+/** @brief Compare two UVectors for equality. */
+template <class Tp, class Alloc>
+inline bool operator==(const UVector<Tp, Alloc>& lhs,
+                       const UVector<Tp, Alloc>& rhs) noexcept {
+  return lhs.size() == rhs.size() &&
+         std::equal(lhs.begin(), lhs.end(), rhs.begin());
+}
+
+/** @brief Compare two UVectors for inequality. */
+template <class Tp, class Alloc>
+inline bool operator!=(const UVector<Tp, Alloc>& lhs,
+                       const UVector<Tp, Alloc>& rhs) noexcept {
+  return !(lhs == rhs);
+}
+
+/** @brief Compare two UVectors for smaller than.
+ * @details If two UVectors compare equal up to the length of one, the UVector
+ * with the smallest size is consider to be smaller.
+ */
+template <class Tp, class Alloc>
+inline bool operator<(const UVector<Tp, Alloc>& lhs,
+                      const UVector<Tp, Alloc>& rhs) noexcept {
+  const size_t minSize = std::min(lhs.size(), rhs.size());
+  for (size_t i = 0; i != minSize; ++i) {
+    if (lhs[i] < rhs[i])
+      return true;
+    else if (lhs[i] > rhs[i])
+      return false;
+  }
+  return lhs.size() < rhs.size();
+}
+
+/** @brief Compare two UVectors for smaller than or equal.
+ * @details If two UVectors compare equal up to the length of one, the UVector
+ * with the smallest size is consider to be smaller.
+ */
+template <class Tp, class Alloc>
+inline bool operator<=(const UVector<Tp, Alloc>& lhs,
+                       const UVector<Tp, Alloc>& rhs) noexcept {
+  const size_t minSize = std::min(lhs.size(), rhs.size());
+  for (size_t i = 0; i != minSize; ++i) {
+    if (lhs[i] < rhs[i])
+      return true;
+    else if (lhs[i] > rhs[i])
+      return false;
+  }
+  return lhs.size() <= rhs.size();
+}
+
+/** @brief Compare two UVectors for larger than.
+ * @details If two UVectors compare equal up to the length of one, the UVector
+ * with the smallest size is consider to be smaller.
+ */
+template <class Tp, class Alloc>
+inline bool operator>(const UVector<Tp, Alloc>& lhs,
+                      const UVector<Tp, Alloc>& rhs) noexcept {
+  return rhs < lhs;
+}
+
+/** @brief Compare two UVectors for larger than or equal.
+ * @details If two UVectors compare equal up to the length of one, the UVector
+ * with the smallest size is consider to be smaller.
+ */
+template <class Tp, class Alloc>
+inline bool operator>=(const UVector<Tp, Alloc>& lhs,
+                       const UVector<Tp, Alloc>& rhs) noexcept {
+  return rhs <= lhs;
+}
+
+/** @brief Swap the contents of the two UVectors.
+ * @details Iterators to both vectors will remain valid and will point into
+ * to the swapped container afterwards. This function will never reallocate
+ * space.
+ *
+ * The allocator will be swapped when the @c propagate_on_container_swap
+ * of the respective @c allocator_trait is @c true_type.
+ * Its behaviour is undefined when the allocators do not compare equal and
+ * @c propagate_on_container_swap is false.
+ */
+template <class Tp, class Alloc>
+inline void swap(UVector<Tp, Alloc>& x, UVector<Tp, Alloc>& y) {
+  x.swap(y);
+}
+
+/** @} */
+
+}  // namespace aocommon
+
+#endif  // AO_UVECTOR_11_H
diff --git a/external/aocommon/include/aocommon/windowfunction.h b/external/aocommon/include/aocommon/windowfunction.h
new file mode 100644
index 0000000..4de8c71
--- /dev/null
+++ b/external/aocommon/include/aocommon/windowfunction.h
@@ -0,0 +1,98 @@
+#ifndef AOCOMMON_WINDOW_FUNCTION_H_
+#define AOCOMMON_WINDOW_FUNCTION_H_
+
+#include <cmath>
+#include <stdexcept>
+#include <string>
+
+namespace aocommon {
+/**
+ * @brief Collection of common signal windowing functions.
+ *
+ */
+class WindowFunction {
+ public:
+  enum Type {
+    Rectangular,
+    BlackmanNutall,
+    BlackmanHarris,
+    Hann,
+    RaisedHann,
+    Tukey,
+    Gaussian
+  };
+
+  static Type GetType(const std::string& typeStr) {
+    if (typeStr == "hann") return Hann;
+    if (typeStr == "raised-hann")
+      return RaisedHann;
+    else if (typeStr == "blackman-nutall")
+      return BlackmanNutall;
+    else if (typeStr == "gaussian")
+      return Gaussian;
+    else if (typeStr == "blackman-harris")
+      return BlackmanHarris;
+    else if (typeStr == "rectangular")
+      return Rectangular;
+    else if (typeStr == "tukey")
+      return Tukey;
+    else
+      throw std::runtime_error(
+          "The window function name is not a valid. Valid windows are: "
+          "rectangular, hann, blackman-harris or blackman-nutall");
+  }
+
+  static double Evaluate(Type windowFunc, size_t n, size_t i) {
+    switch (windowFunc) {
+      case Rectangular:
+        return 1.0;
+      case BlackmanNutall:
+        return EvaluateBlackmanNutall(n, i);
+      case BlackmanHarris:
+        return EvaluateBlackmanHarris(n, i);
+      case Tukey:
+        throw std::runtime_error("Tukey window requires parameter");
+      case Hann:
+        return EvaluateHann(n, i);
+      case RaisedHann:
+        return EvaluateRaisedHann(n, i);
+      case Gaussian:
+        return EvaluateGaussian(n, i);
+    }
+    return 0.0;
+  }
+
+  static double EvaluateBlackmanNutall(size_t n, size_t i) {
+    const static double a0 = 0.3635819, a1 = 0.4891775, a2 = 0.1365995,
+                        a3 = 0.0106411;
+    const double id = double(i) * 2.0 * M_PI, nd = int(n);
+    return a0 - a1 * std::cos((id) / nd) + a2 * std::cos((2.0 * id) / nd) -
+           a3 * std::cos((3.0 * id) / nd);
+  }
+
+  static double EvaluateBlackmanHarris(size_t n, size_t i) {
+    const static double a0 = 0.35875, a1 = 0.48829, a2 = 0.14128, a3 = 0.01168;
+    const double id = double(i) * 2.0 * M_PI, nd = int(n);
+    return a0 - a1 * std::cos((id) / nd) + a2 * std::cos((2.0 * id) / nd) -
+           a3 * std::cos((3.0 * id) / nd);
+  }
+
+  static double EvaluateHann(size_t n, size_t i) {
+    double s = std::sin(M_PI * double(i) / (double(n)));
+    return s * s;
+  }
+
+  static double EvaluateRaisedHann(size_t n, size_t i) {
+    double s = std::sin(M_PI * double(i) / (double(n)));
+    return s * s * 0.99 + 1e-2;
+  }
+
+  static double EvaluateGaussian(size_t n, size_t i) {
+    /// e^(-x^2 / 2sigma^2), sigma = 1/5.
+    constexpr double oneOverSigma = 5.0;
+    double x = (double(i) / double(n) - 0.5) * oneOverSigma;
+    return std::exp(-x * x * 0.5);
+  }
+};
+}  // namespace aocommon
+#endif  // AO_WINDOW_FUNCTION_H
diff --git a/external/aocommon/scripts/format.sh b/external/aocommon/scripts/format.sh
new file mode 100644
index 0000000..06e8592
--- /dev/null
+++ b/external/aocommon/scripts/format.sh
@@ -0,0 +1,78 @@
+# Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# format.sh: Formats source code in a repository in accordance with
+# .clang-format and .cmake-format.py files.
+#
+# This script uses the following variables:
+# - SOURCE_DIR: The directory that contains the source files.
+# - EXCLUDE_DIRS: (Optional) directories that must be excluded from formatting.
+#                 These paths are relative to SOURCE_DIR.
+# - CXX_SOURCES: Patterns of the C++ files, which clang-format should format.
+# - CMAKE_SOURCES: Patterns of the CMake files, which cmake-format should format.
+#
+# A repository that uses format.sh should define its own run-format.sh script
+# that defines these variables and then sources this script.
+# If you want to automatically check formatting in each commit, include the line
+# "./scripts/run-format.sh" to .git/hooks/pre-commit
+# and make sure pre-commit is an executable shell script.
+
+# Disable globbing
+set -e -f
+
+# Check arguments
+if [ -z "$SOURCE_DIR" -o -z "$CXX_SOURCES" -o -z "$CMAKE_SOURCES" ]; then
+  echo "Please define SOURCE_DIR, CXX_SOURCES and CMAKE_SOURCES when using $BASH_SOURCE"
+  exit 1
+fi
+
+# Detect run environment.
+if [ -n "$CI" ]; then
+  DRYRUN=" (dry run on CI)"
+elif [ -n "$GIT_AUTHOR_DATE" ]; then
+  DRYRUN=" (dry run in git hook)"
+fi
+
+# print in bold-face
+echo -e "\e[1mRunning formatters$DRYRUN...\e[0m"
+
+# Convert SOURCES into "-name ext1 -o -name ext2 -o name ext3 ..."
+CXX_FIND_NAMES="-name ${CXX_SOURCES[0]}"
+for i in `seq 1 $((${#CXX_SOURCES[*]} - 1))`; do
+  CXX_FIND_NAMES+=" -o -name ${CXX_SOURCES[$i]}"
+done
+
+CMAKE_FIND_NAMES="-name ${CMAKE_SOURCES[0]}"
+for i in `seq 1 $((${#CMAKE_SOURCES[*]} - 1))`; do
+  CMAKE_FIND_NAMES+=" -o -name ${CMAKE_SOURCES[$i]}"
+done
+
+# Convert EXCLUDE_DIRS into "-path ./dir1 -prune -o -path ./dir2 -prune -o ..."
+FIND_EXCLUDES=
+for e in ${EXCLUDE_DIRS[*]}; do
+  FIND_EXCLUDES+="-path ./$e -prune -o "
+done
+
+cd $SOURCE_DIR
+CXX_FILES=$(find . $FIND_EXCLUDES -type f \( $CXX_FIND_NAMES \) -print)
+CMAKE_FILES=$(find . $FIND_EXCLUDES -type f \( $CMAKE_FIND_NAMES \) -print)
+
+if [ -n "$DRYRUN" ]; then
+  # If the clang-format xml has no replacement entries, all files are formatted.
+  if !(clang-format-12 -style=file --output-replacements-xml $CXX_FILES |
+       grep -q "<replacement ") && cmake-format --check $CMAKE_FILES; then
+    # print in bold-face green
+    echo -e "\e[1m\e[32mGreat job, all files are properly formatted!\e[0m"
+    exit 0;
+  else
+    # Print in bold-face red
+    echo -e "\e[1m\e[31mAt least one file is not properly formatted!\e[0m"
+    echo -e "\e[1m\e[31mRun $0 for formatting all files!\e[0m"
+    exit 1;
+  fi
+else
+  clang-format-12 -i -style=file $CXX_FILES
+  cmake-format -i $CMAKE_FILES
+  # print in bold-face
+  echo -e "\e[1mSuccessfully formatted all files.\e[0m"
+fi
diff --git a/external/aocommon/scripts/run-format.sh b/external/aocommon/scripts/run-format.sh
new file mode 100755
index 0000000..29341cb
--- /dev/null
+++ b/external/aocommon/scripts/run-format.sh
@@ -0,0 +1,24 @@
+#!/bin/bash
+
+# Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+#Script configuration for this repo. Adjust it when copying to a different repo.
+
+#The directory that contains the source files.
+SOURCE_DIR=$(dirname "$0")/..
+
+#Directories that must be excluded from formatting. These paths are
+#relative to SOURCE_DIR.
+EXCLUDE_DIRS=(external build CMake)
+
+#The patterns of the C++ source files, which clang-format should format.
+CXX_SOURCES=(*.cpp *.h)
+
+#The patterns of the CMake source files, which cmake-format should format.
+CMAKE_SOURCES=(CMakeLists.txt *.cmake)
+
+#End script configuration.
+
+#The common formatting script has further documentation.
+source $(dirname "$0")/format.sh
diff --git a/external/aocommon/tests/runtests.cpp b/external/aocommon/tests/runtests.cpp
new file mode 100644
index 0000000..68c49b9
--- /dev/null
+++ b/external/aocommon/tests/runtests.cpp
@@ -0,0 +1,4 @@
+#define BOOST_TEST_MODULE aocommon
+#define BOOST_TEST_DYN_LINK
+
+#include <boost/test/unit_test.hpp>
diff --git a/external/aocommon/tests/tangle.cpp b/external/aocommon/tests/tangle.cpp
new file mode 100644
index 0000000..0056d8d
--- /dev/null
+++ b/external/aocommon/tests/tangle.cpp
@@ -0,0 +1,26 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/units/angle.h>
+
+#include <cmath>
+
+using aocommon::units::Angle;
+
+BOOST_AUTO_TEST_SUITE(angle)
+
+BOOST_AUTO_TEST_CASE(parse_values) {
+  BOOST_CHECK_EQUAL(Angle::Parse("0", ""), 0.0);
+  BOOST_CHECK_CLOSE_FRACTION(Angle::Parse("90", "", Angle::kDegrees), M_PI_2,
+                             1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(Angle::Parse("2700ArCmIn", ""), M_PI_4, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(Angle::Parse("5400", "", Angle::kArcminutes),
+                             M_PI_2, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(Angle::Parse("1296000ASEC", ""), 2.0 * M_PI, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(Angle::Parse("1296000mas", ""),
+                             2.0 * M_PI / 1000.0, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(Angle::Parse("90 deg", ""), M_PI_2, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(Angle::Parse("-180 deg", ""), -M_PI, 1e-7);
+  BOOST_CHECK_THROW(Angle::Parse("10 aocommon", ""), std::runtime_error);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tbanddata.cpp b/external/aocommon/tests/tbanddata.cpp
new file mode 100644
index 0000000..4280e74
--- /dev/null
+++ b/external/aocommon/tests/tbanddata.cpp
@@ -0,0 +1,83 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/banddata.h>
+
+using aocommon::BandData;
+using aocommon::ChannelInfo;
+
+BOOST_AUTO_TEST_SUITE(banddata)
+
+BOOST_AUTO_TEST_CASE(construction) {
+  BandData bandData1;
+  BOOST_CHECK_EQUAL(bandData1.ChannelCount(), 0);
+
+  // Check that these methods don't crash:
+  bandData1.CentreFrequency();
+  bandData1.CentreWavelength();
+  bandData1.FrequencyStep();
+  bandData1.ReferenceFrequency();
+  bandData1.HighestFrequency();
+  bandData1.LongestWavelength();
+  bandData1.LowestFrequency();
+  bandData1.SmallestWavelength();
+
+  std::vector<ChannelInfo> channels{ChannelInfo(150e6, 10e6),
+                                    ChannelInfo(160e6, 10e6),
+                                    ChannelInfo(170e6, 10e6)};
+  BandData bandData2(channels, 160e6);
+  BOOST_CHECK_EQUAL(bandData2.ChannelCount(), 3);
+  BOOST_CHECK_CLOSE_FRACTION(bandData2.ChannelFrequency(0), 150e6, 1e-5);
+  BOOST_CHECK_CLOSE_FRACTION(bandData2.ChannelFrequency(1), 160e6, 1e-5);
+  BOOST_CHECK_CLOSE_FRACTION(bandData2.ChannelFrequency(2), 170e6, 1e-5);
+  BOOST_CHECK_CLOSE_FRACTION(bandData2.FrequencyStep(), 10e6, 1e-5);
+  bandData2 = bandData1;
+  BOOST_CHECK_EQUAL(bandData2.ChannelCount(), 0);
+  bandData2 = BandData(channels, 160e6);
+  BOOST_CHECK_EQUAL(bandData2.ChannelCount(), 3);
+  BandData bandData3(std::move(bandData2));
+  BOOST_CHECK_EQUAL(bandData3.ChannelCount(), 3);
+  BandData bandData4(bandData3);
+  BOOST_CHECK_EQUAL(bandData4.ChannelCount(), 3);
+  BOOST_CHECK_CLOSE_FRACTION(bandData4.ChannelFrequency(0), 150e6, 1e-5);
+  BOOST_CHECK_CLOSE_FRACTION(bandData4.ChannelFrequency(1), 160e6, 1e-5);
+  BOOST_CHECK_CLOSE_FRACTION(bandData4.ChannelFrequency(2), 170e6, 1e-5);
+  BOOST_CHECK_EQUAL(bandData4.ReferenceFrequency(), 160e6);
+  std::vector<double> newFreqs = {120e6, 130e6};
+  bandData4.Set(2, newFreqs.data());
+  BOOST_CHECK_EQUAL(bandData4.ChannelFrequency(0), 120e6);
+  BOOST_CHECK_EQUAL(bandData4.ChannelFrequency(1), 130e6);
+}
+
+BOOST_AUTO_TEST_CASE(copy_assignment) {
+  std::vector<ChannelInfo> channelsA{ChannelInfo(150e6, 5e6),
+                                     ChannelInfo(160e6, 5e6),
+                                     ChannelInfo(170e6, 5e6)};
+  std::vector<ChannelInfo> channelsB{
+      ChannelInfo(110e6, 10e6), ChannelInfo(120e6, 10e6),
+      ChannelInfo(130e6, 10e6), ChannelInfo(140e6, 10e6)};
+  BandData a(channelsA, 160e6), b(channelsB, 140e6);
+  a = b;
+  BOOST_CHECK_EQUAL(a.ChannelCount(), 4);
+  BOOST_CHECK_EQUAL(a.Channel(0).Frequency(), 110e6);
+  BOOST_CHECK_EQUAL(a.Channel(1).Frequency(), 120e6);
+  BOOST_CHECK_EQUAL(a.Channel(2).Frequency(), 130e6);
+  BOOST_CHECK_EQUAL(a.Channel(3).Frequency(), 140e6);
+  BOOST_CHECK_EQUAL(a.Channel(0).Width(), 10e6);
+  BOOST_CHECK_EQUAL(a.Channel(1).Width(), 10e6);
+  BOOST_CHECK_EQUAL(a.Channel(2).Width(), 10e6);
+  BOOST_CHECK_EQUAL(a.Channel(3).Width(), 10e6);
+}
+
+BOOST_AUTO_TEST_CASE(extrema_and_reference) {
+  std::vector<ChannelInfo> channelsA{ChannelInfo(170e6, 5e6),
+                                     ChannelInfo(160e6, 5e6),
+                                     ChannelInfo(150e6, 5e6)};
+  BandData a(channelsA, 160e6);
+  BOOST_CHECK_EQUAL(a.HighestFrequency(), 170e6);
+  BOOST_CHECK_EQUAL(a.LowestFrequency(), 150e6);
+  BOOST_CHECK_EQUAL(a.ReferenceFrequency(), 160e6);
+  BOOST_CHECK_CLOSE(a.SmallestWavelength(), aocommon::c() / 170e6, 1e-8);
+  BOOST_CHECK_CLOSE(a.LongestWavelength(), aocommon::c() / 150e6, 1e-8);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tfits.cpp b/external/aocommon/tests/tfits.cpp
new file mode 100644
index 0000000..4a65538
--- /dev/null
+++ b/external/aocommon/tests/tfits.cpp
@@ -0,0 +1,78 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/fits/fitsreader.h>
+#include <aocommon/fits/fitswriter.h>
+
+BOOST_AUTO_TEST_SUITE(fits)
+
+BOOST_AUTO_TEST_CASE(write_and_read) {
+  const size_t width = 32;
+  const size_t height = 16;
+  const double dl = 0.0125;
+  const double dm = 0.025;
+  const size_t val = 42;
+
+  aocommon::UVector<double> image(width * height, val);
+
+  // Write an image
+  aocommon::FitsWriter writer;
+  writer.SetImageDimensions(width, height, dl, dm);
+  writer.AddHistory("aocommon test write");
+  writer.Write("test-image.fits", image.data());
+
+  // Read the image
+  aocommon::FitsReader reader("test-image.fits");
+  aocommon::UVector<double> imageFromDisk(width * height);
+  reader.Read(imageFromDisk.data());
+
+  BOOST_CHECK_EQUAL(reader.ImageWidth(), width);
+  BOOST_CHECK_EQUAL(reader.ImageHeight(), height);
+  BOOST_CHECK_CLOSE(reader.PixelSizeX(), dl, 1e-8);
+  BOOST_CHECK_CLOSE(reader.PixelSizeY(), dm, 1e-8);
+  BOOST_CHECK_EQUAL(image[0], val);
+  BOOST_CHECK_EQUAL_COLLECTIONS(image.begin(), image.end(),
+                                imageFromDisk.begin(), imageFromDisk.end());
+
+  BOOST_CHECK_EQUAL(reader.History().size(), 1);
+  BOOST_CHECK_EQUAL(reader.History()[0], "aocommon test write");
+
+  std::string s = "unset";
+  BOOST_CHECK(!reader.ReadStringKeyIfExists("nonexist", s));
+  BOOST_CHECK_EQUAL(s, "unset");
+  double d;
+  BOOST_CHECK(!reader.ReadDoubleKeyIfExists("nonexist", d));
+}
+
+BOOST_AUTO_TEST_CASE(fitsbase) {
+  class FitsTester : public aocommon::FitsBase {
+   public:
+    void CheckStatus(int status, const std::string& filename) {
+      checkStatus(status, filename);
+    }
+    void CheckStatus(int status, const std::string& filename,
+                     const std::string& operation) {
+      checkStatus(status, filename, operation);
+    }
+  } tester;
+  // Should not throw:
+  tester.CheckStatus(0, "some_file.fits");
+  tester.CheckStatus(0, "some_file.fits", "operation");
+  // Exception should contain file and operation:
+  try {
+    tester.CheckStatus(WRITE_ERROR, "some_file.fits");
+    BOOST_FAIL("Exception should be thrown");
+  } catch (std::runtime_error& e) {
+    std::string str = e.what();
+    BOOST_CHECK_NE(str.find("some_file.fits"), std::string::npos);
+  }
+  try {
+    tester.CheckStatus(FILE_NOT_OPENED, "some_file.fits", "operation");
+    BOOST_FAIL("Exception should be thrown");
+  } catch (std::runtime_error& e) {
+    std::string str = e.what();
+    BOOST_CHECK_NE(str.find("some_file.fits"), std::string::npos);
+    BOOST_CHECK_NE(str.find("operation"), std::string::npos);
+  }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tfluxdensity.cpp b/external/aocommon/tests/tfluxdensity.cpp
new file mode 100644
index 0000000..a61f19b
--- /dev/null
+++ b/external/aocommon/tests/tfluxdensity.cpp
@@ -0,0 +1,24 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/units/fluxdensity.h>
+
+using aocommon::units::FluxDensity;
+
+BOOST_AUTO_TEST_SUITE(flux_density)
+
+BOOST_AUTO_TEST_CASE(adding_values) {
+  BOOST_CHECK_EQUAL(FluxDensity::Parse("0Jy", ""), 0.0);
+  BOOST_CHECK_CLOSE_FRACTION(FluxDensity::Parse("1Jy", ""), 1.0, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(FluxDensity::Parse("1KJy", ""), 1e3, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(FluxDensity::Parse("1mJy", ""), 1e-3, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(FluxDensity::Parse("1µJy", ""), 1e-6, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(FluxDensity::Parse("1nJy", ""), 1e-9, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(FluxDensity::Parse("3.5", ""), 3.5, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(FluxDensity::Parse("0.025 KJy", ""), 25.0, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(
+      FluxDensity::Parse("-0.025", "", FluxDensity::kKiloJansky), -25.0, 1e-7);
+  BOOST_CHECK_CLOSE_FRACTION(FluxDensity::Parse("-2.5e-2KJy", ""), -25.0, 1e-7);
+  BOOST_CHECK_THROW(FluxDensity::Parse("1aocommon", ""), std::runtime_error);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/thmatrix4x4.cpp b/external/aocommon/tests/thmatrix4x4.cpp
new file mode 100644
index 0000000..739ad47
--- /dev/null
+++ b/external/aocommon/tests/thmatrix4x4.cpp
@@ -0,0 +1,194 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/hmatrix4x4.h>
+#include <aocommon/matrix2x2.h>
+#include <aocommon/matrix4x4.h>
+
+using aocommon::HMC4x4;
+using aocommon::MC2x2;
+using aocommon::MC4x4;
+using aocommon::Vector4;
+
+#define CHECK_CLOSE_MESSAGE(VAL, REF, MSG)         \
+  BOOST_CHECK_MESSAGE(std::fabs(VAL - REF) < 1e-6, \
+                      MSG << " is " << VAL << ", should be " << REF);
+
+BOOST_AUTO_TEST_SUITE(hmatrix4x4)
+
+template <typename Matrix>
+static void CheckMatrix(const Matrix& result, const Matrix& groundtruth) {
+  for (size_t i = 0; i != 16; ++i) {
+    BOOST_CHECK_CLOSE(result[i].real(), groundtruth[i].real(), 1e-6);
+    BOOST_CHECK_CLOSE(result[i].imag(), groundtruth[i].imag(), 1e-6);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(zero) {
+  HMC4x4 zero = HMC4x4::Zero();
+  HMC4x4 ref{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+             0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
+  CheckMatrix(zero, ref);
+  CheckMatrix(zero.ToMatrix(), MC4x4::Zero());
+}
+
+BOOST_AUTO_TEST_CASE(unit) {
+  HMC4x4 unit = HMC4x4::Unit();
+  HMC4x4 ref{1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
+             0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0};
+  CheckMatrix(unit, ref);
+  CheckMatrix(unit.ToMatrix(), MC4x4::Unit());
+}
+
+BOOST_AUTO_TEST_CASE(buffer) {
+  HMC4x4 ref = HMC4x4::Unit();
+  std::array<double, 16> buffer;
+  for (size_t i = 0; i != buffer.size(); ++i) {
+    buffer[i] = ref.Data(i);
+  }
+  HMC4x4 unit(buffer.data());
+  CheckMatrix(unit, ref);
+  CheckMatrix(unit.ToMatrix(), MC4x4::Unit());
+}
+
+BOOST_AUTO_TEST_CASE(inversion) {
+  HMC4x4 m1(HMC4x4::Unit());
+  BOOST_CHECK(m1.Invert());
+  CheckMatrix(m1, HMC4x4::Unit());
+
+  HMC4x4 m2(HMC4x4::Unit() * 2);
+  BOOST_CHECK(m2.Invert());
+  CheckMatrix(m2, HMC4x4::Unit() * 0.5);
+  BOOST_CHECK(m2.Invert());
+  CheckMatrix(m2, HMC4x4::Unit() * 2.0);
+
+  HMC4x4 m3;
+  BOOST_CHECK(!m3.Invert());
+}
+
+BOOST_AUTO_TEST_CASE(from_data) {
+  // Identity matrix
+  HMC4x4 m = HMC4x4::FromData({1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
+                               0.0, 0.0, 0.0, 0.0, 0.0, 1.0});
+  CheckMatrix(m, HMC4x4::Unit());
+
+  auto invalid_size = {1.0, 0.0};
+  BOOST_CHECK_THROW(HMC4x4::FromData(invalid_size), std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(indexing1) {
+  HMC4x4 m{1.0, 2.0, 4.0, 7.0, 2.0, 3.0, 5.0, 8.0,
+           4.0, 5.0, 6.0, 9.0, 7.0, 8.0, 9.0, 10.0};
+  const double vals[16] = {1.0, 2.0, 4.0, 7.0, 2.0, 3.0, 5.0, 8.0,
+                           4.0, 5.0, 6.0, 9.0, 7.0, 8.0, 9.0, 10.0};
+  for (size_t i = 0; i != 16; ++i) {
+    BOOST_CHECK_CLOSE(m[i].real(), vals[i], 1e-6);
+    BOOST_CHECK_CLOSE(m[i].imag(), 0.0, 1e-6);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(indexing2) {
+  std::complex<double> j(0.0, 1.0);
+  HMC4x4 m{1.0, 2.0 - j, 4.0, 7.0, 2.0 + j, 3.0,     5.0, 8.0 + j,
+           4.0, 5.0,     6.0, 9.0, 7.0,     8.0 - j, 9.0, 10.0};
+  const std::complex<double> vals[16] = {1.0, 2.0 - j, 4.0, 7.0, 2.0 + j, 3.0,
+                                         5.0, 8.0 + j, 4.0, 5.0, 6.0,     9.0,
+                                         7.0, 8.0 - j, 9.0, 10.0};
+  for (size_t i = 0; i != 16; ++i) {
+    CHECK_CLOSE_MESSAGE(m[i].real(), vals[i].real(), "Real element " << i);
+    CHECK_CLOSE_MESSAGE(m[i].imag(), vals[i].imag(), "Imag element " << i);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(scalar_product) {
+  HMC4x4 ref = HMC4x4{2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0,
+                      0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0};
+  // scalar multiplication
+  CheckMatrix(HMC4x4::Unit() * 2.0, ref);
+  // scalar multiplication-assignment
+  HMC4x4 m = HMC4x4::Unit();
+  m *= 2.0;
+  CheckMatrix(m, ref);
+}
+
+BOOST_AUTO_TEST_CASE(scalar_division) {
+  HMC4x4 m = HMC4x4{2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0,
+                    0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0};
+  // scalar division-assignment
+  m /= 2.0;
+  CheckMatrix(m, HMC4x4::Unit());
+}
+
+BOOST_AUTO_TEST_CASE(product_with_vector4) {
+  Vector4 v1(2.0, 2.0, 2.0, 2.0);
+  Vector4 res = HMC4x4::Unit() * v1;
+  for (size_t i = 0; i != 4; ++i) {
+    BOOST_CHECK_CLOSE(res[i].real(), 2.0, 1e-6);
+    BOOST_CHECK_CLOSE(res[i].imag(), 0.0, 1e-6);
+  }
+  Vector4 v2(std::complex<double>(2.0, 3.0), std::complex<double>(4.0, 5.0),
+             std::complex<double>(5.0, 6.0), std::complex<double>(7.0, 8.0));
+  res = HMC4x4::Unit() * 0.5 * v2;
+  Vector4 ref = MC4x4::Unit() * 0.5 * v2;
+  for (size_t i = 0; i != 4; ++i) {
+    BOOST_CHECK_CLOSE(res[i].real(), ref[i].real(), 1e-6);
+    BOOST_CHECK_CLOSE(res[i].imag(), ref[i].imag(), 1e-6);
+  }
+  std::complex<double> j(0.0, 1.0);
+  MC4x4 m{1.0,           2.0 + 1.0 * j, 3.0 + 2.0 * j, 4.0 + 3.0 * j,
+          2.0 - 1.0 * j, 2.0,           3.0 + 2.0 * j, 4.0 + 2.0 * j,
+          3.0 - 2.0 * j, 3.0 - 2.0 * j, 3.0,           4.0 - 3.0 * j,
+          4.0 - 3.0 * j, 4.0 - 2.0 * j, 4.0 + 3.0 * j, 4.0};
+
+  res = HMC4x4(m) * v2;
+  ref = m * v2;
+  for (size_t i = 0; i != 4; ++i) {
+    CHECK_CLOSE_MESSAGE(res[i].real(), ref[i].real(), "Element " << i);
+    CHECK_CLOSE_MESSAGE(res[i].imag(), ref[i].imag(), "Element " << i);
+  }
+}
+
+static void checkKroneckerProduct(const MC2x2& a, const MC2x2& x,
+                                  const MC2x2& b) {
+  Vector4 ref = a.Multiply(x).MultiplyHerm(b).Vec();
+  HMC4x4 product = HMC4x4::KroneckerProduct(b.HermTranspose().Transpose(), a);
+  Vector4 v = product * x.Vec();
+  for (size_t i = 0; i != 4; ++i) {
+    BOOST_CHECK_CLOSE(v[i].real(), ref[i].real(), 1e-6);
+    BOOST_CHECK_CLOSE(v[i].imag(), ref[i].imag(), 1e-6);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(kronecker_product_a) {
+  checkKroneckerProduct(MC2x2::Unity(), MC2x2::Unity(), MC2x2::Unity());
+}
+
+BOOST_AUTO_TEST_CASE(kronecker_product_b) {
+  MC2x2 a1{1.0, 2.0, 2.0, 4.0}, x1(MC2x2::Unity()), b1{1.0, 2.0, 2.0, 4.0};
+  checkKroneckerProduct(a1, x1, b1);
+}
+
+BOOST_AUTO_TEST_CASE(kronecker_product_c) {
+  MC2x2 a3{0.0, 1.0, 1.0, 3.0}, x3{0.0, 1.0, 2.0, 3.0}, b3{0.0, 1.0, 1.0, 3.0};
+  checkKroneckerProduct(a3, x3, b3);
+}
+
+BOOST_AUTO_TEST_CASE(kronecker_product_d) {
+  std::complex<double> x(8, 2), y(6, 3), xc = std::conj(x), yc = std::conj(y);
+  MC2x2 a4{0.0, 2.0 * y, 2.0 * yc, 3.0}, x4{1.0, 2.0 * xc, 2.0 * x, 4.0},
+      b4{1.0, 3.0 * x, 3.0 * xc, 4.0};
+  checkKroneckerProduct(a4, x4, b4);
+}
+
+BOOST_AUTO_TEST_CASE(norm) {
+  BOOST_CHECK_CLOSE((HMC4x4::Unit() * 2.0).Norm(), (MC4x4::Unit() * 2.0).Norm(),
+                    1e-6);
+  std::complex<double> j(0, 1);
+  HMC4x4 m{
+      1.0,  2.0 + 3.0 * j,   4.0 - 5.0 * j,   6.0 + 7.0 * j,   2.0 - 3.0 * j,
+      8.0,  9.0 + 10.0 * j,  11.0 - 12.0 * j, 4.0 + 5.0 * j,   9.0 - 10.0 * j,
+      13.0, 14.0 + 15.0 * j, 6.0 - 7.0 * j,   11.0 + 12.0 * j, 11.0 + 12.0 * j,
+      16.0};
+  BOOST_CHECK_CLOSE(m.Norm(), m.ToMatrix().Norm(), 1e-6);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/timage.cpp b/external/aocommon/tests/timage.cpp
new file mode 100644
index 0000000..59b4f76
--- /dev/null
+++ b/external/aocommon/tests/timage.cpp
@@ -0,0 +1,356 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/image.h>
+
+#include <aocommon/uvector.h>
+
+#include <random>
+
+using aocommon::DImage;
+using aocommon::Image;
+using aocommon::ImageBase;
+
+BOOST_AUTO_TEST_SUITE(image)
+
+struct ImageFixture {
+  ImageFixture()
+      : image(3, 2, {6.0, 5.0, 4.0, 3.0, 2.0, 1.0}), image_ref(image) {}
+
+  Image image;
+  const Image image_ref;
+};
+
+BOOST_AUTO_TEST_CASE(median_empty) {
+  BOOST_CHECK_EQUAL(Image::Median(nullptr, 0), 0.0f);
+}
+
+BOOST_AUTO_TEST_CASE(median_single) {
+  aocommon::UVector<float> arr(1, 1.0);
+  BOOST_CHECK_EQUAL(Image::Median(arr.data(), arr.size()), 1.0f);
+
+  arr[0] = std::numeric_limits<float>::quiet_NaN();
+  Image::Median(arr.data(),
+                arr.size());  // undefined -- just make sure it doesn't crash
+}
+
+BOOST_AUTO_TEST_CASE(median_two_elements) {
+  {
+    aocommon::UVector<float> arr(2, 1.0);
+    BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 1.0,
+                               1e-5);
+  }
+
+  {
+    aocommon::UVector<float> arr(2, 0.0);
+    arr[1] = 2.0;
+    BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 1.0,
+                               1e-5);
+  }
+
+  {
+    aocommon::UVector<float> arr(2, 1.0);
+    arr[1] = -1.0;
+    BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 0.0,
+                               1e-5);
+  }
+
+  {
+    aocommon::UVector<float> arr(2, 13.0);
+    arr[1] = std::numeric_limits<float>::quiet_NaN();
+    BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 13.0,
+                               1e-5);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(median_three_elements) {
+  aocommon::UVector<float> arr(3, 1.0);
+  BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 1.0, 1e-5);
+
+  arr[0] = 0.0;
+  arr[1] = 1.0;
+  arr[2] = 2.0;
+  BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 1.0, 1e-5);
+
+  arr[0] = 3.0;
+  arr[1] = -3.0;
+  arr[2] = 2.0;
+  BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 2.0, 1e-5);
+
+  arr[1] = std::numeric_limits<float>::quiet_NaN();
+  BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 2.5, 1e-5);
+
+  arr[0] = std::numeric_limits<float>::quiet_NaN();
+  BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 2.0, 1e-5);
+}
+
+BOOST_AUTO_TEST_CASE(median_double) {
+  aocommon::UVector<double> arr = {6.0, -3.0, 2.0};
+  BOOST_CHECK_CLOSE_FRACTION(DImage::Median(arr.data(), arr.size()), 2.0, 1e-5);
+}
+
+BOOST_AUTO_TEST_CASE(median_invalid) {
+  aocommon::UVector<std::complex<float>> arr = {6.0, -3.0, 2.0};
+  BOOST_CHECK_THROW(
+      ImageBase<std::complex<float>>::Median(arr.data(), arr.size()),
+      std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(mad_empty) {
+  BOOST_CHECK_EQUAL(Image::MAD(nullptr, 0), 0.0);
+}
+
+BOOST_AUTO_TEST_CASE(mad_single) {
+  aocommon::UVector<float> arr(1, 1.0);
+  BOOST_CHECK_EQUAL(Image::MAD(arr.data(), arr.size()), 0.0);
+}
+
+BOOST_AUTO_TEST_CASE(mad_two_elements) {
+  aocommon::UVector<float> arr(2, 1.0);
+  BOOST_CHECK_EQUAL(Image::MAD(arr.data(), arr.size()), 0.0);
+
+  arr[0] = 0.0;
+  arr[1] = 2.0;
+  BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 1.0, 1e-5);
+
+  arr[0] = 1.0;
+  arr[1] = -1.0;
+  BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 0.0, 1e-5);
+
+  arr[0] = 13.0;
+  arr[1] = std::numeric_limits<float>::quiet_NaN();
+  BOOST_CHECK_CLOSE_FRACTION(Image::Median(arr.data(), arr.size()), 13.0, 1e-5);
+}
+
+BOOST_AUTO_TEST_CASE(mad_three_elements) {
+  aocommon::UVector<float> arr(3, 1.0);
+  BOOST_CHECK_CLOSE_FRACTION(Image::MAD(arr.data(), arr.size()), 0.0, 1e-5);
+
+  arr[0] = 0.0;
+  arr[1] = 1.0;
+  arr[2] = 2.0;
+  BOOST_CHECK_CLOSE_FRACTION(Image::MAD(arr.data(), arr.size()), 1.0, 1e-5);
+
+  arr[0] = 3.0;
+  arr[1] = -3.0;
+  arr[2] = 2.0;
+  BOOST_CHECK_CLOSE_FRACTION(Image::MAD(arr.data(), arr.size()), 1.0, 1e-5);
+
+  arr[1] = std::numeric_limits<float>::quiet_NaN();
+  BOOST_CHECK_CLOSE_FRACTION(Image::MAD(arr.data(), arr.size()), 0.5, 1e-5);
+
+  arr[0] = std::numeric_limits<float>::quiet_NaN();
+  BOOST_CHECK_CLOSE_FRACTION(Image::MAD(arr.data(), arr.size()), 0.0, 1e-5);
+}
+
+BOOST_AUTO_TEST_CASE(stddev_from_mad) {
+  std::mt19937 rnd;
+  std::normal_distribution<float> dist(1.0f, 5.0f);
+  aocommon::UVector<float> data(10000);
+  for (size_t i = 0; i != data.size(); ++i) data[i] = dist(rnd);
+  BOOST_CHECK_CLOSE_FRACTION(Image::StdDevFromMAD(data.data(), data.size()),
+                             5.0f, 0.05);
+}
+
+BOOST_AUTO_TEST_CASE(constructors) {
+  const size_t width = 10;
+  const size_t height = 20;
+  {
+    Image image(width, height);
+    BOOST_CHECK_EQUAL(image.Width(), width);
+    BOOST_CHECK_EQUAL(image.Height(), height);
+    BOOST_CHECK_EQUAL(image.Size(), width * height);
+  }
+
+  {
+    Image image(width, height, 42.0);
+    aocommon::UVector<float> ref(width * height, 42.0);
+    BOOST_CHECK_EQUAL_COLLECTIONS(image.begin(), image.end(), ref.begin(),
+                                  ref.end());
+
+    // Copy constructor
+    Image image1(image);
+    BOOST_CHECK_EQUAL_COLLECTIONS(image1.begin(), image1.end(), image.begin(),
+                                  image.end());
+
+    // Move constructor
+    Image image2(std::move(image1));
+    BOOST_CHECK_EQUAL_COLLECTIONS(image2.begin(), image2.end(), image.begin(),
+                                  image.end());
+    BOOST_CHECK(image1.Empty());
+    BOOST_CHECK(image1.Data() == nullptr);
+
+    // reset
+    image2.Reset();
+    BOOST_CHECK(image2.Empty());
+    BOOST_CHECK(image2.Data() == nullptr);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(initializer_list_constructor) {
+  Image image(2, 4, {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f});
+  BOOST_REQUIRE_EQUAL(image.Width(), 2);
+  BOOST_REQUIRE_EQUAL(image.Height(), 4);
+  for (size_t i = 0; i != 8; ++i) {
+    BOOST_CHECK_CLOSE(image[i], i + 1.0f, 1e-6f);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(indexing_operator, ImageFixture) {
+  const aocommon::UVector<float> arr = {6.0, 5.0, 4.0, 3.0, 2.0, 1.0};
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_EQUAL(image[i], arr[i]);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(add_assign, ImageFixture) {
+  image += image;
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], image_ref[i] + image_ref[i], 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(multiply_assign, ImageFixture) {
+  image *= image;
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], image_ref[i] * image_ref[i], 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(subtract_assign, ImageFixture) {
+  image -= image;
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], 0.0f, 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(divide_assign, ImageFixture) {
+  const float factor = 2.0;
+  image /= factor;
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], image_ref[i] / factor, 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(multiply_assign_factor, ImageFixture) {
+  const float factor = 2.0;
+  image *= factor;
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], factor * image_ref[i], 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(sqrt, ImageFixture) {
+  image.Sqrt();
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], std::sqrt(image_ref[i]), 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(square, ImageFixture) {
+  image.Square();
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], image_ref[i] * image_ref[i], 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(add_with_factor, ImageFixture) {
+  image.AddWithFactor(image, 4.0f);
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], 5.0f * image_ref[i], 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(square_with_factor, ImageFixture) {
+  const float factor = 2.0;
+  image.SquareWithFactor(factor);
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], image_ref[i] * image_ref[i] * factor, 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(sqrt_with_factor, ImageFixture) {
+  const float factor = 2.0;
+  image.SqrtWithFactor(factor);
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], std::sqrt(image_ref[i]) * factor, 1e-4);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(negate, ImageFixture) {
+  image.Negate();
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_EQUAL(image[i], -image_ref[i]);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(trim_and_untrim) {
+  const size_t width = 5;
+  const size_t height = 3;
+  aocommon::UVector<float> row_values = {0., 1., 2., 3., 4.};
+  aocommon::UVector<float> image_data;
+  for (size_t i = 0; i != height; ++i) {
+    image_data.insert(image_data.begin() + i * width, row_values.begin(),
+                      row_values.end());
+  }
+
+  Image image(width, height);
+  image.Assign(image_data.begin(), image_data.end());
+
+  const size_t x1 = 1;
+  const size_t y1 = 1;
+  const size_t box_width = 3;
+  const size_t box_height = 1;
+
+  Image trimmed_image = image.TrimBox(x1, y1, box_width, box_height);
+  // Offsets are only correct if box_height == 1
+  BOOST_CHECK_EQUAL_COLLECTIONS(trimmed_image.begin(), trimmed_image.end(),
+                                row_values.begin() + x1,
+                                row_values.begin() + x1 + box_width);
+
+  Image untrimmed_image = trimmed_image.Untrim(width, height);
+  BOOST_CHECK_EQUAL(untrimmed_image.Size(), image.Size());
+  BOOST_CHECK_EQUAL(
+      std::accumulate(untrimmed_image.begin(), untrimmed_image.end(), 0.0f),
+      std::accumulate(trimmed_image.begin(), trimmed_image.end(), 0.0f));
+}
+
+BOOST_AUTO_TEST_CASE(serialization) {
+  const size_t width = 3;
+  const size_t height = 2;
+  aocommon::UVector<float> arr = {6.0, 5.0, 4.0, 3.0, 2.0, 1.0};
+  Image image_in(width, height);
+  image_in.Assign(arr.begin(), arr.end());
+
+  aocommon::SerialOStream ostr;
+  image_in.Serialize(ostr);
+
+  aocommon::SerialIStream istr(std::move(ostr));
+  Image image_out;
+  image_out.Unserialize(istr);
+
+  BOOST_CHECK_EQUAL(image_in.Width(), image_out.Width());
+  BOOST_CHECK_EQUAL(image_in.Height(), image_out.Height());
+  BOOST_CHECK_EQUAL(image_in.Size(), image_out.Size());
+  for (size_t i = 0; i != arr.size(); ++i) {
+    BOOST_CHECK_EQUAL(image_out[i], arr[i]);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(add_sub_image) {
+  Image image(4, 5, {10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f,
+                     17.0f, 18.0f, 19.0f, 20.0f, 21.0f, 22.0f, 23.0f,
+                     24.0f, 25.0f, 26.0f, 27.0f, 28.0f, 29.0f});
+  const Image sub_image(2, 2, {100.0f, 200.0f, 300.0f, 400.0f});
+  image.AddSubImage(image.Data(), 1, 1, image.Width(), sub_image.Data(),
+                    sub_image.Width(), sub_image.Height());
+  const Image reference(4, 5,
+                        {10.0f, 11.0f, 12.0f,  13.0f,  14.0f, 115.0f, 216.0f,
+                         17.0f, 18.0f, 319.0f, 420.0f, 21.0f, 22.0f,  23.0f,
+                         24.0f, 25.0f, 26.0f,  27.0f,  28.0f, 29.0f});
+  BOOST_REQUIRE_EQUAL(image.Size(), reference.Size());
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], reference[i], 1e-6);
+  }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tlane.cpp b/external/aocommon/tests/tlane.cpp
new file mode 100644
index 0000000..d82f84a
--- /dev/null
+++ b/external/aocommon/tests/tlane.cpp
@@ -0,0 +1,271 @@
+#include <iostream>
+
+#include <aocommon/lane.h>
+
+#include <fstream>
+#include <thread>
+#include <vector>
+
+#include <boost/test/unit_test.hpp>
+#include <boost/make_unique.hpp>
+
+using aocommon::Lane;
+
+// These are "first order" tests: none of these tests explicitly test
+// multi-threading / thread-safety features of Lane
+
+BOOST_AUTO_TEST_SUITE(lane)
+
+BOOST_AUTO_TEST_CASE(construct_default) {
+  const Lane<int> l;
+  BOOST_CHECK_EQUAL(l.capacity(), 0);
+  BOOST_CHECK_EQUAL(l.size(), 0);
+  BOOST_CHECK(l.empty());
+}
+
+BOOST_AUTO_TEST_CASE(construct_with_capacity) {
+  const Lane<int> l(7);
+  BOOST_CHECK_EQUAL(l.capacity(), 7);
+  BOOST_CHECK_EQUAL(l.size(), 0);
+  BOOST_CHECK(l.empty());
+}
+
+BOOST_AUTO_TEST_CASE(read_write) {
+  Lane<int> l(4);
+  constexpr size_t n = 2;
+  const int values[n] = {3, 4};
+  l.write(values, n);
+  l.write_end();
+  BOOST_CHECK(!l.empty());
+  BOOST_CHECK_EQUAL(l.size(), n);
+
+  for (size_t i = 0; i != n; ++i) {
+    int result;
+    BOOST_REQUIRE(l.read(result));
+    BOOST_CHECK_EQUAL(result, values[i]);
+  }
+  int result;
+  BOOST_CHECK(l.empty());
+  BOOST_CHECK(!l.read(result));
+}
+
+BOOST_AUTO_TEST_CASE(move_construct) {
+  Lane<int> a(4);
+  constexpr size_t n = 2;
+  const int values[n] = {3, 4};
+  a.write(values, n);
+
+  Lane<int> b(std::move(a));
+  BOOST_CHECK_EQUAL(a.capacity(), 0);
+  BOOST_CHECK(a.empty());
+  BOOST_CHECK_EQUAL(a.size(), 0);
+  BOOST_CHECK_EQUAL(b.capacity(), 4);
+  BOOST_CHECK(!b.empty());
+  BOOST_CHECK_EQUAL(b.size(), n);
+}
+
+BOOST_AUTO_TEST_CASE(move_assign) {
+  Lane<int> a(4);
+  constexpr size_t n = 2;
+  const int values_a[n] = {3, 4};
+  a.write(values_a, n);
+
+  Lane<int> b(3);
+  const int values_b[3] = {5, 6, 7};
+  b.write(values_b, 3);
+  b = std::move(a);
+
+  BOOST_CHECK_EQUAL(b.capacity(), 4);
+  BOOST_CHECK(!b.empty());
+  BOOST_CHECK_EQUAL(b.size(), n);
+  for (size_t i = 0; i != n; ++i) {
+    int result;
+    BOOST_REQUIRE(b.read(result));
+    BOOST_CHECK_EQUAL(result, values_a[i]);
+  }
+  BOOST_CHECK(b.empty());
+}
+
+BOOST_AUTO_TEST_CASE(emplace) {
+  Lane<std::pair<int, int>> l(4);
+  l.emplace(3, 30);
+  l.emplace(4, 40);
+  l.write_end();
+  BOOST_CHECK(!l.empty());
+  BOOST_CHECK_EQUAL(l.size(), 2);
+
+  std::pair<int, int> result;
+  BOOST_REQUIRE(l.read(result));
+  BOOST_CHECK_EQUAL(result.first, 3);
+  BOOST_CHECK_EQUAL(result.second, 30);
+  BOOST_REQUIRE(l.read(result));
+  BOOST_CHECK_EQUAL(result.first, 4);
+  BOOST_CHECK_EQUAL(result.second, 40);
+
+  BOOST_CHECK(!l.read(result));
+  BOOST_CHECK(l.empty());
+}
+
+BOOST_AUTO_TEST_CASE(emplace_noncopyable) {
+  // This test is to make sure that emplace() with multiple parameters and
+  // move-only operands compiles
+  using ValueType = std::pair<std::unique_ptr<int>, std::unique_ptr<int>>;
+  aocommon::Lane<ValueType> l(4);
+  ValueType v(boost::make_unique<int>(5), boost::make_unique<int>(11));
+  l.emplace(std::move(v));
+  BOOST_CHECK(!l.empty());
+
+  ValueType result;
+  BOOST_REQUIRE(l.read(result));
+  BOOST_REQUIRE(result.first);
+  BOOST_REQUIRE(result.second);
+  BOOST_CHECK_EQUAL(*result.first, 5);
+  BOOST_CHECK_EQUAL(*result.second, 11);
+  BOOST_CHECK(l.empty());
+}
+
+BOOST_AUTO_TEST_CASE(noncopyable_read_write) {
+  Lane<std::unique_ptr<int>> l(4);
+  constexpr size_t n = 2;
+  const int values[n] = {3, 4};
+  for (size_t i = 0; i != n; ++i) {
+    l.write(boost::make_unique<int>(values[i]));
+  }
+  l.write_end();
+  BOOST_CHECK(!l.empty());
+  BOOST_CHECK_EQUAL(l.size(), n);
+
+  for (size_t i = 0; i != n; ++i) {
+    std::unique_ptr<int> result;
+    BOOST_REQUIRE(l.read(result));
+    BOOST_REQUIRE(result);
+    BOOST_CHECK_EQUAL(*result, values[i]);
+  }
+  std::unique_ptr<int> result;
+  BOOST_CHECK(!l.read(result));
+  BOOST_CHECK(l.empty());
+  BOOST_CHECK(!result);
+}
+
+BOOST_AUTO_TEST_CASE(move_write) {
+  Lane<std::unique_ptr<int>> l(4);
+  std::vector<std::unique_ptr<int>> values;
+  values.emplace_back();
+  values.emplace_back(boost::make_unique<int>(7));
+  l.move_write(values.data(), values.size());
+  l.write_end();
+  BOOST_CHECK(!l.empty());
+  BOOST_CHECK_EQUAL(l.size(), 2);
+
+  std::unique_ptr<int> result;
+  BOOST_REQUIRE(l.read(result));
+  BOOST_CHECK(!result);
+
+  BOOST_REQUIRE(l.read(result));
+  BOOST_REQUIRE(result);
+  BOOST_CHECK_EQUAL(*result, 7);
+
+  BOOST_CHECK(!l.read(result));
+  BOOST_CHECK(l.empty());
+  BOOST_REQUIRE(result);
+  BOOST_CHECK_EQUAL(*result, 7);
+}
+
+BOOST_AUTO_TEST_CASE(discard) {
+  Lane<int> l(4);
+  constexpr size_t n = 3;
+  const int values[n] = {3, 4, 5};
+  l.write(values, n);
+  l.write_end();
+  l.discard(2);
+  BOOST_CHECK(!l.empty());
+  BOOST_CHECK_EQUAL(l.size(), 1);
+
+  int result;
+  BOOST_REQUIRE(l.read(result));
+  BOOST_CHECK_EQUAL(result, values[2]);
+
+  BOOST_CHECK(!l.read(result));
+  BOOST_CHECK(l.empty());
+}
+
+BOOST_AUTO_TEST_CASE(clear) {
+  constexpr size_t n = 2;
+  const int values_a[n] = {3, 4};
+  Lane<int> l(3);
+  l.write(values_a, n);
+  l.write_end();
+  l.clear();
+  BOOST_CHECK_EQUAL(l.capacity(), 3);
+  BOOST_CHECK(l.empty());
+  BOOST_CHECK_EQUAL(l.size(), 0);
+  const int values_b[n] = {5, 6};
+  l.write(values_b, n);
+  l.write_end();
+  for (size_t i = 0; i != n; ++i) {
+    int result;
+    BOOST_REQUIRE(l.read(result));
+    BOOST_CHECK_EQUAL(result, values_b[i]);
+  }
+  int result;
+  BOOST_CHECK(!l.read(result));
+  BOOST_CHECK(l.empty());
+}
+
+BOOST_AUTO_TEST_CASE(resize) {
+  Lane<int> l(1);
+  l.write(17);
+  l.write_end();
+  l.resize(3);
+  BOOST_CHECK_EQUAL(l.capacity(), 3);
+  BOOST_CHECK(l.empty());
+  BOOST_CHECK_EQUAL(l.size(), 0);
+  constexpr size_t n = 2;
+  const int values[n] = {3, 4};
+  l.write(values, n);
+  l.write_end();
+  for (size_t i = 0; i != n; ++i) {
+    int result;
+    BOOST_REQUIRE(l.read(result));
+    BOOST_CHECK_EQUAL(result, values[i]);
+  }
+  int result;
+  BOOST_CHECK(!l.read(result));
+  BOOST_CHECK(l.empty());
+}
+
+BOOST_AUTO_TEST_CASE(wait_for_empty) {
+  Lane<int> l(1);
+  BOOST_CHECK_NO_THROW(l.wait_for_empty());
+}
+
+BOOST_AUTO_TEST_CASE(multiple_threads) {
+  Lane<int> l(5);
+
+  std::thread t([&l]() {
+    for (size_t i = 100; i != 150; ++i) {
+      int result;
+      BOOST_REQUIRE(l.read(result));
+      BOOST_CHECK_EQUAL(result, i);
+    }
+    l.discard(25);
+    for (size_t i = 175; i != 250; ++i) {
+      int result;
+      BOOST_REQUIRE(l.read(result));
+      BOOST_CHECK_EQUAL(result, i);
+    }
+  });
+
+  for (size_t i = 100; i != 190; ++i) l.write(i);
+  for (size_t i = 190; i != 240; ++i) l.emplace(i);
+  std::vector<int> values;
+  for (size_t i = 240; i != 250; ++i) values.emplace_back(i);
+  l.write(values.data(), values.size());
+  l.wait_for_empty();
+  l.write_end();
+
+  t.join();
+  BOOST_CHECK(l.empty());
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tlogger.cpp b/external/aocommon/tests/tlogger.cpp
new file mode 100644
index 0000000..eeab049
--- /dev/null
+++ b/external/aocommon/tests/tlogger.cpp
@@ -0,0 +1,49 @@
+#ifdef HAVE_LOGGER
+
+#include <aocommon/logger.h>
+
+#include <sstream>
+
+#include <boost/test/unit_test.hpp>
+#include <boost/test/tools/output_test_stream.hpp>
+#include <iostream>
+
+BOOST_AUTO_TEST_SUITE(logger)
+
+BOOST_AUTO_TEST_CASE(verbosity) {
+  BOOST_CHECK_EQUAL(aocommon::Logger::IsVerbose(), false);
+  aocommon::Logger::SetVerbosity(aocommon::Logger::kVerboseVerbosity);
+  BOOST_CHECK_EQUAL(aocommon::Logger::IsVerbose(), true);
+}
+
+BOOST_AUTO_TEST_CASE(logwriter) {
+  std::stringstream output;
+  aocommon::Logger::LogWriter<aocommon::Logger::kInfoLevel> logwriter(output);
+
+  std::string str = "is a";
+  logwriter << "T"
+            << "h"
+            << "i"
+            << "s"
+            << " " << str;
+  BOOST_CHECK_EQUAL(output.str(), "This is a");
+
+  aocommon::Logger::SetVerbosity(aocommon::Logger::kQuietVerbosity);
+  logwriter << " quiet ";
+  BOOST_CHECK_EQUAL(output.str(), "This is a");
+
+  aocommon::Logger::SetVerbosity(aocommon::Logger::kNormalVerbosity);
+
+  logwriter << " test.";
+  BOOST_CHECK_EQUAL(output.str(), "This is a test.");
+
+  const size_t my_size_t = 10;
+  const double my_double = 9.999;
+  logwriter << " Numerical output? " << my_size_t << "/" << my_double << ".";
+  BOOST_CHECK_EQUAL(output.str(),
+                    "This is a test. Numerical output? 10/9.999.");
+}
+
+BOOST_AUTO_TEST_SUITE_END()
+
+#endif
\ No newline at end of file
diff --git a/external/aocommon/tests/tmatrix2x2.cpp b/external/aocommon/tests/tmatrix2x2.cpp
new file mode 100644
index 0000000..386736c
--- /dev/null
+++ b/external/aocommon/tests/tmatrix2x2.cpp
@@ -0,0 +1,473 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/matrix2x2.h>
+#include <aocommon/matrix2x2diag.h>
+
+#include <iostream>
+
+using aocommon::Matrix2x2;
+using aocommon::MC2x2;
+using aocommon::MC2x2F;
+
+BOOST_AUTO_TEST_SUITE(matrix2x2)
+
+BOOST_AUTO_TEST_CASE(from_diagonal) {
+  const aocommon::MC2x2Diag a({1.0, 2.0}, {3.0, 4.0});
+  MC2x2 b(a);
+  BOOST_CHECK_CLOSE(b[0].real(), 1, 1e-6);
+  BOOST_CHECK_CLOSE(b[0].imag(), 2, 1e-6);
+  BOOST_CHECK_CLOSE(b[1].real(), 0, 1e-6);
+  BOOST_CHECK_CLOSE(b[1].imag(), 0, 1e-6);
+  BOOST_CHECK_CLOSE(b[2].real(), 0, 1e-6);
+  BOOST_CHECK_CLOSE(b[2].imag(), 0, 1e-6);
+  BOOST_CHECK_CLOSE(b[3].real(), 3, 1e-6);
+  BOOST_CHECK_CLOSE(b[3].imag(), 4, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(complex_times_real) {
+  MC2x2 a({1.0, 2.0}, {0, 0}, {0, 0}, {3.0, 4.0});
+  // Flattened real 2x2 array
+  double r[4] = {10, 20, 30, 40};
+
+  // Multiply
+  MC2x2 b = a * r;
+  BOOST_CHECK_CLOSE(b[0].real(), 10, 1e-6);
+  BOOST_CHECK_CLOSE(b[0].imag(), 20, 1e-6);
+  BOOST_CHECK_CLOSE(b[1].real(), 20, 1e-6);
+  BOOST_CHECK_CLOSE(b[1].imag(), 40, 1e-6);
+  BOOST_CHECK_CLOSE(b[2].real(), 90, 1e-6);
+  BOOST_CHECK_CLOSE(b[2].imag(), 120, 1e-6);
+  BOOST_CHECK_CLOSE(b[3].real(), 120, 1e-6);
+  BOOST_CHECK_CLOSE(b[3].imag(), 160, 1e-6);
+
+  // Multiply-assign
+  a *= r;
+  BOOST_CHECK_CLOSE(a[0].real(), 10, 1e-6);
+  BOOST_CHECK_CLOSE(a[0].imag(), 20, 1e-6);
+  BOOST_CHECK_CLOSE(a[1].real(), 20, 1e-6);
+  BOOST_CHECK_CLOSE(a[1].imag(), 40, 1e-6);
+  BOOST_CHECK_CLOSE(a[2].real(), 90, 1e-6);
+  BOOST_CHECK_CLOSE(a[2].imag(), 120, 1e-6);
+  BOOST_CHECK_CLOSE(a[3].real(), 120, 1e-6);
+  BOOST_CHECK_CLOSE(a[3].imag(), 160, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(complex_division_with_real) {
+  MC2x2F a({4.0, 2.0}, {0, 40}, {12, 16}, {8.0, 4.0});
+
+  // Divide and assign
+  a /= 4.0f;
+  BOOST_CHECK_CLOSE(a[0].real(), 1, 1e-6);
+  BOOST_CHECK_CLOSE(a[0].imag(), 0.5, 1e-6);
+  BOOST_CHECK_CLOSE(a[1].real(), 0, 1e-6);
+  BOOST_CHECK_CLOSE(a[1].imag(), 10, 1e-6);
+  BOOST_CHECK_CLOSE(a[2].real(), 3, 1e-6);
+  BOOST_CHECK_CLOSE(a[2].imag(), 4, 1e-6);
+  BOOST_CHECK_CLOSE(a[3].real(), 2, 1e-6);
+  BOOST_CHECK_CLOSE(a[3].imag(), 1, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(assign_to) {
+  MC2x2 a({1.0, 2.0}, {0, 0}, {0, 0}, {3.0, 4.0});
+  std::complex<double> r1[4];
+
+  // Assign to complex double buffer
+  a.AssignTo(r1);
+  BOOST_CHECK_CLOSE(r1[0].real(), 1, 1e-6);
+  BOOST_CHECK_CLOSE(r1[0].imag(), 2, 1e-6);
+  BOOST_CHECK_CLOSE(r1[3].real(), 3, 1e-6);
+  BOOST_CHECK_CLOSE(r1[3].imag(), 4, 1e-6);
+
+  // Assign to complex float buffer.
+  std::complex<float> r2[4];
+  a.AssignTo(r2);
+  BOOST_CHECK_CLOSE(r2[0].real(), 1, 1e-6);
+  BOOST_CHECK_CLOSE(r2[0].imag(), 2, 1e-6);
+  BOOST_CHECK_CLOSE(r2[3].real(), 3, 1e-6);
+  BOOST_CHECK_CLOSE(r2[3].imag(), 4, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(eigenvalue1) {
+  double unit[4] = {1.0, 0.0, 0.0, 1.0};
+  double e1, e2;
+  Matrix2x2::EigenValues(unit, e1, e2);
+  BOOST_CHECK_CLOSE(e1, 1.0, 1e-6);
+  BOOST_CHECK_CLOSE(e2, 1.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(eigenvalue2) {
+  double unit[4] = {0.0, 1.0, -2.0, -3.0};
+  double e1, e2;
+  Matrix2x2::EigenValues(unit, e1, e2);
+  if (e1 < e2) std::swap(e1, e2);
+  BOOST_CHECK_CLOSE(e1, -1.0, 1e-6);
+  BOOST_CHECK_CLOSE(e2, -2.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(eigenvalue3) {
+  double unit[4] = {0.0, -2.0, 1.0, -3.0};
+  double e1, e2;
+  Matrix2x2::EigenValues(unit, e1, e2);
+  if (e1 < e2) std::swap(e1, e2);
+  BOOST_CHECK_CLOSE(e1, -1.0, 1e-6);
+  BOOST_CHECK_CLOSE(e2, -2.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(eigenvalue4) {
+  double unit[4] = {0.0, 1.0, -1.0, 0.0};
+  double e1, e2;
+  Matrix2x2::EigenValues(unit, e1, e2);
+  if (e1 < e2) std::swap(e1, e2);
+  BOOST_CHECK(!std::isfinite(e1));
+  BOOST_CHECK(!std::isfinite(e2));
+}
+
+BOOST_AUTO_TEST_CASE(eigenvector2) {
+  double unit[4] = {0.0, 1.0, -2.0, -3.0};
+  double e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(unit, e1, e2, vec1, vec2);
+  if (e1 < e2) {
+    std::swap(e1, e2);
+    std::swap(vec1, vec2);
+  }
+  BOOST_CHECK_CLOSE(e1, -1.0, 1e-6);
+  BOOST_CHECK_CLOSE(vec1[0] / vec1[1], -1.0, 1e-6);  // vec1 = c [-1, 1]
+  BOOST_CHECK_CLOSE(e2, -2.0, 1e-6);
+  BOOST_CHECK_CLOSE(vec2[0] / vec2[1], -0.5, 1e-6);  // vec2 = c [-1, 2]
+}
+
+BOOST_AUTO_TEST_CASE(eigenvector3) {
+  double unit[4] = {0.0, -2.0, 1.0, -3.0};
+  double e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(unit, e1, e2, vec1, vec2);
+  if (e1 < e2) {
+    std::swap(e1, e2);
+    std::swap(vec1, vec2);
+  }
+  BOOST_CHECK_CLOSE(e1, -1.0, 1e-6);
+  BOOST_CHECK_CLOSE(vec1[0] / vec1[1], 2.0, 1e-6);  // vec1 = c [2, 1]
+  BOOST_CHECK_CLOSE(e2, -2.0, 1e-6);
+  BOOST_CHECK_CLOSE(vec2[0] / vec2[1], 1.0, 1e-6);  // vec2 = c [1, 1]
+}
+
+BOOST_AUTO_TEST_CASE(eigenvector4) {
+  double unit[4] = {1.0, 2.0, 3.0, -4.0};
+  double e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(unit, e1, e2, vec1, vec2);
+  if (e1 < e2) {
+    std::swap(e1, e2);
+    std::swap(vec1, vec2);
+  }
+  BOOST_CHECK_CLOSE(e1, 2.0, 1e-6);
+  BOOST_CHECK_CLOSE(vec1[0] / vec1[1], 2.0, 1e-6);  // vec1 = c [2, 1]
+  BOOST_CHECK_CLOSE(e2, -5.0, 1e-6);
+  BOOST_CHECK_CLOSE(vec2[1] / vec2[0], -3.0, 1e-6);  // vec2 = c [-2, 6]
+}
+
+BOOST_AUTO_TEST_CASE(eigenvector5) {
+  double m[4] = {1.0, 0.0, 0.0, 0.5};
+  double e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(m, e1, e2, vec1, vec2);
+  if (e1 < e2) {
+    std::swap(e1, e2);
+    std::swap(vec1, vec2);
+  }
+  BOOST_CHECK_CLOSE(e1, 1.0, 1e-6);
+  BOOST_CHECK_CLOSE(vec1[1] / vec1[0], 0.0, 1e-6);
+  BOOST_CHECK_CLOSE(e2, 0.5, 1e-6);
+  BOOST_CHECK_CLOSE(vec2[0] / vec2[1], 0.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(cholesky_real) {
+  std::complex<double> matrixA[4] = {1., 2., 2., 13.};
+  std::complex<double> matrixB[4] = {1., 2., 2., 13.};
+  const std::complex<double> answer[4] = {1., 0., 2., 3.};
+
+  BOOST_CHECK(Matrix2x2::Cholesky(matrixA));
+  for (size_t i = 0; i != 4; ++i) {
+    BOOST_CHECK_CLOSE(matrixA[i].real(), answer[i].real(), 1e-6);
+    BOOST_CHECK_CLOSE(matrixA[i].imag(), answer[i].imag(), 1e-6);
+  }
+
+  Matrix2x2::UncheckedCholesky(matrixB);
+  for (size_t i = 0; i != 4; ++i) {
+    BOOST_CHECK_CLOSE(matrixB[i].real(), answer[i].real(), 1e-6);
+    BOOST_CHECK_CLOSE(matrixB[i].imag(), answer[i].imag(), 1e-6);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(cholesky_complex) {
+  std::complex<double> matrixA[4] = {{1., 0.}, {2., -5.}, {2., 5.}, {38., 0.}};
+  std::complex<double> matrixB[4] = {{1., 0.}, {2., -5.}, {2., 5.}, {38., 0.}};
+  std::complex<double> answer[4] = {{1., 0.}, {0., 0.}, {2., 5.}, {3., 0.}};
+  BOOST_CHECK(Matrix2x2::CheckedCholesky(matrixA));
+  for (size_t i = 0; i != 4; ++i) {
+    BOOST_CHECK_CLOSE(matrixA[i].real(), answer[i].real(), 1e-6);
+    BOOST_CHECK_CLOSE(matrixA[i].imag(), answer[i].imag(), 1e-6);
+  }
+
+  Matrix2x2::UncheckedCholesky(matrixB);
+  for (size_t i = 0; i != 4; ++i) {
+    BOOST_CHECK_CLOSE(matrixB[i].real(), answer[i].real(), 1e-6);
+    BOOST_CHECK_CLOSE(matrixB[i].imag(), answer[i].imag(), 1e-6);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(cholesky_not_positive) {
+  std::complex<double> diag_not_positive[4] = {
+      {0., 0.}, {0., 0.}, {0., 0.}, {1., 0.}};  // diagonal not positive
+  BOOST_CHECK(!Matrix2x2::CheckedCholesky(diag_not_positive));
+  std::complex<double> diag_not_real[4] = {
+      {1., 0.}, {0., 0.}, {0., 0.}, {1., 1.}};  // diagonal not real
+  BOOST_CHECK(!Matrix2x2::CheckedCholesky(diag_not_real));
+  std::complex<double> not_hermitian[4] = {
+      {1., 0.}, {1., 0.}, {2., 0.}, {1., 0.}};  // not hermitian
+  BOOST_CHECK(!Matrix2x2::CheckedCholesky(not_hermitian));
+}
+
+BOOST_AUTO_TEST_CASE(eigen_value_and_vectors_real) {
+  double m[] = {4.0, 1.0, 0.0, 4.0};
+
+  double e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(m, e1, e2, vec1, vec2);
+
+  BOOST_CHECK_CLOSE(e1, 4.0, 1e-5);
+  BOOST_CHECK_CLOSE(e2, 4.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec1[0], -1.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec1[1], 0.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec2[0], -1.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec2[1], 0.0, 1e-5);
+
+  // Of course this is no longer necessary when the above checks
+  // are already done, but e.g. signs are actually ambiguous in
+  // above equations, so this is the real equation that should hold:
+  BOOST_CHECK_CLOSE(m[0] * vec1[0] + m[1] * vec1[1], e1 * vec1[0], 1e-5);
+  BOOST_CHECK_CLOSE(m[2] * vec1[0] + m[3] * vec1[1], e1 * vec1[1], 1e-5);
+}
+
+BOOST_AUTO_TEST_CASE(eigen_value_and_vectors_complex) {
+  std::complex<double> m[] = {
+      std::complex<double>(4.0, 1.0), std::complex<double>(1.0, 0.0),
+      std::complex<double>(0.0, 0.0), std::complex<double>(4.0, 1.0)};
+
+  std::complex<double> e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(m, e1, e2, vec1, vec2);
+
+  BOOST_CHECK_CLOSE(e1.real(), 4.0, 1e-5);
+  BOOST_CHECK_CLOSE(e1.imag(), 1.0, 1e-5);
+  BOOST_CHECK_CLOSE(e2.real(), 4.0, 1e-5);
+  BOOST_CHECK_CLOSE(e2.imag(), 1.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec1[0].real(), -1.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec1[0].imag(), 0.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec1[1].real(), 0.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec1[1].imag(), 0.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec2[0].real(), -1.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec2[0].imag(), 0.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec2[1].real(), 0.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec2[1].imag(), 0.0, 1e-5);
+
+  BOOST_CHECK_LT(std::abs(m[0] * vec1[0] + m[1] * vec1[1] - e1 * vec1[0]),
+                 1e-5);
+  BOOST_CHECK_LT(std::abs(m[2] * vec1[0] + m[3] * vec1[1] - e1 * vec1[1]),
+                 1e-5);
+}
+
+BOOST_AUTO_TEST_CASE(eigen_value_order_real) {
+  // Test a specific case for which the eigen vector order
+  // is "ambiguous". vec1 should always be associated with
+  // e1, and vec2 with e2.
+  // vec1 = { 0 , 1 }
+  // vec2 = { 1 , 0 }
+  // e1 = 4, e2 = 3
+  // m {0, 1}^T = {0, 4} and m {1, 0}^T = {3, 0}
+  // m = [ 3 0 ; 0 4 ]
+  double m[] = {3.0, 0.0, 0.0, 4.0};
+
+  double e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(m, e1, e2, vec1, vec2);
+
+  BOOST_CHECK_CLOSE(e1, 4.0, 1e-5);
+  BOOST_CHECK_CLOSE(e2, 3.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec1[0], 0.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec1[1], 1.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec2[0], 1.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec2[1], 0.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(m[0] * vec1[0] + m[1] * vec1[1], e1 * vec1[0], 1e-5);
+  BOOST_CHECK_CLOSE(m[2] * vec1[0] + m[3] * vec1[1], e1 * vec1[1], 1e-5);
+}
+
+BOOST_AUTO_TEST_CASE(eigen_value_order1_complex) {
+  // Test a specific case for which the eigen vector order
+  // is "ambiguous". vec1 should always be associated with
+  // e1, and vec2 with e2.
+  // vec1 = { 0 , 1 }
+  // vec2 = { 1 , 0 }
+  // e1 = 4 + i, e2 = 3 + i
+  // m {0, 1}^T = {0, 4+i} and m {1, 0}^T = {3+i, 0}
+  // m = [ 3+i 0 ; 0 4+i ]
+  std::complex<double> m[] = {
+      std::complex<double>(3.0, 1.0), std::complex<double>(0.0, 0.0),
+      std::complex<double>(0.0, 0.0), std::complex<double>(4.0, 1.0)};
+
+  std::complex<double> e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(m, e1, e2, vec1, vec2);
+
+  BOOST_CHECK_CLOSE(e1.real(), 4.0, 1e-5);
+  BOOST_CHECK_CLOSE(e1.imag(), 1.0, 1e-5);
+  BOOST_CHECK_CLOSE(e2.real(), 3.0, 1e-5);
+  BOOST_CHECK_CLOSE(e2.imag(), 1.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec1[0].real(), 0.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec1[1].real(), 1.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec2[0].real(), 1.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec2[1].real(), 0.0, 1e-5);
+
+  const std::complex<double> lhs1 = m[0] * vec1[0] + m[1] * vec1[1],
+                             rhs1 = e1 * vec1[0],
+                             lhs2 = m[2] * vec1[0] + m[3] * vec1[1],
+                             rhs2 = e1 * vec1[1];
+  BOOST_CHECK_LT(std::abs(lhs1 - rhs1), 1e-5);
+  BOOST_CHECK_LT(std::abs(lhs2 - rhs2), 1e-5);
+}
+
+BOOST_AUTO_TEST_CASE(eigen_value_order2_complex) {
+  // vec1 = { 1 , 0 }
+  // vec2 = { 0 , 1 }
+  // e1 = 4 + i, e2 = 3 + i
+  // m {1, 0}^T = {4+i, 0} and m {0, 1}^T = {0, 3+i}
+  // m = [ 4+i 0 ; 0 3+i ]
+  std::complex<double> m[] = {
+      std::complex<double>(4.0, 1.0), std::complex<double>(0.0, 0.0),
+      std::complex<double>(0.0, 0.0), std::complex<double>(3.0, 1.0)};
+
+  std::complex<double> e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(m, e1, e2, vec1, vec2);
+
+  BOOST_CHECK_CLOSE(e1.real(), 4.0, 1e-5);
+  BOOST_CHECK_CLOSE(e1.imag(), 1.0, 1e-5);
+  BOOST_CHECK_CLOSE(e2.real(), 3.0, 1e-5);
+  BOOST_CHECK_CLOSE(e2.imag(), 1.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec1[0].real(), 1.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec1[1].real(), 0.0, 1e-5);
+
+  BOOST_CHECK_CLOSE(vec2[0].real(), 0.0, 1e-5);
+  BOOST_CHECK_CLOSE(vec2[1].real(), 1.0, 1e-5);
+
+  const std::complex<double> lhs1 = m[0] * vec1[0] + m[1] * vec1[1],
+                             rhs1 = e1 * vec1[0],
+                             lhs2 = m[2] * vec1[0] + m[3] * vec1[1],
+                             rhs2 = e1 * vec1[1];
+  BOOST_CHECK_LT(std::abs(lhs1 - rhs1), 1e-5);
+  BOOST_CHECK_LT(std::abs(lhs2 - rhs2), 1e-5);
+}
+
+BOOST_AUTO_TEST_CASE(evdecomposition) {
+  MC2x2 a(1, 2, 3, 4), b(5, 6, 7, 8);
+  MC2x2 jones = a.MultiplyHerm(b) + b.MultiplyHerm(a);
+  MC2x2 r = jones;
+  r *= r.HermTranspose();
+  std::complex<double> e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(r.Data(), e1, e2, vec1, vec2);
+  double v1norm = std::norm(vec1[0]) + std::norm(vec1[1]);
+  vec1[0] /= sqrt(v1norm);
+  vec1[1] /= sqrt(v1norm);
+  double v2norm = std::norm(vec2[0]) + std::norm(vec2[1]);
+  vec2[0] /= sqrt(v2norm);
+  vec2[1] /= sqrt(v2norm);
+
+  MC2x2 u(vec1[0], vec2[0], vec1[1], vec2[1]), e(e1, 0, 0, e2);
+  MC2x2 res = u.Multiply(e).MultiplyHerm(u);
+  for (size_t i = 0; i != 4; ++i)
+    BOOST_CHECK_CLOSE(res[i].real(), r[i].real(), 1e-6);
+
+  MC2x2 decomposed = r.DecomposeHermitianEigenvalue();
+  decomposed *= decomposed.HermTranspose();
+  for (size_t i = 0; i != 4; ++i)
+    BOOST_CHECK_CLOSE(decomposed[i].real(), r[i].real(), 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(herm_transpose) {
+  const std::complex<double> a(1, 2);
+  const std::complex<double> b(3, 4);
+  const std::complex<double> c(5, 6);
+  const std::complex<double> d(7, 8);
+  const MC2x2 m(a, b, c, d);
+  MC2x2 result = m.HermTranspose();
+  BOOST_CHECK_CLOSE(result[0].real(), a.real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[0].imag(), -a.imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[1].real(), c.real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[1].imag(), -c.imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[2].real(), b.real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[2].imag(), -b.imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[3].real(), d.real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[3].imag(), -d.imag(), 1e-6);
+  result -= HermTranspose(m);
+  for (size_t i = 0; i != 4; ++i) BOOST_CHECK_LT(std::norm(result[i]), 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(conjugate, *boost::unit_test::tolerance(1e8)) {
+  const std::complex<double> a(1, 2);
+  const std::complex<double> b(3, 4);
+  const std::complex<double> c(5, 6);
+  const std::complex<double> d(7, 8);
+
+  const MC2x2 m(a, b, c, d);
+  const MC2x2 m_conj = m.Conjugate();
+  BOOST_TEST(m_conj[0] == std::conj(a));
+  BOOST_TEST(m_conj[1] == std::conj(b));
+  BOOST_TEST(m_conj[2] == std::conj(c));
+  BOOST_TEST(m_conj[3] == std::conj(d));
+}
+
+BOOST_AUTO_TEST_CASE(double_dot) {
+  const std::complex<double> a(1, 2);
+  const std::complex<double> b(3, 4);
+  const std::complex<double> c(5, 6);
+  const std::complex<double> d(7, 8);
+  const MC2x2 m(a, b, c, d);
+
+  // Double contraction with conjugate of itself should equal the matrix norm
+  const std::complex<double> result0 = m.DoubleDot(m.Conjugate());
+  BOOST_CHECK_CLOSE(result0.real(), aocommon::Norm(m), 1e-8);
+  BOOST_CHECK_CLOSE(result0.imag(), 0.0, 1e-8);
+
+  const std::complex<double> result1 = m.DoubleDot(m);
+  const std::complex<double> result_ref = a * a + b * b + c * c + d * d;
+  BOOST_CHECK_CLOSE(result1.real(), result_ref.real(), 1e-8);
+  BOOST_CHECK_CLOSE(result1.imag(), result_ref.imag(), 1e-8);
+}
+
+BOOST_AUTO_TEST_CASE(trace) {
+  const std::complex<double> a(1, 2);
+  const std::complex<double> b(3, 4);
+  const std::complex<double> c(5, 6);
+  const std::complex<double> d(7, 8);
+  const MC2x2 m(a, b, c, d);
+  BOOST_CHECK_CLOSE(Trace(m).real(), (a + d).real(), 1e-6);
+  BOOST_CHECK_CLOSE(Trace(m).imag(), (a + d).imag(), 1e-6);
+  BOOST_CHECK_CLOSE((Trace(m) * 0.0).real(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE((Trace(m) * 0.0).imag(), 0.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(norm) {
+  const std::complex<double> a(1, 2);
+  const std::complex<double> b(3, 4);
+  const std::complex<double> c(5, 6);
+  const std::complex<double> d(7, 8);
+  const MC2x2 m(a, b, c, d);
+  double norm_result =
+      1 * 1 + 2 * 2 + 3 * 3 + 4 * 4 + 5 * 5 + 6 * 6 + 7 * 7 + 8 * 8;
+  BOOST_CHECK_CLOSE(Norm(m), norm_result, 1e-6);
+  BOOST_CHECK_CLOSE(Norm(m * std::complex<double>(0.0, 0.0)), 0.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tmatrix2x2diag.cpp b/external/aocommon/tests/tmatrix2x2diag.cpp
new file mode 100644
index 0000000..ace2761
--- /dev/null
+++ b/external/aocommon/tests/tmatrix2x2diag.cpp
@@ -0,0 +1,184 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/matrix2x2diag.h>
+
+#include <iostream>
+
+using aocommon::MC2x2;
+using aocommon::MC2x2Diag;
+
+BOOST_AUTO_TEST_SUITE(matrix2x2diag)
+
+BOOST_AUTO_TEST_CASE(construct_default) {
+  const MC2x2Diag m;
+  BOOST_CHECK_CLOSE(m[0].real(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE(m[0].imag(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE(m[1].real(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE(m[1].imag(), 0.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(construct_from_array) {
+  double unit[2] = {1.0, 1.0};
+  const MC2x2Diag m(unit);
+  BOOST_CHECK_CLOSE(m[0].real(), 1.0, 1e-6);
+  BOOST_CHECK_CLOSE(m[0].imag(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE(m[1].real(), 1.0, 1e-6);
+  BOOST_CHECK_CLOSE(m[1].imag(), 0.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(copy_construct) {
+  const MC2x2Diag source(std::complex<double>(3.0, 4.0),
+                         std::complex<double>(5.0, 6.0));
+  const MC2x2Diag copy(source);
+  BOOST_CHECK_CLOSE(copy[0].real(), 3.0, 1e-6);
+  BOOST_CHECK_CLOSE(copy[0].imag(), 4.0, 1e-6);
+  BOOST_CHECK_CLOSE(copy[1].real(), 5.0, 1e-6);
+  BOOST_CHECK_CLOSE(copy[1].imag(), 6.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(copy_assign) {
+  const MC2x2Diag source(std::complex<double>(3.0, 4.0),
+                         std::complex<double>(5.0, 6.0));
+  MC2x2Diag copy(MC2x2Diag::Zero());
+  copy = source;
+  BOOST_CHECK_CLOSE(copy[0].real(), 3.0, 1e-6);
+  BOOST_CHECK_CLOSE(copy[0].imag(), 4.0, 1e-6);
+  BOOST_CHECK_CLOSE(copy[1].real(), 5.0, 1e-6);
+  BOOST_CHECK_CLOSE(copy[1].imag(), 6.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(add) {
+  MC2x2Diag lhs(std::complex<double>(3.0, 4.0), std::complex<double>(5.0, 6.0));
+  const MC2x2Diag rhs(std::complex<double>(7.0, 8.0),
+                      std::complex<double>(9.0, 10.0));
+  lhs += rhs;
+  lhs += MC2x2Diag::Zero();
+  BOOST_CHECK_CLOSE(lhs[0].real(), 10.0, 1e-6);
+  BOOST_CHECK_CLOSE(lhs[0].imag(), 12.0, 1e-6);
+  BOOST_CHECK_CLOSE(lhs[1].real(), 14.0, 1e-6);
+  BOOST_CHECK_CLOSE(lhs[1].imag(), 16.0, 1e-6);
+  lhs = lhs + lhs + MC2x2Diag::Zero();
+  BOOST_CHECK_CLOSE(lhs[0].real(), 20.0, 1e-6);
+  BOOST_CHECK_CLOSE(lhs[0].imag(), 24.0, 1e-6);
+  BOOST_CHECK_CLOSE(lhs[1].real(), 28.0, 1e-6);
+  BOOST_CHECK_CLOSE(lhs[1].imag(), 32.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(multiply) {
+  const std::complex<double> a(1.0, 2.0);
+  const std::complex<double> b(3.0, 4.0);
+  const std::complex<double> c(5.0, 6.0);
+  const std::complex<double> d(7.0, 8.0);
+  const MC2x2Diag lhs(a, b);
+  const MC2x2Diag rhs(c, d);
+  MC2x2Diag result = lhs * rhs * MC2x2Diag::Unity();
+  result *= MC2x2Diag::Unity() * MC2x2Diag(2, 3);
+  BOOST_CHECK_CLOSE(result[0].real(), 2.0 * (a * c).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[0].imag(), 2.0 * (a * c).imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[1].real(), 3.0 * (b * d).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[1].imag(), 3.0 * (b * d).imag(), 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(scalar_operations) {
+  MC2x2Diag a(2.0, 4.0);
+  a *= 4.0;
+  BOOST_CHECK_CLOSE(a[0].real(), 8.0, 1e-6);
+  BOOST_CHECK_CLOSE(a[0].imag(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE(a[1].real(), 16.0, 1e-6);
+  BOOST_CHECK_CLOSE(a[1].imag(), 0.0, 1e-6);
+  a /= 2.0;
+  BOOST_CHECK_CLOSE(a[0].real(), 4.0, 1e-6);
+  BOOST_CHECK_CLOSE(a[0].imag(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE(a[1].real(), 8.0, 1e-6);
+  BOOST_CHECK_CLOSE(a[1].imag(), 0.0, 1e-6);
+
+  MC2x2Diag b = a * 2.0;
+  BOOST_CHECK_CLOSE(b[0].real(), 8.0, 1e-6);
+  BOOST_CHECK_CLOSE(b[0].imag(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE(b[1].real(), 16.0, 1e-6);
+  BOOST_CHECK_CLOSE(b[1].imag(), 0.0, 1e-6);
+
+  MC2x2Diag c = b / 2.0;
+  BOOST_CHECK_CLOSE(c[0].real(), 4.0, 1e-6);
+  BOOST_CHECK_CLOSE(c[0].imag(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE(c[1].real(), 8.0, 1e-6);
+  BOOST_CHECK_CLOSE(c[1].imag(), 0.0, 1e-6);
+
+  MC2x2Diag d(std::complex<double>{1.0, 2.0}, std::complex<double>{3.0, 4.0});
+  d *= std::complex<double>{1.0, 2.0};
+  BOOST_CHECK_CLOSE(d[0].real(), -3.0, 1e-6);
+  BOOST_CHECK_CLOSE(d[0].imag(), 4.0, 1e-6);
+  BOOST_CHECK_CLOSE(d[1].real(), -5.0, 1e-6);
+  BOOST_CHECK_CLOSE(d[1].imag(), 10.0, 1e-6);
+
+  MC2x2Diag e = d * std::complex<double>{2.0, 1.0};
+  BOOST_CHECK_CLOSE(e[0].real(), -10.0, 1e-6);
+  BOOST_CHECK_CLOSE(e[0].imag(), 5.0, 1e-6);
+  BOOST_CHECK_CLOSE(e[1].real(), -20.0, 1e-6);
+  BOOST_CHECK_CLOSE(e[1].imag(), 15.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(herm_transpose) {
+  const MC2x2Diag m(std::complex<double>(3.0, 4.0),
+                    std::complex<double>(5.0, 6.0));
+  const MC2x2Diag result = m.HermTranspose();
+  BOOST_CHECK_CLOSE(result[0].real(), 3.0, 1e-6);
+  BOOST_CHECK_CLOSE(result[0].imag(), -4.0, 1e-6);
+  BOOST_CHECK_CLOSE(result[1].real(), 5.0, 1e-6);
+  BOOST_CHECK_CLOSE(result[1].imag(), -6.0, 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(diagonal) {
+  const std::complex<double> a(1.0, 2.0);
+  const std::complex<double> b(3.0, 4.0);
+  const std::complex<double> c(5.0, 6.0);
+  const std::complex<double> d(7.0, 8.0);
+  const MC2x2 m(a, b, c, d);
+  const MC2x2Diag dm = Diagonal(m);
+  BOOST_CHECK_CLOSE(dm[0].real(), a.real(), 1e-6);
+  BOOST_CHECK_CLOSE(dm[0].imag(), a.imag(), 1e-6);
+  BOOST_CHECK_CLOSE(dm[1].real(), d.real(), 1e-6);
+  BOOST_CHECK_CLOSE(dm[1].imag(), d.imag(), 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(diag_nondiag_multiply) {
+  const std::complex<double> a(1.0, 2.0);
+  const std::complex<double> b(3.0, 4.0);
+  const std::complex<double> c(5.0, 6.0);
+  const std::complex<double> d(7.0, 8.0);
+  const std::complex<double> e(8.0, 9.0);
+  const std::complex<double> f(10.0, 11.0);
+  const MC2x2 m(a, b, c, d);
+  const MC2x2Diag dm(e, f);
+  const MC2x2 result = m * dm;
+  BOOST_CHECK_CLOSE(result[0].real(), (a * e).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[0].imag(), (a * e).imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[1].real(), (b * f).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[1].imag(), (b * f).imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[2].real(), (c * e).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[2].imag(), (c * e).imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[3].real(), (d * f).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[3].imag(), (d * f).imag(), 1e-6);
+}
+
+BOOST_AUTO_TEST_CASE(nondiag_diag_multiply) {
+  const std::complex<double> a(1.0, 2.0);
+  const std::complex<double> b(3.0, 4.0);
+  const std::complex<double> c(5.0, 6.0);
+  const std::complex<double> d(7.0, 8.0);
+  const std::complex<double> e(8.0, 9.0);
+  const std::complex<double> f(10.0, 11.0);
+  const MC2x2Diag dm(a, b);
+  const MC2x2 m(c, d, e, f);
+  const MC2x2 result = dm * m;
+  BOOST_CHECK_CLOSE(result[0].real(), (a * c).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[0].imag(), (a * c).imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[1].real(), (a * d).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[1].imag(), (a * d).imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[2].real(), (b * e).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[2].imag(), (b * e).imag(), 1e-6);
+  BOOST_CHECK_CLOSE(result[3].real(), (b * f).real(), 1e-6);
+  BOOST_CHECK_CLOSE(result[3].imag(), (b * f).imag(), 1e-6);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tmatrix4x4.cpp b/external/aocommon/tests/tmatrix4x4.cpp
new file mode 100644
index 0000000..a7b4f3a
--- /dev/null
+++ b/external/aocommon/tests/tmatrix4x4.cpp
@@ -0,0 +1,84 @@
+#ifndef TEST_MATRIX4X4_H
+#define TEST_MATRIX4X4_H
+
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/matrix4x4.h>
+
+using aocommon::Matrix4x4;
+using aocommon::MC2x2;
+using aocommon::MC4x4;
+using aocommon::Vector4;
+
+BOOST_AUTO_TEST_SUITE(matrix4x4)
+
+static void CheckMatrix(const Matrix4x4& result, const Matrix4x4& groundtruth) {
+  for (size_t i = 0; i != 16; ++i) {
+    BOOST_CHECK_CLOSE(result[i].real(), groundtruth[i].real(), 1e-6);
+    BOOST_CHECK_CLOSE(result[i].imag(), groundtruth[i].imag(), 1e-6);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(construction) {
+  CheckMatrix(MC4x4(), MC4x4{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+                             0.0, 0.0, 0.0, 0.0, 0.0, 0.0});
+
+  // Constructor must take 16 values if a list is given:
+  BOOST_CHECK_THROW(MC4x4({3, 4}), std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(unit) {
+  MC4x4 unit = MC4x4::Unit();
+  MC4x4 ref{1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
+            0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0};
+  CheckMatrix(unit, ref);
+}
+
+BOOST_AUTO_TEST_CASE(inversion) {
+  MC4x4 m1(MC4x4::Unit());
+  BOOST_CHECK(m1.Invert());
+  CheckMatrix(m1, MC4x4::Unit());
+
+  MC4x4 m2(MC4x4::Unit() * 2);
+  BOOST_CHECK(m2.Invert());
+  CheckMatrix(m2, MC4x4::Unit() * 0.5);
+  BOOST_CHECK(m2.Invert());
+  CheckMatrix(m2, MC4x4::Unit() * 2.0);
+
+  MC4x4 m3;
+  BOOST_CHECK(!m3.Invert());
+}
+
+static void checkKroneckerProduct(const MC2x2& a, const MC2x2& x,
+                                  const MC2x2& b) {
+  Vector4 ref = a.Multiply(x).MultiplyHerm(b).Vec();
+  MC4x4 product = MC4x4::KroneckerProduct(b.HermTranspose().Transpose(), a);
+  Vector4 v = product * x.Vec();
+  for (size_t i = 0; i != 4; ++i) {
+    BOOST_CHECK_CLOSE(v[i].real(), ref[i].real(), 1e-6);
+    BOOST_CHECK_CLOSE(v[i].imag(), ref[i].imag(), 1e-6);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(kronecker_product) {
+  checkKroneckerProduct(MC2x2::Unity(), MC2x2::Unity(), MC2x2::Unity());
+
+  MC2x2 a1{1.0, 2.0, 2.0, 4.0}, x1(MC2x2::Unity()), b1{1.0, 2.0, 2.0, 4.0};
+  checkKroneckerProduct(a1, x1, b1);
+
+  MC2x2 a2{0.0, 1.0, 2.0, 3.0}, x2(MC2x2::Unity()), b2{0.0, 1.0, 2.0, 3.0};
+  checkKroneckerProduct(a2, x2, b2);
+
+  MC2x2 a3{0.0, 1.0, 2.0, 3.0}, x3{0.0, 1.0, 2.0, 3.0}, b3{0.0, 1.0, 2.0, 3.0};
+  checkKroneckerProduct(a3, x3, b3);
+
+  std::complex<double> x(8, 2), y(6, 3);
+  MC2x2 a4{0.0, 1.0 * y, 2.0 * x, 3.0 * y},
+      x4{1.0 * y, 2.0 * x, 3.0 * x, 4.0 * y},
+      b4{1.0 * x, 2.0 * x, 3.0 * x, 4.0 * y};
+  checkKroneckerProduct(a4, x4, b4);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
+
+#endif
diff --git a/external/aocommon/tests/tmultibanddata.cpp b/external/aocommon/tests/tmultibanddata.cpp
new file mode 100644
index 0000000..2bd4dbd
--- /dev/null
+++ b/external/aocommon/tests/tmultibanddata.cpp
@@ -0,0 +1,106 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/multibanddata.h>
+
+#include <vector>
+
+using aocommon::BandData;
+using aocommon::ChannelInfo;
+using aocommon::MultiBandData;
+
+BOOST_AUTO_TEST_SUITE(multi_band_data)
+
+BOOST_AUTO_TEST_CASE(empty) {
+  MultiBandData multiBand;
+  BOOST_CHECK_EQUAL(multiBand.BandCount(), 0u);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.BandStart(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.BandEnd(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.Bandwidth(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.CentreFrequency(), 0.0, 1e-6);
+  BOOST_CHECK_EQUAL(multiBand.DataDescCount(), 0u);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.HighestFrequency(), 0.0, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.LowestFrequency(), 0.0, 1e-6);
+
+  MultiBandData moved(std::move(multiBand));
+  BOOST_CHECK_EQUAL(moved.BandCount(), 0u);
+
+  MultiBandData copied(multiBand);
+  BOOST_CHECK_EQUAL(copied.BandCount(), 0u);
+}
+
+BOOST_AUTO_TEST_CASE(irregular_bands) {
+  // Band 1 has (purposely):
+  // - A higher frequency than Band 2
+  // - Fewer channels than Band 2
+  // - Have a different channel width
+  // MultiBandData should be able to handle this.
+  std::vector<ChannelInfo> channels1{ChannelInfo(180e6, 10e6),
+                                     ChannelInfo(190e6, 10e6)},
+      channels2{ChannelInfo(140e6, 5e6), ChannelInfo(145e6, 5e6),
+                ChannelInfo(150e6, 5e6)};
+  MultiBandData multiBand;
+  const size_t data_desc_id_1 = multiBand.AddBand(BandData(channels1, 185e6));
+  const size_t data_desc_id_2 = multiBand.AddBand(BandData(channels2, 145e6));
+
+  BOOST_CHECK_EQUAL(multiBand.BandCount(), 2u);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.BandStart(), 137.5e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.BandEnd(), 195e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.Bandwidth(), 195e6 - 137.5e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.CentreFrequency(),
+                             0.5 * (195e6 + 137.5e6), 1e-6);
+  BOOST_CHECK_EQUAL(multiBand.DataDescCount(), 2u);
+  BOOST_CHECK_EQUAL(multiBand.GetBandIndex(data_desc_id_1), 0u);
+  BOOST_CHECK_EQUAL(multiBand.GetBandIndex(data_desc_id_2), 1u);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.HighestFrequency(), 190e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(multiBand.LowestFrequency(), 140e6, 1e-6);
+  BOOST_CHECK_EQUAL(multiBand[data_desc_id_1].ChannelCount(), 2u);
+  BOOST_CHECK_EQUAL(multiBand[data_desc_id_2].ChannelCount(), 3u);
+
+  MultiBandData partialBandA(multiBand, 1, 2);
+  BOOST_CHECK_EQUAL(partialBandA.BandCount(), 2u);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandA.BandStart(), 142.5e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandA.BandEnd(), 195e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandA.Bandwidth(), 195e6 - 142.5e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandA.CentreFrequency(),
+                             0.5 * (195e6 + 142.5e6), 1e-6);
+  BOOST_CHECK_EQUAL(partialBandA.DataDescCount(), 2u);
+  BOOST_CHECK_EQUAL(partialBandA.GetBandIndex(data_desc_id_1), 0u);
+  BOOST_CHECK_EQUAL(partialBandA.GetBandIndex(data_desc_id_2), 1u);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandA.HighestFrequency(), 190e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandA.LowestFrequency(), 145e6, 1e-6);
+  BOOST_CHECK_EQUAL(partialBandA[data_desc_id_1].ChannelCount(), 1u);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandA[data_desc_id_1].ChannelFrequency(0),
+                             190e6, 1e-6);
+  BOOST_CHECK_EQUAL(partialBandA[data_desc_id_2].ChannelCount(), 1u);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandA[data_desc_id_2].ChannelFrequency(0),
+                             145e6, 1e-6);
+
+  MultiBandData partialBandB(multiBand, 1, 3);
+  BOOST_CHECK_EQUAL(partialBandB.BandCount(), 2u);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandB.BandStart(), 142.5e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandB.BandEnd(), 195e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandB.Bandwidth(), 195e6 - 142.5e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandB.CentreFrequency(),
+                             0.5 * (195e6 + 142.5e6), 1e-6);
+  BOOST_CHECK_EQUAL(partialBandB.DataDescCount(), 2u);
+  BOOST_CHECK_EQUAL(partialBandB.GetBandIndex(data_desc_id_1), 0u);
+  BOOST_CHECK_EQUAL(partialBandB.GetBandIndex(data_desc_id_2), 1u);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandB.HighestFrequency(), 190e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandB.LowestFrequency(), 145e6, 1e-6);
+  BOOST_CHECK_EQUAL(partialBandB[data_desc_id_1].ChannelCount(), 1u);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandB[data_desc_id_1].ChannelFrequency(0),
+                             190e6, 1e-6);
+  BOOST_CHECK_EQUAL(partialBandB[data_desc_id_2].ChannelCount(), 2u);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandB[data_desc_id_2].ChannelFrequency(0),
+                             145e6, 1e-6);
+  BOOST_CHECK_CLOSE_FRACTION(partialBandB[data_desc_id_2].ChannelFrequency(1),
+                             150e6, 1e-6);
+
+  MultiBandData copy(multiBand);
+  BOOST_CHECK_EQUAL(copy.BandCount(), 2u);
+
+  MultiBandData moved(std::move(multiBand));
+  BOOST_CHECK_EQUAL(moved.BandCount(), 2u);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tparallelfor.cpp b/external/aocommon/tests/tparallelfor.cpp
new file mode 100644
index 0000000..7d09ea8
--- /dev/null
+++ b/external/aocommon/tests/tparallelfor.cpp
@@ -0,0 +1,123 @@
+#include <aocommon/barrier.h>
+#include <aocommon/parallelfor.h>
+
+#include <iostream>
+
+#include <cmath>
+#include <mutex>
+
+#include <unistd.h>  // for sleep
+
+#include <boost/test/unit_test.hpp>
+
+using namespace aocommon;
+
+BOOST_AUTO_TEST_SUITE(parallelfor)
+
+void func() {}
+
+BOOST_AUTO_TEST_CASE(barrier) {
+  BOOST_CHECK_NO_THROW(Barrier b(1, func); b.wait();
+
+                       Barrier c(2, func); std::thread t([&]() { c.wait(); });
+                       c.wait(); t.join(););
+}
+
+BOOST_AUTO_TEST_CASE(unused) { BOOST_CHECK_NO_THROW(ParallelFor<size_t>(4);); }
+
+BOOST_AUTO_TEST_CASE(single_thread) {
+  ParallelFor<size_t> loop(1);
+  std::vector<size_t> counts(10, 0);
+  loop.Run(0, 10, [&](size_t iter) { counts[iter]++; });
+
+  const std::vector<size_t> ref(10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(parallel_with_thread_id) {
+  ParallelFor<size_t> loop(4);
+  std::mutex mutex;
+  std::vector<size_t> counts(10, 0);
+  loop.Run(0, 10, [&](size_t iter, size_t thread_id) {
+    std::unique_lock<std::mutex> lock(mutex);
+    BOOST_CHECK_LT(thread_id, 4);
+    counts[iter]++;
+  });
+
+  const std::vector<size_t> ref(10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(parallel_without_thread_id) {
+  ParallelFor<size_t> loop(4);
+  std::mutex mutex;
+  std::vector<size_t> counts(10, 0);
+  loop.Run(0, 10, [&](size_t iter) {
+    std::unique_lock<std::mutex> lock(mutex);
+    counts[iter]++;
+  });
+
+  const std::vector<size_t> ref(10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(reuse_with_thread_id) {
+  std::vector<size_t> counts(20, 0);
+  std::mutex mutex;
+  ParallelFor<size_t> loop(4);
+  loop.Run(0, 10, [&](size_t iter, size_t thread_id) {
+    std::unique_lock<std::mutex> lock(mutex);
+    BOOST_CHECK_LT(thread_id, 4);
+    counts[iter]++;
+  });
+  std::vector<size_t> ref(20, 0);
+  std::fill(ref.begin(), ref.begin() + 10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+
+  loop.Run(10, 20, [&](size_t iter, size_t thread_id) {
+    std::unique_lock<std::mutex> lock(mutex);
+    BOOST_CHECK_LT(thread_id, 4);
+    counts[iter]++;
+  });
+  ref = std::vector<size_t>(20, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(reuse_without_thread_id) {
+  std::vector<size_t> counts(20, 0);
+  std::mutex mutex;
+  ParallelFor<size_t> loop(4);
+  loop.Run(0, 10, [&](size_t iter) {
+    std::unique_lock<std::mutex> lock(mutex);
+    counts[iter]++;
+  });
+  std::vector<size_t> ref(20, 0);
+  std::fill(ref.begin(), ref.begin() + 10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+
+  loop.Run(10, 20, [&](size_t iter) {
+    std::unique_lock<std::mutex> lock(mutex);
+    counts[iter]++;
+  });
+  ref = std::vector<size_t>(20, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(single_threaded_with_thread_id) {
+  ParallelFor<size_t> pFor(1);
+  std::vector<size_t> counts(10, 0);
+  pFor.Run(0, 10, [&](size_t iter, size_t) { counts[iter]++; });
+
+  std::vector<size_t> ref(10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tqueue.cpp b/external/aocommon/tests/tqueue.cpp
new file mode 100644
index 0000000..e4e87ef
--- /dev/null
+++ b/external/aocommon/tests/tqueue.cpp
@@ -0,0 +1,104 @@
+
+#include <aocommon/queue.h>
+
+#include <boost/test/unit_test.hpp>
+
+#include <memory>
+#include <type_traits>
+#include <vector>
+
+using aocommon::Queue;
+
+BOOST_AUTO_TEST_SUITE(queue)
+
+BOOST_AUTO_TEST_CASE(constructor) {
+  const Queue<int> q;
+  BOOST_CHECK(q.Empty());
+  BOOST_CHECK_EQUAL(q.Size(), 0u);
+  BOOST_CHECK(q.begin() == q.end());
+  // The initial capacity shouldn't be too much.
+  BOOST_CHECK_LE(q.Capacity(), 16u);
+}
+
+BOOST_AUTO_TEST_CASE(push_pop_push) {
+  Queue<std::pair<int, int>> q;  // Use a non-pod value type.
+
+  // Test lvalue push back.
+  const std::pair<int, int> value(42, 43);
+  const std::pair<int, int>& pushed_lvalue = q.PushBack(value);  // lvalue
+  BOOST_CHECK_EQUAL(&pushed_lvalue, &q[0]);
+  BOOST_CHECK_EQUAL(&*q.begin(), &q[0]);
+  BOOST_CHECK_EQUAL(q.end() - q.begin(), 1);
+  BOOST_CHECK_EQUAL(q.Size(), 1u);
+  BOOST_CHECK_EQUAL(q[0].first, 42);
+  BOOST_CHECK_EQUAL(q[0].second, 43);
+
+  q.PopFront();
+  BOOST_CHECK(q.Empty());
+
+  // Test rvalue push back.
+  const std::pair<int, int>& pushed_rvalue = q.PushBack(std::make_pair(52, 53));
+  BOOST_CHECK(q.Size() == 1u);
+  BOOST_CHECK_EQUAL(&pushed_rvalue, &q[0]);
+  BOOST_CHECK(&*q.begin() == &q[0]);
+  BOOST_CHECK_EQUAL(q.end() - q.begin(), 1);
+  BOOST_CHECK_EQUAL(q[0].first, 52);
+  BOOST_CHECK_EQUAL(q[0].second, 53);
+}
+
+BOOST_AUTO_TEST_CASE(push50_pop50_push50) {
+  const int n = 50;
+  Queue<int> q;
+
+  for (int i = 0; i < n; ++i) q.PushBack(i);
+  BOOST_CHECK_EQUAL(q.end() - q.begin(), n);
+  BOOST_CHECK_EQUAL(q.Size(), std::size_t(n));
+  for (int i = 0; i < n; ++i) BOOST_CHECK_EQUAL(q[i], i);
+
+  for (int i = 0; i < n; ++i) {
+    q.PopFront();
+    BOOST_CHECK_EQUAL(q.Size(), std::size_t(n - i - 1));
+  }
+
+  for (int i = 0; i < n; ++i) q.PushBack(i);
+  BOOST_CHECK_EQUAL(q.end() - q.begin(), n);
+  BOOST_CHECK_EQUAL(q.Size(), std::size_t(n));
+  for (int i = 0; i < n; ++i) BOOST_CHECK_EQUAL(q[i], i);
+
+  // Check that the capacity is still reasonable.
+  BOOST_CHECK_LT(q.Capacity(), std::size_t(2 * n));
+}
+
+BOOST_AUTO_TEST_CASE(clear) {
+  Queue<int> q;
+  const std::size_t initial_capacity = q.Capacity();
+
+  for (int i = 0; i < 42; ++i) q.PushBack(i);
+  BOOST_CHECK_EQUAL(q.Size(), 42u);
+  const std::size_t new_capacity = q.Capacity();
+  BOOST_REQUIRE_GT(new_capacity, initial_capacity);
+
+  q.Clear();
+  BOOST_CHECK(q.Empty());
+  BOOST_CHECK_EQUAL(q.Size(), 0u);
+  BOOST_CHECK_EQUAL(q.Capacity(), new_capacity);
+}
+
+/// Test creating a vector of Queues with move-only types, which is a use case.
+/// When a Queue contains move-only values, such as std::unique_ptr, a
+/// std::vector<Queue<std::unique_ptr<X>>> only works if Queue has a noexcept
+/// move constructor. (A std::vector<std::deque<std::unique_ptr<X>> does not
+/// work, for that reason: The compiler will complain.)
+BOOST_AUTO_TEST_CASE(vector_of_fifo_of_move_only_type) {
+  // Check using type traits.
+  static_assert(
+      std::is_nothrow_move_constructible<Queue<std::unique_ptr<int>>>::value,
+      "Queue is 'nothrow move constructible'");
+
+  // Check by creating a vector of Fifos.
+  std::vector<Queue<std::unique_ptr<int>>> queues(1);
+  queues.emplace_back();
+  // This test is a mainly compile-time test -> No further checks are needed.
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tradeccoord.cpp b/external/aocommon/tests/tradeccoord.cpp
new file mode 100644
index 0000000..330c3da
--- /dev/null
+++ b/external/aocommon/tests/tradeccoord.cpp
@@ -0,0 +1,84 @@
+#include <boost/test/unit_test.hpp>
+#include <boost/test/data/test_case.hpp>
+
+#include <aocommon/radeccoord.h>
+
+using aocommon::RaDecCoord;
+
+BOOST_AUTO_TEST_SUITE(ra_dec_coord)
+
+const std::string raValues[15] = {"00h00m00s",   "00h00m00.0s", "00h00m00.00s",
+                                  "12h00m00.0s", "00:00:00.0",  "-00:00:00.0",
+                                  "-00:01:00.0", "-23:59:59.9", "-23:59:59.99",
+                                  "11:59:59.9",  "-11:59:59.9", "23:59:59.9",
+                                  "23:59:59.90", "23:59:59.99", "23:59:59.999"};
+
+const std::string badRaValues[8] = {"",       "00h00m00.00-", "00h00m00.00s!",
+                                    "?",      "00h",          "00h00m",
+                                    "00:00*", "00:00:00.0x"};
+
+static const std::string decValues[11] = {
+    "00d00m00.0s",  "90d00m00.0s",  "00.00.00.0",   "-00d00m00s",
+    "-00d01m00.0s", "89.59.59.9",   "89d59m59.99s", "-89.59.59.9",
+    "-89.59.59.90", "-89.59.59.99", "-89.59.59.999"};
+
+static const std::string badDecValues[7] = {
+    "", "-", "00.00.00.a", "-00d", "-00d01", "01d02m03", "05.04a"};
+
+BOOST_DATA_TEST_CASE(testRAParsesConsistently,
+                     boost::unit_test::data::make(raValues)) {
+  long double val = RaDecCoord::ParseRA(sample);
+  if (val < 0.0) val += 2.0L * M_PIl;
+  std::string recomposed = RaDecCoord::RAToString(val);
+
+  BOOST_CHECK_CLOSE_FRACTION(val, RaDecCoord::ParseRA(recomposed), 1e-9);
+}
+
+BOOST_DATA_TEST_CASE(testRAToString, boost::unit_test::data::make(raValues)) {
+  double val = RaDecCoord::ParseRA(sample);
+  if (val < 0.0) val += 2.0L * M_PIl;
+  std::string recomposed = RaDecCoord::RAToString(val);
+
+  BOOST_CHECK_CLOSE_FRACTION(val, RaDecCoord::ParseRA(recomposed), 1e-9);
+}
+
+BOOST_AUTO_TEST_CASE(testNegativeRAToString) {
+  // A negative RA should parse fine and produce a negative
+  // value in radians:
+  double val = RaDecCoord::ParseRA("-10h30m00s");
+  BOOST_CHECK_CLOSE_FRACTION(val, -10.5 * M_PIl / 12.0L, 1e-9);
+
+  // A negative value in radians should however still produce a
+  // "positive" RA string, because it is uncommon to write
+  // an RA as "-10h30m".
+  std::string recomposed = RaDecCoord::RAToString(val);
+  BOOST_CHECK_EQUAL(recomposed.substr(0, 10), "13h30m00.0");
+}
+
+BOOST_DATA_TEST_CASE(testRAParseException,
+                     boost::unit_test::data::make(badRaValues)) {
+  BOOST_CHECK_THROW(RaDecCoord::ParseRA(sample), std::runtime_error);
+}
+
+BOOST_DATA_TEST_CASE(testDeclinationParsesConsistently,
+                     boost::unit_test::data::make(decValues)) {
+  double val = RaDecCoord::ParseDec(sample);
+  std::string recomposed = RaDecCoord::DecToString(val);
+  BOOST_CHECK_EQUAL(RaDecCoord::ParseDec(sample),
+                    RaDecCoord::ParseDec(recomposed));
+}
+
+BOOST_DATA_TEST_CASE(testDeclinationToString,
+                     boost::unit_test::data::make(decValues)) {
+  double val = RaDecCoord::ParseDec(sample);
+  std::string recomposed = RaDecCoord::DecToString(val);
+  BOOST_CHECK_EQUAL(recomposed,
+                    RaDecCoord::DecToString(RaDecCoord::ParseDec(recomposed)));
+}
+
+BOOST_DATA_TEST_CASE(testDeclinationParseException,
+                     boost::unit_test::data::make(badDecValues)) {
+  BOOST_CHECK_THROW(RaDecCoord::ParseDec(sample), std::runtime_error);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tserialstream.cpp b/external/aocommon/tests/tserialstream.cpp
new file mode 100644
index 0000000..2261f42
--- /dev/null
+++ b/external/aocommon/tests/tserialstream.cpp
@@ -0,0 +1,250 @@
+#include <boost/test/unit_test.hpp>
+
+#include <aocommon/io/serialistream.h>
+#include <aocommon/io/serialostream.h>
+
+#include <limits>
+
+using aocommon::SerialIStream;
+using aocommon::SerialOStream;
+
+BOOST_AUTO_TEST_SUITE(serialization)
+
+BOOST_AUTO_TEST_CASE(one_by_one_input_syntax) {
+  SerialOStream ostr;
+  ostr.Bool(true)
+      .UInt8(80)
+      .UInt16(160)
+      .UInt32(320)
+      .UInt64(640)
+      .Float(1.5)
+      .Double(3.14)
+      .LDouble(2.71)
+      .String("hi!");
+
+  SerialIStream istr(std::move(ostr));
+
+  BOOST_CHECK_EQUAL(istr.Bool(), true);
+  BOOST_CHECK_EQUAL(istr.UInt8(), 80u);
+  BOOST_CHECK_EQUAL(istr.UInt16(), 160u);
+  BOOST_CHECK_EQUAL(istr.UInt32(), 320u);
+  BOOST_CHECK_EQUAL(istr.UInt64(), 640u);
+  BOOST_CHECK_EQUAL(istr.Float(), 1.5);
+  BOOST_CHECK_EQUAL(istr.Double(), 3.14);
+  BOOST_CHECK_EQUAL(istr.LDouble(), 2.71);
+  BOOST_CHECK_EQUAL(istr.String(), "hi!");
+}
+
+BOOST_AUTO_TEST_CASE(concatenated_input_syntax) {
+  SerialOStream ostr;
+  ostr.Bool(true)
+      .UInt8(80)
+      .UInt16(160)
+      .UInt32(320)
+      .UInt64(640)
+      .Float(1.5)
+      .Double(3.14)
+      .LDouble(2.71)
+      .String("hi!");
+
+  bool b = false;
+  uint8_t u8 = 0;
+  uint16_t u16 = 0;
+  uint32_t u32 = 0;
+  uint64_t u64 = 0;
+  float f = 0.0f;
+  double d = 0.0;
+  long double ld = 0.0;
+  std::string s;
+
+  SerialIStream istr(std::move(ostr));
+  istr.Bool(b)
+      .UInt8(u8)
+      .UInt16(u16)
+      .UInt32(u32)
+      .UInt64(u64)
+      .Float(f)
+      .Double(d)
+      .LDouble(ld)
+      .String(s);
+
+  BOOST_CHECK_EQUAL(b, true);
+  BOOST_CHECK_EQUAL(u8, 80u);
+  BOOST_CHECK_EQUAL(u16, 160u);
+  BOOST_CHECK_EQUAL(u32, 320u);
+  BOOST_CHECK_EQUAL(u64, 640u);
+  BOOST_CHECK_EQUAL(f, 1.5);
+  BOOST_CHECK_EQUAL(d, 3.14);
+  BOOST_CHECK_EQUAL(ld, 2.71);
+  BOOST_CHECK_EQUAL(s, "hi!");
+}
+
+BOOST_AUTO_TEST_CASE(vector) {
+  const std::vector<std::int32_t> int32_a;
+  const std::vector<std::int32_t> int32_b{12, -13, 14};
+  const std::vector<std::uint64_t> uint64_a;
+  const std::vector<std::uint64_t> uint64_b{18, 19, 20};
+  const std::vector<std::complex<float>> cf_a;
+  const std::vector<std::complex<float>> cf_b{{1, 1}, {-2, -2}, {3, 3}};
+
+  SerialOStream ostr;
+  ostr.Vector(int32_a)
+      .Vector(int32_b)
+      .Vector(uint64_a)
+      .Vector(uint64_b)
+      .Vector(cf_a)
+      .Vector(cf_b);
+
+  SerialIStream istr(std::move(ostr));
+
+  std::vector<std::int32_t> out_int32_a, out_int32_b;
+  std::vector<std::uint64_t> out_uint64_a, out_uint64_b;
+  std::vector<std::complex<float>> out_cf_a, out_cf_b;
+  istr.Vector(out_int32_a)
+      .Vector(out_int32_b)
+      .Vector(out_uint64_a)
+      .Vector(out_uint64_b)
+      .Vector(out_cf_a)
+      .Vector(out_cf_b);
+  BOOST_CHECK(out_int32_a.empty());
+  BOOST_CHECK_EQUAL_COLLECTIONS(int32_b.begin(), int32_b.end(),
+                                out_int32_b.begin(), out_int32_b.end());
+  BOOST_CHECK(out_uint64_a.empty());
+  BOOST_CHECK_EQUAL_COLLECTIONS(uint64_b.begin(), uint64_b.end(),
+                                out_uint64_b.begin(), out_uint64_b.end());
+  BOOST_CHECK(out_cf_a.empty());
+  BOOST_CHECK_EQUAL_COLLECTIONS(cf_b.begin(), cf_b.end(), out_cf_b.begin(),
+                                out_cf_b.end());
+}
+
+BOOST_AUTO_TEST_CASE(vector64) {
+  const std::vector<std::int8_t> int8_a;
+  const std::vector<std::int8_t> int8_b{
+      0, std::numeric_limits<std::int8_t>::min(),
+      std::numeric_limits<std::int8_t>::max()};
+  const std::vector<std::int64_t> int64_a;
+  const std::vector<std::int64_t> int64_b{
+      0, std::numeric_limits<std::int64_t>::min(),
+      std::numeric_limits<std::int64_t>::max()};
+
+  SerialOStream ostr;
+  ostr.VectorUInt64(int8_a)
+      .VectorUInt64(int8_b)
+      .VectorUInt64(int64_a)
+      .VectorUInt64(int64_b);
+
+  SerialIStream istr(std::move(ostr));
+
+  std::vector<std::int8_t> out_int8_a, out_int8_b;
+  std::vector<std::int64_t> out_int64_a, out_int64_b;
+  istr.VectorUInt64(out_int8_a)
+      .VectorUInt64(out_int8_b)
+      .VectorUInt64(out_int64_b)
+      .VectorUInt64(out_int64_b);
+
+  BOOST_CHECK(out_int8_a.empty());
+  BOOST_CHECK_EQUAL_COLLECTIONS(int8_b.begin(), int8_b.end(),
+                                out_int8_b.begin(), out_int8_b.end());
+  BOOST_CHECK(out_int64_a.empty());
+  BOOST_CHECK_EQUAL_COLLECTIONS(int64_b.begin(), int64_b.end(),
+                                out_int64_b.begin(), out_int64_b.end());
+}
+
+struct Serializable {
+  // By updating the stream pointer members, the test can check that these
+  // functions were called with the proper argument.
+  void Serialize(SerialOStream& stream) { ostream = &stream; }
+  void Unserialize(SerialIStream& stream) { istream = &stream; }
+
+  SerialIStream* istream = nullptr;
+  SerialOStream* ostream = nullptr;
+};
+
+BOOST_AUTO_TEST_CASE(pointer) {
+  std::shared_ptr<Serializable> shared_empty;
+  std::shared_ptr<Serializable> shared(new Serializable());
+  std::unique_ptr<Serializable> unique_empty;
+  std::unique_ptr<Serializable> unique(new Serializable());
+
+  SerialOStream ostr;
+  ostr.Ptr(shared_empty).Ptr(shared).Ptr(unique_empty).Ptr(unique);
+  BOOST_CHECK_EQUAL(shared->ostream, &ostr);
+  BOOST_CHECK_EQUAL(unique->ostream, &ostr);
+  BOOST_CHECK_EQUAL(shared->istream, nullptr);
+  BOOST_CHECK_EQUAL(unique->istream, nullptr);
+
+  SerialIStream istr(std::move(ostr));
+
+  std::shared_ptr<Serializable> out_shared_empty;
+  std::shared_ptr<Serializable> out_shared;
+  std::unique_ptr<Serializable> out_unique_empty;
+  std::unique_ptr<Serializable> out_unique;
+  istr.Ptr(out_shared_empty)
+      .Ptr(out_shared)
+      .Ptr(out_unique_empty)
+      .Ptr(out_unique);
+  BOOST_CHECK(!out_shared_empty);
+  BOOST_CHECK(!out_unique_empty);
+  BOOST_REQUIRE(out_shared);
+  BOOST_REQUIRE(out_unique);
+  BOOST_CHECK_EQUAL(out_shared->ostream, nullptr);
+  BOOST_CHECK_EQUAL(out_unique->ostream, nullptr);
+  BOOST_CHECK_EQUAL(out_shared->istream, &istr);
+  BOOST_CHECK_EQUAL(out_unique->istream, &istr);
+}
+
+struct TestObject {
+  uint64_t a, b;
+  void Serialize(SerialOStream& stream) const { stream.UInt64(a).UInt64(b); }
+  void Unserialize(SerialIStream& stream) { stream.UInt64(a).UInt64(b); }
+  // The Boost checks require operator== and operator!= to be implemented.
+  bool operator==(const TestObject& rhs) const {
+    return a == rhs.a && b == rhs.b;
+  }
+  bool operator!=(const TestObject& rhs) const { return !operator==(rhs); }
+};
+void operator<<(std::ostream& str, const TestObject& obj) {
+  str << "TestObject{" << obj.a << ", " << obj.b << '}';
+}
+
+BOOST_AUTO_TEST_CASE(object) {
+  const TestObject in{42, 4242};
+  SerialOStream ostr;
+  BOOST_CHECK_EQUAL(&ostr.Object(in), &ostr);
+
+  SerialIStream istr(std::move(ostr));
+  TestObject out;
+  BOOST_CHECK_EQUAL(&istr.Object(out), &istr);
+  BOOST_CHECK_EQUAL(out, in);
+}
+
+BOOST_AUTO_TEST_CASE(object_vector) {
+  const std::vector<TestObject> empty;
+  const std::vector<TestObject> filled{{13, 37}, {0, 42}};
+
+  SerialOStream ostr;
+  ostr.ObjectVector(empty)
+      .ObjectVector(filled)
+      .ObjectVector(empty)
+      .ObjectVector(filled);
+
+  SerialIStream istr(std::move(ostr));
+
+  std::vector<TestObject> out_empty1;
+  std::vector<TestObject> out_empty2;
+  std::vector<TestObject> out_filled1;
+  std::vector<TestObject> out_filled2;
+  istr.ObjectVector(out_empty1)
+      .ObjectVector(out_filled1)
+      .ObjectVector(out_empty2)
+      .ObjectVector(out_filled2);
+
+  BOOST_CHECK(out_empty1.empty());
+  BOOST_CHECK_EQUAL_COLLECTIONS(filled.begin(), filled.end(),
+                                out_filled1.begin(), out_filled1.end());
+  BOOST_CHECK(out_empty2.empty());
+  BOOST_CHECK_EQUAL_COLLECTIONS(filled.begin(), filled.end(),
+                                out_filled2.begin(), out_filled2.end());
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tstaticfor.cpp b/external/aocommon/tests/tstaticfor.cpp
new file mode 100644
index 0000000..5bd6560
--- /dev/null
+++ b/external/aocommon/tests/tstaticfor.cpp
@@ -0,0 +1,100 @@
+#include <aocommon/staticfor.h>
+
+#include <mutex>
+
+#include <unistd.h>  // for sleep
+
+#include <boost/test/unit_test.hpp>
+
+using aocommon::StaticFor;
+
+BOOST_AUTO_TEST_SUITE(staticfor)
+
+BOOST_AUTO_TEST_CASE(construct) {
+  StaticFor<size_t> sFor(4);
+  BOOST_CHECK_EQUAL(sFor.NThreads(), 4);
+}
+
+BOOST_AUTO_TEST_CASE(run) {
+  StaticFor<size_t> loop(4);
+  std::mutex mutex;
+  std::vector<size_t> counts(10, 0);
+  loop.Run(0, 10, [&](size_t a, size_t b) {
+    for (size_t iter = a; iter != b; ++iter) {
+      std::unique_lock<std::mutex> lock(mutex);
+      counts[iter]++;
+    }
+  });
+
+  std::vector<size_t> ref(10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(single_threaded) {
+  StaticFor<size_t> loop(1);
+  std::vector<size_t> counts(10, 0);
+  loop.Run(0, 10, [&](size_t a, size_t b) {
+    for (size_t iter = a; iter != b; ++iter) {
+      counts[iter]++;
+    }
+  });
+
+  std::vector<size_t> ref(10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(resume_run) {
+  std::vector<size_t> counts(20, 0);
+  std::mutex mutex;
+  StaticFor<size_t> loop(40);
+  loop.Run(0, 10, [&](size_t a, size_t b) {
+    for (size_t iter = a; iter != b; ++iter) {
+      std::unique_lock<std::mutex> lock(mutex);
+      counts[iter]++;
+    }
+  });
+  std::vector<size_t> ref(20, 0);
+  std::fill(ref.begin(), ref.begin() + 10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+
+  loop.Run(10, 20, [&](size_t a, size_t b) {
+    for (size_t iter = a; iter != b; ++iter) {
+      std::unique_lock<std::mutex> lock(mutex);
+      counts[iter]++;
+    }
+  });
+  ref = std::vector<size_t>(20, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(run_with_thread_id) {
+  StaticFor<size_t> loop(4);
+  std::mutex mutex;
+  std::vector<size_t> counts(10, 0);
+  std::vector<size_t> threads(4, 0);
+  loop.Run(0, 10, [&](size_t a, size_t b, size_t t) {
+    for (size_t iter = a; iter != b; ++iter) {
+      std::unique_lock<std::mutex> lock(mutex);
+      counts[iter]++;
+    }
+    std::unique_lock<std::mutex> lock(mutex);
+    threads[t]++;
+  });
+
+  std::vector<size_t> ref(10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+
+  // Not all threads might actually be used, because if one thread
+  // finishes before a second thread is starting, the first
+  // thread is used to perform the next loop.
+  // Therefore all we can check is whether there weren't more than
+  // 4 blocks:
+  for (size_t i = 0; i != threads.size(); ++i) BOOST_CHECK_LT(threads[i], 5);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tthreadpool.cpp b/external/aocommon/tests/tthreadpool.cpp
new file mode 100644
index 0000000..a24a1b7
--- /dev/null
+++ b/external/aocommon/tests/tthreadpool.cpp
@@ -0,0 +1,78 @@
+#include <iostream>
+#include <cmath>
+
+#include <unistd.h>  // for usleep
+
+#include <aocommon/threadpool.h>
+
+#include <boost/test/unit_test.hpp>
+
+using namespace aocommon;
+
+BOOST_AUTO_TEST_SUITE(threadpool)
+
+BOOST_AUTO_TEST_CASE(empty) {
+  ThreadPool();
+  BOOST_CHECK(true);
+
+  BOOST_CHECK_THROW(ThreadPool(0), std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(single) {
+  ThreadPool pool;
+  std::mutex mutex;
+  std::vector<size_t> counts(10, 0);
+  pool.For(0, 10, [&](size_t iter, size_t) {
+    std::unique_lock<std::mutex> lock(mutex);
+    counts[iter]++;
+  });
+  std::vector<size_t> ref(10, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(recursive) {
+  ThreadPool pool;
+  std::mutex mutex;
+  std::vector<size_t> counts(800, 0);
+  pool.For(0, 100, [&](size_t iter1, size_t) {
+    pool.For(0, 8, [&](size_t iter2, size_t) {
+      std::unique_lock<std::mutex> lock(mutex);
+      counts[iter1 + iter2 * 100]++;
+    });
+  });
+  std::vector<size_t> ref(800, 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(slow_task) {
+  std::mutex mutex;
+  ThreadPool pool;
+  std::vector<size_t> counts(5 * pool.NThreads(), 0);
+  pool.For(0, 5 * pool.NThreads(), [&](size_t iter, size_t) {
+    usleep(1000);
+    std::unique_lock<std::mutex> lock(mutex);
+    counts[iter]++;
+  });
+  std::vector<size_t> ref(5 * pool.NThreads(), 1);
+  BOOST_CHECK_EQUAL_COLLECTIONS(counts.begin(), counts.end(), ref.begin(),
+                                ref.end());
+}
+
+BOOST_AUTO_TEST_CASE(reuse) {
+  ThreadPool pool;
+  for (size_t i = 0; i != 100; ++i) {
+    volatile double x = 0.1;
+    pool.For(0, 100, [&](size_t iter, size_t) { (void)sin(x); });
+  }
+}
+
+BOOST_AUTO_TEST_CASE(set_n_threads) {
+  ThreadPool pool(1);
+  BOOST_CHECK_EQUAL(pool.NThreads(), 1);
+  pool.SetNThreads(4);
+  BOOST_CHECK_EQUAL(pool.NThreads(), 4);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tthrowruntimeerror.cpp b/external/aocommon/tests/tthrowruntimeerror.cpp
new file mode 100644
index 0000000..cffa03d
--- /dev/null
+++ b/external/aocommon/tests/tthrowruntimeerror.cpp
@@ -0,0 +1,21 @@
+#include "aocommon/throwruntimeerror.h"
+
+#include <boost/test/unit_test.hpp>
+
+#include <string>
+
+BOOST_AUTO_TEST_SUITE(throw_runtime_error)
+
+BOOST_AUTO_TEST_CASE(throw_runtime_error) {
+  BOOST_CHECK_EXCEPTION(
+      aocommon::ThrowRuntimeError(), std::runtime_error,
+      [](const std::runtime_error& e) { return e.what() == std::string(); });
+
+  BOOST_CHECK_EXCEPTION(
+      aocommon::ThrowRuntimeError('a', "bc", std::string("def"), 123),
+      std::runtime_error, [](const std::runtime_error& e) {
+        return e.what() == std::string("abcdef123");
+      });
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/ttransform_if.cpp b/external/aocommon/tests/ttransform_if.cpp
new file mode 100644
index 0000000..b1ec15c
--- /dev/null
+++ b/external/aocommon/tests/ttransform_if.cpp
@@ -0,0 +1,153 @@
+#include "aocommon/transform_if.h"
+
+#include <boost/test/unit_test.hpp>
+
+// Since boost test can't do compile-time validation the tests use asserts.
+#ifdef NDEBUG
+#undef NDEBUG
+#endif
+#include <algorithm>
+#include <array>
+#include <cassert>
+
+#if __cplusplus > 201703L
+// std::equal is constexpr since C++20
+using std::equal;
+#else
+template <class InputIt1, class InputIt2>
+#if __cplusplus > 201402L
+constexpr
+#endif
+    bool
+    equal(InputIt1 first1, InputIt1 last1, InputIt2 first2) {
+  while (first1 != last1) {
+    if (!(*first1 == *first2)) {
+      return false;
+    }
+    ++first1;
+    ++first2;
+  }
+  return true;
+}
+#endif
+
+static constexpr std::array<int, 10> kInput{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
+
+BOOST_AUTO_TEST_SUITE(transform_if)
+
+#if __cplusplus > 201402L
+constexpr
+#endif
+    bool
+    TestAllFalse() {
+  std::array<int, 10> output{};
+  std::array<int, 10>::iterator out = aocommon::transform_if(
+      kInput.begin(), kInput.end(), output.begin(), [](int) { return false; },
+      [](int i) { return i; });
+
+  assert(out == output.begin());
+
+  return true;
+}
+
+BOOST_AUTO_TEST_CASE(transform_if_all_false) {
+  TestAllFalse();
+#if __cplusplus > 201402L
+  static_assert(TestAllFalse());
+#endif
+}
+
+#if __cplusplus > 201402L
+constexpr
+#endif
+    bool
+    TestAllTrue() {
+  std::array<int, 10> output{};
+  std::array<int, 10>::iterator out = aocommon::transform_if(
+      kInput.begin(), kInput.end(), output.begin(), [](int) { return true; },
+      [](int i) { return i; });
+
+  assert(out == output.end());
+  assert(equal(kInput.begin(), kInput.end(), output.begin()));
+
+  return true;
+}
+
+BOOST_AUTO_TEST_CASE(transform_if_all_true) {
+  TestAllTrue();
+#if __cplusplus > 201402L
+  static_assert(TestAllTrue());
+#endif
+}
+
+#if __cplusplus > 201402L
+constexpr
+#endif
+    bool
+    TestLessThanFive() {
+  std::array<int, 10> output{};
+  std::array<int, 10>::iterator out = aocommon::transform_if(
+      kInput.begin(), kInput.end(), output.begin(), [](int i) { return i < 5; },
+      [](int i) { return i; });
+
+  assert(out == output.begin() + 5);
+  assert(equal(kInput.begin(), kInput.begin() + 5, output.begin()));
+
+  return true;
+}
+
+BOOST_AUTO_TEST_CASE(transform_if_less_than_five) {
+  TestLessThanFive();
+#if __cplusplus > 201402L
+  static_assert(TestLessThanFive());
+#endif
+}
+
+#if __cplusplus > 201402L
+constexpr
+#endif
+    bool
+    TestLessThanThreeToDouble() {
+  std::array<double, 10> output{};
+  std::array<double, 10>::iterator out = aocommon::transform_if(
+      kInput.begin(), kInput.end(), output.begin(), [](int i) { return i < 3; },
+      [](int i) { return i + 3; });
+
+  assert(out == output.begin() + 3);
+  assert(equal(kInput.begin() + 3, kInput.begin() + 6, output.begin()));
+
+  return true;
+}
+
+BOOST_AUTO_TEST_CASE(transform_if_less_than_three_to_double) {
+  TestLessThanThreeToDouble();
+#if __cplusplus > 201402L
+  static_assert(TestLessThanThreeToDouble());
+#endif
+}
+
+#if __cplusplus > 201402L
+constexpr
+#endif
+    bool
+    TestToUnrelatedType() {
+  constexpr std::array<const char*, 3> kData{"abc", "def", "ghi"};
+  std::array<const char*, 3> output{};
+  std::array<const char*, 3>::iterator out = aocommon::transform_if(
+      kInput.begin(), kInput.end(), output.begin(),
+      [](int i) { return i == 5; }, [&](int i) { return kData[1]; });
+
+  assert(out == output.begin() + 1);
+  assert(output.front() == kData[1]);
+
+  return true;
+}
+
+BOOST_AUTO_TEST_CASE(transform_if_to_unrelated_type) {
+  TestToUnrelatedType();
+#if __cplusplus > 201402L
+  static_assert(TestToUnrelatedType());
+#endif
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/external/aocommon/tests/tuvector.cpp b/external/aocommon/tests/tuvector.cpp
new file mode 100644
index 0000000..a84735a
--- /dev/null
+++ b/external/aocommon/tests/tuvector.cpp
@@ -0,0 +1,672 @@
+#include <iostream>
+
+#include <aocommon/uvector.h>
+
+#include <fstream>
+#include <vector>
+
+#include <boost/test/unit_test.hpp>
+
+BOOST_AUTO_TEST_SUITE(UVector)
+
+template <typename Tp>
+typename aocommon::UVector<Tp>::iterator insert_uninitialized(
+    aocommon::UVector<Tp>& vec,
+    typename aocommon::UVector<Tp>::const_iterator i, size_t count) {
+  return vec.insert_uninitialized(i, count);
+}
+
+template <typename Tp>
+typename std::vector<Tp>::iterator insert_uninitialized(
+    std::vector<Tp>& vec, typename std::vector<Tp>::iterator i, size_t count) {
+  size_t index = i - vec.begin();
+  vec.insert(i, count, Tp());
+  return vec.begin() + index;
+}
+
+template <typename Vec>
+void test() {
+  BOOST_CHECK(Vec().empty());
+  BOOST_CHECK(!Vec(1).empty());
+  BOOST_CHECK(Vec().capacity() == 0);
+  Vec vec(1000);
+  BOOST_CHECK(!vec.empty());
+  BOOST_CHECK(vec.size() == 1000);
+  BOOST_CHECK(vec.capacity() >= 1000);
+
+  vec.push_back(16);
+  BOOST_CHECK(vec.size() == 1001);
+  BOOST_CHECK(vec[1000] == 16);
+
+  vec.push_back(17);
+  BOOST_CHECK(vec.size() == 1002);
+  BOOST_CHECK(vec[1001] == 17);
+
+  vec[0] = 1337;
+  BOOST_CHECK(vec[0] == 1337);
+
+  vec.pop_back();
+  BOOST_CHECK(vec.size() == 1001);
+  BOOST_CHECK(*vec.begin() == 1337);
+  BOOST_CHECK(*(vec.end() - 1) == 16);
+  BOOST_CHECK(*vec.rbegin() == 16);
+  BOOST_CHECK(*(vec.rend() - 1) == 1337);
+
+  vec = Vec(100, 1);
+  BOOST_CHECK(vec.size() == 100);
+  BOOST_CHECK(vec[0] == 1);
+  BOOST_CHECK(vec[99] == 1);
+
+  // construct with range
+  vec[0] = 2;
+  vec[99] = 3;
+  vec = Vec(vec.rbegin(), vec.rend());
+  BOOST_CHECK(vec.size() == 100);
+  BOOST_CHECK(vec[0] == 3);
+  BOOST_CHECK(vec[99] == 2);
+  BOOST_CHECK(vec[1] == 1);
+  BOOST_CHECK(vec[50] == 1);
+
+  // construct with init list
+  const int listA[] = {7, 8, 9};
+  vec = Vec(listA, listA + 3);
+  BOOST_CHECK(vec.size() == 3);
+  BOOST_CHECK(vec[0] == 7);
+  BOOST_CHECK(vec[1] == 8);
+  BOOST_CHECK(vec[2] == 9);
+
+  BOOST_CHECK(Vec(listA, listA + 2).size() == 2);
+  BOOST_CHECK(Vec(listA, listA + 2).size() == 2);
+  BOOST_CHECK(Vec(7, 8).size() == 7);
+
+  // resize
+  vec.resize(5);
+  BOOST_CHECK(vec.size() == 5);
+  BOOST_CHECK(vec[0] == 7);
+  BOOST_CHECK(vec[1] == 8);
+  BOOST_CHECK(vec[2] == 9);
+  vec[4] = 4;
+
+  vec.resize(1000);
+  BOOST_CHECK(vec.size() == 1000);
+  BOOST_CHECK(vec[0] == 7);
+  BOOST_CHECK(vec[1] == 8);
+  BOOST_CHECK(vec[2] == 9);
+  BOOST_CHECK(vec[4] == 4);
+
+  vec.resize(5, 10);
+  BOOST_CHECK(vec.size() == 5);
+  vec.resize(1000, 10);
+  BOOST_CHECK(vec.size() == 1000);
+  BOOST_CHECK(vec[0] == 7);
+  BOOST_CHECK(vec[1] == 8);
+  BOOST_CHECK(vec[2] == 9);
+  BOOST_CHECK(vec[4] == 4);
+  BOOST_CHECK(vec[5] == 10);
+  BOOST_CHECK(vec[999] == 10);
+  BOOST_CHECK(vec.capacity() >= 1000);
+
+  // resize that changes capacity
+  Vec().swap(vec);
+  vec.resize(5, 10);
+  BOOST_CHECK_EQUAL(vec.size(), 5);
+  vec.resize(1000, 10);
+  BOOST_CHECK_EQUAL(vec.size(), 1000);
+
+  // reserve
+  vec.reserve(0);
+  BOOST_CHECK(vec.capacity() >= 1000);
+  vec = Vec();
+  vec.reserve(1000);
+  BOOST_CHECK(vec.size() == 0);
+  BOOST_CHECK(vec.capacity() >= 1000);
+
+  // shrink_to_fit
+  vec.resize(1000, 3);
+  vec.resize(5);
+  vec.shrink_to_fit();
+  BOOST_CHECK_EQUAL(vec.size(), 5);
+
+  vec = Vec();
+  vec.shrink_to_fit();
+  BOOST_CHECK_EQUAL(vec.size(), 0);
+  BOOST_CHECK_EQUAL(vec.capacity(), 0);
+
+  vec.push_back(3);
+  vec.push_back(7);
+  vec.shrink_to_fit();
+  BOOST_CHECK_EQUAL(vec.size(), 2);
+  BOOST_CHECK_EQUAL(vec.capacity(), 2);
+  BOOST_CHECK_EQUAL(vec[0], 3);
+  BOOST_CHECK_EQUAL(vec[1], 7);
+
+  // at
+  BOOST_CHECK(vec.at(0) == 3);
+  BOOST_CHECK(vec.at(1) == 7);
+  try {
+    vec.at(2);
+    BOOST_CHECK(false);
+  } catch (...) {
+    BOOST_CHECK(true);
+  }
+  try {
+    vec.at(-1);
+    BOOST_CHECK(false);
+  } catch (...) {
+    BOOST_CHECK(true);
+  }
+
+  // assign
+  vec.push_back(0);
+  Vec temp = vec;
+  vec.assign(temp.rbegin() + 1, temp.rend());
+  BOOST_CHECK(vec.size() == 2);
+  BOOST_CHECK(vec[0] == 7);
+  BOOST_CHECK(vec[1] == 3);
+
+  vec.assign(10, 1337);
+  BOOST_CHECK(vec.size() == 10);
+  BOOST_CHECK(vec[0] == 1337);
+  BOOST_CHECK(vec[9] == 1337);
+
+  vec = Vec();
+  const int listB[] = {1, 2, 3, 5, 7, 9};
+  vec.assign(listB, listB + 6);
+  BOOST_CHECK(vec.size() == 6);
+  BOOST_CHECK(vec[0] == 1);
+  BOOST_CHECK(vec[1] == 2);
+  BOOST_CHECK(vec[5] == 9);
+
+  // insert
+  vec = Vec(1000);
+  vec.push_back(16);
+  BOOST_CHECK(vec.insert(vec.begin() + 1001, 42) - vec.begin() == 1001);
+  BOOST_CHECK(vec.insert(vec.begin() + 1001, 37) - vec.begin() == 1001);
+  BOOST_CHECK(vec.size() == 1003);
+  BOOST_CHECK(vec[1000] == 16);
+  BOOST_CHECK(vec[1001] == 37);
+  BOOST_CHECK(vec[1002] == 42);
+
+  // GNU C++ doesn't return something yet, so skip for now
+  // BOOST_CHECK(vec.insert(vec.begin()+1001, 3, 3) == vec.begin() + 1001,
+  // "insert()");
+  vec.insert(vec.begin() + 1001, 3, 3);
+  BOOST_CHECK(vec[1000] == 16);
+  BOOST_CHECK(vec[1001] == 3);
+  BOOST_CHECK(vec[1002] == 3);
+  BOOST_CHECK(vec[1003] == 3);
+  BOOST_CHECK(vec[1004] == 37);
+
+  vec = Vec();
+  BOOST_CHECK(vec.capacity() ==
+              0);  // to make sure inserts are going to increment size
+  for (size_t i = 0; i != 100; ++i) {
+    vec.insert(vec.begin(), 1);
+    vec.insert(vec.begin() + (vec.size() - 1) / 3 + 1, 2);
+    vec.insert(vec.end(), 3);
+  }
+  bool allCorrect[3] = {true, true, true};
+  for (size_t i = 0; i != 100; ++i) {
+    allCorrect[0] = allCorrect[0] && (vec[i] == 1);
+    allCorrect[1] = allCorrect[1] && (vec[i + vec.size() / 3] == 2);
+    allCorrect[2] = allCorrect[2] && (vec[i + vec.size() * 2 / 3] == 3);
+  }
+  BOOST_CHECK(allCorrect[0]);
+  BOOST_CHECK(allCorrect[1]);
+  BOOST_CHECK(allCorrect[2]);
+
+  const int listC[] = {1, 2, 3, 4, 5};
+  temp = Vec(listC, listC + 5);
+  vec = Vec();
+  for (size_t i = 0; i != 100; ++i) {
+    vec.insert(vec.begin(), temp.begin(), temp.end());
+    vec.insert(vec.begin() + (vec.size() - 5) / 3 + 5, temp.rbegin(),
+               temp.rend());
+    vec.insert(vec.end(), temp.begin(), temp.end());
+  }
+  BOOST_CHECK(vec.size() == 100 * 15);
+  for (size_t i = 0; i != 100; ++i) {
+    for (int j = 0; j != 5; ++j) {
+      allCorrect[0] = allCorrect[0] && vec[i * 5 + j] == j + 1;
+      allCorrect[1] = allCorrect[1] && vec[i * 5 + vec.size() / 3 + j] == 5 - j;
+      allCorrect[2] =
+          allCorrect[2] && vec[i * 5 + vec.size() * 2 / 3 + j] == j + 1;
+    }
+  }
+  BOOST_CHECK(allCorrect[0]);
+  BOOST_CHECK(allCorrect[1]);
+  BOOST_CHECK(allCorrect[2]);
+
+  vec = Vec(2, 1);
+  vec[1] = 4;
+  vec.insert(vec.begin() + 1, 3);
+  vec.insert(vec.begin() + 1, 2);
+  BOOST_CHECK(vec[0] == 1);
+  BOOST_CHECK(vec[1] == 2);
+  BOOST_CHECK(vec[2] == 3);
+  BOOST_CHECK(vec[3] == 4);
+
+  typename Vec::iterator insert_iter = vec.insert(vec.begin() + 2, 1000, 7);
+  BOOST_CHECK_EQUAL(insert_iter - vec.begin(), 2);
+  BOOST_CHECK_EQUAL(vec.size(), 1004);
+
+  // insert_uninitialized
+  vec = Vec(1000);
+  vec.push_back(16);
+  BOOST_CHECK_EQUAL(
+      insert_uninitialized(vec, vec.begin() + 1001, 1) - vec.begin(), 1001);
+  BOOST_CHECK_EQUAL(
+      insert_uninitialized(vec, vec.begin() + 1001, 1) - vec.begin(), 1001);
+  BOOST_CHECK_EQUAL(vec.size(), 1003);
+  BOOST_CHECK_EQUAL(vec[1000], 16);
+
+  // insert_uninitialized with (likely) capacity change
+  typename Vec::iterator uinsert_iter =
+      insert_uninitialized(vec, vec.begin() + 1003, 5000);
+  BOOST_CHECK_EQUAL(uinsert_iter - vec.begin(), 1003);
+
+  vec[1001] = 37;
+  // GNU C++ doesn't return something yet, so skip for now
+  // BOOST_CHECK(insert_uninitialized(vec, vec.begin()+1001, 3, 3) ==
+  // vec.begin() + 1001, "insert()");
+  insert_uninitialized(vec, vec.begin() + 1001, 3);
+  BOOST_CHECK(vec[1000] == 16);
+  BOOST_CHECK(vec[1004] == 37);
+
+  // Erase
+  const int listD[] = {1, 2, 3, 4};
+  vec = Vec(listD, listD + 4);
+  typename Vec::iterator iter = vec.erase(vec.begin() + 1);
+  BOOST_CHECK(iter == vec.begin() + 1);
+  BOOST_CHECK(vec.size() == 3);
+  BOOST_CHECK(vec[0] == 1);
+  BOOST_CHECK(vec[1] == 3);
+  BOOST_CHECK(vec[2] == 4);
+  iter = vec.erase(vec.begin() + 2);
+  BOOST_CHECK(iter == vec.end());
+  BOOST_CHECK(vec.size() == 2);
+  BOOST_CHECK(vec[0] == 1);
+  BOOST_CHECK(vec[1] == 3);
+
+  iter = vec.erase(vec.begin(), vec.end());
+  BOOST_CHECK(iter == vec.end());
+  BOOST_CHECK(vec.empty());
+  vec = Vec(listD, listD + 4);
+  iter = vec.erase(vec.begin() + 1, vec.end() - 1);
+  BOOST_CHECK(iter == vec.begin() + 1);
+  BOOST_CHECK(vec.size() == 2);
+
+  // Swap
+  const int listE[] = {5, 6, 7};
+  temp = Vec(listE, listE + 3);
+  iter = temp.begin();
+  vec = Vec(listD, listD + 4);
+  vec.swap(temp);
+  BOOST_CHECK(vec.size() == 3);
+  BOOST_CHECK(temp.size() == 4);
+  BOOST_CHECK(*iter == 5);
+  BOOST_CHECK(vec[0] == 5);
+  BOOST_CHECK(vec.back() == 7);
+
+  // Clear
+  vec = Vec();
+  vec.clear();
+  BOOST_CHECK(vec.empty());
+  vec = Vec(listD, listD + 4);
+  vec.clear();
+  BOOST_CHECK(vec.empty());
+  vec.push_back(5);
+  BOOST_CHECK(vec.size() == 1);
+  BOOST_CHECK(vec.front() == 5);
+
+  // Emplace
+  vec = Vec(2, 1);
+  vec[1] = 3;
+  iter = vec.insert(vec.begin() + 1, 2);
+  BOOST_CHECK(iter == vec.begin() + 1);
+  BOOST_CHECK(vec.size() == 3);
+  BOOST_CHECK(vec[0] == 1);
+  BOOST_CHECK(vec[1] == 2);
+  BOOST_CHECK(vec[2] == 3);
+
+  // operator==
+  BOOST_CHECK(Vec() == Vec());
+  BOOST_CHECK(!(Vec(1) == Vec()));
+  vec = Vec();
+  vec.push_back(7);
+  vec.pop_back();
+  BOOST_CHECK(vec == Vec());
+  const int listF[] = {1, 2, 3, 4, 5}, listG[] = {1, 2, 3, 4, 6};
+  BOOST_CHECK(Vec(listF, listF + 5) == Vec(listF, listF + 5));
+  BOOST_CHECK(!(Vec(listF, listF + 5) == Vec(listG, listG + 5)));
+  BOOST_CHECK(!(Vec(listF, listF + 4) == Vec(listF, listF + 5)));
+
+  // operator!=
+  BOOST_CHECK(!(Vec() != Vec()));
+  BOOST_CHECK(Vec(1) != Vec());
+  vec = Vec();
+  vec.push_back(7);
+  vec.pop_back();
+  BOOST_CHECK(!(vec != Vec()));
+  BOOST_CHECK(!(Vec(listF, listF + 5) != Vec(listF, listF + 5)));
+  BOOST_CHECK(Vec(listF, listF + 5) != Vec(listG, listG + 5));
+  BOOST_CHECK(Vec(listF, listF + 4) != Vec(listF, listF + 5));
+
+  // operator<
+  BOOST_CHECK(!(Vec() < Vec()));
+  BOOST_CHECK(!(Vec(1, 1) < Vec(1, 1)));
+  BOOST_CHECK(!(Vec(1, 2) < Vec(1, 1)));
+  BOOST_CHECK(Vec() < Vec(1, 1));
+  BOOST_CHECK(!(Vec(1, 1) < Vec()));
+  BOOST_CHECK(Vec(1, 1) < Vec(1, 2));
+  const int listH[] = {1, 2, 4};
+  BOOST_CHECK(Vec(listF, listF + 3) < Vec(listH, listH + 3));
+
+  // operator>
+  BOOST_CHECK(!(Vec() > Vec()));
+  BOOST_CHECK(!(Vec(1, 1) > Vec(1, 1)));
+  BOOST_CHECK(!(Vec(1, 1) > Vec(1, 2)));
+  BOOST_CHECK(Vec(listH, listH + 3) > Vec(listF, listF + 3));
+
+  // operator<=
+  BOOST_CHECK(Vec() <= Vec());
+  BOOST_CHECK(Vec(1, 1) <= Vec(1, 1));
+  BOOST_CHECK(!(Vec(1, 2) <= Vec(1, 1)));
+  BOOST_CHECK(Vec() <= Vec(1, 1));
+  BOOST_CHECK(!(Vec(1, 1) <= Vec()));
+  BOOST_CHECK(Vec(1, 1) <= Vec(1, 2));
+  BOOST_CHECK(Vec(listF, listF + 3) <= Vec(listH, listH + 3));
+
+  // operator>=
+  BOOST_CHECK(Vec() >= Vec());
+  BOOST_CHECK(Vec(1, 1) >= Vec(1, 1));
+  BOOST_CHECK(!(Vec(1, 1) >= Vec(1, 2)));
+  BOOST_CHECK(Vec(1, 1) >= Vec());
+  BOOST_CHECK(!(Vec() >= Vec(1, 1)));
+  BOOST_CHECK(Vec(1, 2) >= Vec(1, 1));
+  BOOST_CHECK(Vec(listH, listH + 3) >= Vec(listF, listF + 3));
+
+  // ::swap
+  const int listI[] = {100, 101, 102};
+  temp = Vec(listI, listI + 3);
+  swap(temp, vec);
+  BOOST_CHECK(vec.size() == 3);
+  BOOST_CHECK(vec[0] == 100);
+  BOOST_CHECK(vec[1] == 101);
+  BOOST_CHECK(vec[2] == 102);
+}
+
+template <typename Tp>
+class FailingAllocator {
+ public:
+  typedef Tp value_type;
+  typedef std::size_t size_type;
+  typedef Tp* pointer;
+  FailingAllocator() {}
+  FailingAllocator(bool fail) { _failAllocation = fail; }
+  void SetFailAllocation(bool fail) { _failAllocation = fail; }
+  bool operator==(const FailingAllocator<Tp>&) { return true; }
+  pointer allocate(size_type n,
+                   std::allocator<void>::const_pointer hint = nullptr) {
+    if (_failAllocation) throw std::bad_alloc();
+    return static_cast<pointer>(malloc(n * sizeof(Tp)));
+  }
+  void deallocate(pointer ptr, size_type n) { free(ptr); }
+
+ private:
+  static bool _failAllocation;
+};
+
+template <typename Tp>
+bool FailingAllocator<Tp>::_failAllocation = false;
+
+template <typename Vec>
+void testBadAllocs() {
+  // typedef typename std::allocator_traits<typename
+  // Vec::allocator_type>::propagate_on_container_copy_assignment DoCopy;
+  // typedef typename std::allocator_traits<typename
+  // Vec::allocator_type>::propagate_on_container_move_assignment DoMove;
+  // typedef typename std::allocator_traits<typename
+  // Vec::allocator_type>::propagate_on_container_swap DoSwap; std::cout <<
+  //	"Propogate on copy assignment: " << DoCopy().value << "\n"
+  //	"Propogate on move assignment: " << DoMove().value << "\n"
+  //	"Propogate on swap: " << DoSwap().value << "\n";
+
+  Vec(5, 0, FailingAllocator<int>(false));
+  try {
+    Vec(5, 0, FailingAllocator<int>(true));
+    BOOST_CHECK(false);
+  } catch (...) {
+    BOOST_CHECK(true);
+  }
+
+  aocommon::UVector<int> goodVec;
+
+  const int ListA[] = {6, 7, 8, 9};
+  Vec vec(FailingAllocator<int>(false));
+  vec.assign(ListA, ListA + 4);
+  goodVec.assign(ListA, ListA + 4);
+  vec.get_allocator().SetFailAllocation(true);
+  try {
+    for (size_t i = 0; i != 10000; ++i) {
+      vec.push_back(i);
+      goodVec.push_back(i);
+    }
+    BOOST_CHECK(false);
+  } catch (...) {
+    BOOST_CHECK(true);
+  }
+  BOOST_CHECK(vec.size() == goodVec.size());
+  BOOST_CHECK(vec.front() == goodVec.front());
+  BOOST_CHECK(vec.back() == goodVec.back());
+
+  vec.get_allocator().SetFailAllocation(false);
+  vec = Vec();
+  vec.reserve(1000);
+  vec.push_back(1);
+  vec.get_allocator().SetFailAllocation(true);
+  try {
+    vec.shrink_to_fit();
+    // shrink to fit is not required to resize
+    // BOOST_CHECK(false);
+  } catch (...) {
+    BOOST_CHECK(true);
+  }
+  BOOST_CHECK(vec.size() == 1);
+  BOOST_CHECK(vec[0] == 1);
+  vec.get_allocator().SetFailAllocation(false);
+  vec.pop_back();
+  vec.shrink_to_fit();
+  vec.push_back(1);
+
+  vec.get_allocator().SetFailAllocation(true);
+  try {
+    vec.insert(vec.begin(), 1000, 0);
+    BOOST_CHECK(false);
+  } catch (...) {
+    BOOST_CHECK(true);
+  }
+  BOOST_CHECK(vec.size() == 1);
+  BOOST_CHECK(vec[0] == 1);
+}
+
+template <typename Tp, typename Propagate_on_container_copy = std::true_type,
+          typename Propagate_on_container_move = std::true_type>
+class IdAllocater {
+ public:
+  typedef IdAllocater<Tp, Propagate_on_container_copy,
+                      Propagate_on_container_move>
+      Myself;
+  typedef std::size_t size_type;
+  typedef Tp value_type;
+  typedef Tp* pointer;
+  typedef std::true_type propagate_on_container_swap;
+  typedef Propagate_on_container_copy propagate_on_container_copy_assignment;
+  typedef Propagate_on_container_move propagate_on_container_move_assignment;
+  IdAllocater(size_t id) : _id(id) {}
+  bool operator==(const Myself& rhs) const { return rhs._id == _id; }
+  bool operator!=(const Myself& rhs) const { return rhs._id != _id; }
+  Myself& operator=(const IdAllocater<Tp>& rhs) {
+    _id = rhs._id;
+    return *this;
+  }
+  Myself select_on_container_copy_construction() const {
+    return IdAllocater(_id + 10);
+  }
+  size_t Id() const { return _id; }
+  pointer allocate(size_type n,
+                   std::allocator<void>::const_pointer hint = nullptr) {
+    char* mem = static_cast<char*>(malloc(n * sizeof(Tp) + sizeof(_id)));
+    *reinterpret_cast<size_t*>(mem) = _id;
+    return reinterpret_cast<pointer>(mem + sizeof(_id));
+  }
+  void deallocate(pointer ptr, size_type n) {
+    char* mem = reinterpret_cast<char*>(ptr) - sizeof(_id);
+    size_t allocId = *reinterpret_cast<size_t*>(mem);
+    if (allocId == _id) {
+      BOOST_CHECK(true);
+    } else {
+      throw std::runtime_error(
+          "\nDeallocation error: Allocator id of allocation (" +
+          std::to_string(allocId) +
+          ") is different from allocator id of deallocation (" +
+          std::to_string(_id) + ")\n");
+    }
+    free(mem);
+  }
+
+ private:
+  size_t _id;
+};
+
+template <typename Vec>
+void testAllocater() {
+  Vec vecA(3, 0, IdAllocater<int>(4)), vecB(3, 0, IdAllocater<int>(5)),
+      vecC(vecA);  // select_on_container_copy_construction will add 10 to id
+  vecA[0] = 1;
+  vecA[1] = 2;
+  vecA[2] = 3;
+  vecB[0] = 11;
+  vecB[1] = 12;
+  vecB[2] = 13;
+  BOOST_CHECK(vecA.get_allocator().Id() == 4);
+  BOOST_CHECK(vecB.get_allocator().Id() == 5);
+  BOOST_CHECK(vecC.get_allocator().Id() == 14);
+  swap(vecA, vecB);
+  BOOST_CHECK(vecA.get_allocator().Id() == 5);
+  BOOST_CHECK(vecB.get_allocator().Id() == 4);
+  BOOST_CHECK(vecA[0] == 11);
+  BOOST_CHECK(vecB[0] == 1);
+  vecC = Vec(3, 0, IdAllocater<int>(6));
+  vecC[0] = 21;
+  vecC[1] = 22;
+  vecC[2] = 23;
+  BOOST_CHECK(vecC.get_allocator().Id() == 6);
+  BOOST_CHECK(vecC[0] == 21);
+  vecC = std::move(vecA);
+  BOOST_CHECK(vecC.get_allocator().Id() == 5);
+  BOOST_CHECK(vecC[0] == 11);
+  Vec vecD(std::move(vecC));
+  BOOST_CHECK(vecD.get_allocator().Id() == 5);
+  BOOST_CHECK(vecD[0] == 11);
+
+  class A {};
+  A a1, a2;
+  std::swap(a1, a2);
+}
+
+template <typename Vec>
+void testExtensions() {
+  // push_back(n, val)
+  Vec vecA(1, 31);
+  vecA.push_back(2, 1337);
+  BOOST_CHECK(vecA.size() == 3);
+  BOOST_CHECK(vecA[0] == 31);
+  BOOST_CHECK(vecA[1] == 1337);
+  BOOST_CHECK(vecA[2] == 1337);
+
+  // push_back(initializer list)
+  Vec vecB;
+  const int listA[] = {1, 2, 3}, listC[] = {4, 5, 6};
+  vecB.push_back(listA, listA + 3);
+  BOOST_CHECK(vecB.size() == 3);
+  BOOST_CHECK(vecB[0] == 1);
+  BOOST_CHECK(vecB[1] == 2);
+  BOOST_CHECK(vecB[2] == 3);
+  vecB.push_back(listC, listC + 3);
+  BOOST_CHECK(vecB.size() == 6);
+  for (int i = 0; i != 6; ++i) BOOST_CHECK(vecB[i] == i + 1);
+
+  // push_back(range)
+  const int listB[] = {9, 11, 12, 13};
+  vecB = Vec(listB, listB + 4);
+  Vec vecC(1, 10);
+  vecC.push_back(vecB.begin() + 1, vecB.end() - 1);
+  BOOST_CHECK(vecC.size() == 3);
+  BOOST_CHECK(vecC[0] == 10);
+  BOOST_CHECK(vecC[1] == 11);
+  BOOST_CHECK(vecC[2] == 12);
+
+  // push_back_uninitialized(n)
+  Vec vecD(1, 42);
+  vecD.push_back_uninitialized(2);
+  BOOST_CHECK(vecD.size() == 3);
+  BOOST_CHECK(vecD[0] == 42);
+}
+
+template <typename Vec>
+void testAllocatorPropagation() {
+  // These vectors should NOT propagate on copy:
+  Vec vecA(3, 0, IdAllocater<int, std::false_type, std::false_type>(4)),
+      vecB(3, 0, IdAllocater<int, std::false_type, std::false_type>(5));
+  Vec vecC(vecA);
+  BOOST_CHECK_EQUAL(vecA.get_allocator().Id(), 4);
+  BOOST_CHECK_EQUAL(vecB.get_allocator().Id(), 5);
+  BOOST_CHECK_EQUAL(vecC.get_allocator().Id(), 14);
+  BOOST_CHECK_EQUAL_COLLECTIONS(vecA.begin(), vecA.end(), vecC.begin(),
+                                vecC.end());
+  vecC = vecB;
+  BOOST_CHECK_EQUAL(vecA.get_allocator().Id(), 4);
+  BOOST_CHECK_EQUAL(vecB.get_allocator().Id(), 5);
+  BOOST_CHECK_EQUAL(vecC.get_allocator().Id(), 14);
+  BOOST_CHECK_EQUAL_COLLECTIONS(vecB.begin(), vecB.end(), vecC.begin(),
+                                vecC.end());
+  Vec bigvec(1000, 1, IdAllocater<int, std::false_type, std::false_type>(7));
+  vecA = bigvec;
+  BOOST_CHECK_EQUAL(vecA.get_allocator().Id(), 4);
+  BOOST_CHECK_EQUAL_COLLECTIONS(vecA.begin(), vecA.end(), bigvec.begin(),
+                                bigvec.end());
+
+  vecA = Vec(3, 0, IdAllocater<int, std::false_type, std::false_type>(4));
+  vecC = vecA;
+  vecB = std::move(vecA);
+  BOOST_CHECK_EQUAL(vecB.get_allocator().Id(), 5);
+  BOOST_CHECK_EQUAL_COLLECTIONS(vecB.begin(), vecB.end(), vecC.begin(),
+                                vecC.end());
+  vecC = bigvec;
+  vecB = std::move(bigvec);
+  BOOST_CHECK_EQUAL(vecB.get_allocator().Id(), 5);
+  BOOST_CHECK_EQUAL_COLLECTIONS(vecB.begin(), vecB.end(), vecC.begin(),
+                                vecC.end());
+}
+
+BOOST_AUTO_TEST_CASE(std_vector_int) { test<std::vector<int>>(); }
+BOOST_AUTO_TEST_CASE(uvector_int) { test<aocommon::UVector<int>>(); }
+BOOST_AUTO_TEST_CASE(uvector_long_int) { test<aocommon::UVector<long int>>(); }
+BOOST_AUTO_TEST_CASE(std_vector_allocator) {
+  testBadAllocs<std::vector<int, FailingAllocator<int>>>();
+  testAllocater<std::vector<int, IdAllocater<int>>>();
+  testAllocatorPropagation<
+      std::vector<int, IdAllocater<int, std::false_type, std::false_type>>>();
+}
+BOOST_AUTO_TEST_CASE(uvector_allocator) {
+  testBadAllocs<aocommon::UVector<int, FailingAllocator<int>>>();
+  testAllocater<aocommon::UVector<int, IdAllocater<int>>>();
+  testAllocatorPropagation<aocommon::UVector<
+      int, IdAllocater<int, std::false_type, std::false_type>>>();
+}
+BOOST_AUTO_TEST_CASE(uvector_extensions) {
+  testExtensions<aocommon::UVector<int>>();
+}
+
+BOOST_AUTO_TEST_SUITE_END()
