Index: wsclean/external/schaapcommon/.clang-format
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/.clang-format
@@ -0,0 +1,157 @@
+---
+Language:        Cpp
+# BasedOnStyle:  Google
+AccessModifierOffset: -1
+AlignAfterOpenBracket: Align
+AlignConsecutiveMacros: false
+AlignConsecutiveAssignments: false
+AlignConsecutiveDeclarations: false
+AlignEscapedNewlines: Left
+AlignOperands:   true
+AlignTrailingComments: true
+AllowAllArgumentsOnNextLine: true
+AllowAllConstructorInitializersOnNextLine: true
+AllowAllParametersOfDeclarationOnNextLine: true
+AllowShortBlocksOnASingleLine: false
+AllowShortCaseLabelsOnASingleLine: false
+AllowShortFunctionsOnASingleLine: All
+AllowShortLambdasOnASingleLine: All
+AllowShortIfStatementsOnASingleLine: WithoutElse
+AllowShortLoopsOnASingleLine: true
+AlwaysBreakAfterDefinitionReturnType: None
+AlwaysBreakAfterReturnType: None
+AlwaysBreakBeforeMultilineStrings: true
+AlwaysBreakTemplateDeclarations: Yes
+BinPackArguments: true
+BinPackParameters: true
+BraceWrapping:
+  AfterCaseLabel:  false
+  AfterClass:      false
+  AfterControlStatement: false
+  AfterEnum:       false
+  AfterFunction:   false
+  AfterNamespace:  false
+  AfterObjCDeclaration: false
+  AfterStruct:     false
+  AfterUnion:      false
+  AfterExternBlock: false
+  BeforeCatch:     false
+  BeforeElse:      false
+  IndentBraces:    false
+  SplitEmptyFunction: true
+  SplitEmptyRecord: true
+  SplitEmptyNamespace: true
+BreakBeforeBinaryOperators: None
+BreakBeforeBraces: Attach
+BreakBeforeInheritanceComma: false
+BreakInheritanceList: BeforeColon
+BreakBeforeTernaryOperators: true
+BreakConstructorInitializersBeforeComma: false
+BreakConstructorInitializers: BeforeColon
+BreakAfterJavaFieldAnnotations: false
+BreakStringLiterals: true
+ColumnLimit:     80
+CommentPragmas:  '^ IWYU pragma:'
+CompactNamespaces: false
+ConstructorInitializerAllOnOneLineOrOnePerLine: true
+ConstructorInitializerIndentWidth: 4
+ContinuationIndentWidth: 4
+Cpp11BracedListStyle: true
+DerivePointerAlignment: false
+DisableFormat:   false
+ExperimentalAutoDetectBinPacking: false
+FixNamespaceComments: true
+ForEachMacros:
+  - foreach
+  - Q_FOREACH
+  - BOOST_FOREACH
+IncludeBlocks:   Regroup
+IncludeCategories:
+  - Regex:           '^<ext/.*\.h>'
+    Priority:        2
+  - Regex:           '^<.*\.h>'
+    Priority:        1
+  - Regex:           '^<.*'
+    Priority:        2
+  - Regex:           '.*'
+    Priority:        3
+IncludeIsMainRegex: '([-_](test|unittest))?$'
+IndentCaseLabels: true
+IndentPPDirectives: None
+IndentWidth:     2
+IndentWrappedFunctionNames: false
+JavaScriptQuotes: Leave
+JavaScriptWrapImports: true
+KeepEmptyLinesAtTheStartOfBlocks: false
+MacroBlockBegin: ''
+MacroBlockEnd:   ''
+MaxEmptyLinesToKeep: 1
+NamespaceIndentation: None
+ObjCBinPackProtocolList: Never
+ObjCBlockIndentWidth: 2
+ObjCSpaceAfterProperty: false
+ObjCSpaceBeforeProtocolList: true
+PenaltyBreakAssignment: 2
+PenaltyBreakBeforeFirstCallParameter: 1
+PenaltyBreakComment: 300
+PenaltyBreakFirstLessLess: 120
+PenaltyBreakString: 1000
+PenaltyBreakTemplateDeclaration: 10
+PenaltyExcessCharacter: 1000000
+PenaltyReturnTypeOnItsOwnLine: 200
+PointerAlignment: Left
+RawStringFormats:
+  - Language:        Cpp
+    Delimiters:
+      - cc
+      - CC
+      - cpp
+      - Cpp
+      - CPP
+      - 'c++'
+      - 'C++'
+    CanonicalDelimiter: ''
+    BasedOnStyle:    google
+  - Language:        TextProto
+    Delimiters:
+      - pb
+      - PB
+      - proto
+      - PROTO
+    EnclosingFunctions:
+      - EqualsProto
+      - EquivToProto
+      - PARSE_PARTIAL_TEXT_PROTO
+      - PARSE_TEST_PROTO
+      - PARSE_TEXT_PROTO
+      - ParseTextOrDie
+      - ParseTextProtoOrDie
+    CanonicalDelimiter: ''
+    BasedOnStyle:    google
+ReflowComments:  true
+SortIncludes:    false
+SortUsingDeclarations: true
+SpaceAfterCStyleCast: false
+SpaceAfterLogicalNot: false
+SpaceAfterTemplateKeyword: true
+SpaceBeforeAssignmentOperators: true
+SpaceBeforeCpp11BracedList: false
+SpaceBeforeCtorInitializerColon: true
+SpaceBeforeInheritanceColon: true
+SpaceBeforeParens: ControlStatements
+SpaceBeforeRangeBasedForLoopColon: true
+SpaceInEmptyParentheses: false
+SpacesBeforeTrailingComments: 2
+SpacesInAngles:  false
+SpacesInContainerLiterals: true
+SpacesInCStyleCastParentheses: false
+SpacesInParentheses: false
+SpacesInSquareBrackets: false
+Standard:        c++11
+StatementMacros:
+  - Q_UNUSED
+  - QT_REQUIRE_VERSION
+TabWidth:        8
+UseTab:          Never
+...
+
Index: wsclean/external/schaapcommon/.clang-tidy
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/.clang-tidy
@@ -0,0 +1,88 @@
+---
+Checks:          'clang-diagnostic-*,clang-analyzer-*,-*,modernize-use-equals-default,modernize-use-emplace,modernize-loop-convert,modernize-use-nullptr,modernize-use-override,modernize-use-using,modernize-return-braced-init-list,modernize-deprecated-headers,modernize-make-shared,google-explicit-constructor,google-build-using-namespace,google-readability-braces-around-statements,fuchsia-header-anon-namespaces'
+WarningsAsErrors: ''
+HeaderFilterRegex: 'include/schaapcommon'
+AnalyzeTemporaryDtors: false
+FormatStyle:     none
+User:            maljaars
+CheckOptions:
+  - key:             modernize-loop-convert.MakeReverseRangeHeader
+    value:           ''
+  - key:             modernize-loop-convert.MinConfidence
+    value:           reasonable
+  - key:             modernize-replace-auto-ptr.IncludeStyle
+    value:           llvm
+  - key:             google-readability-namespace-comments.ShortNamespaceLines
+    value:           '10'
+  - key:             cert-oop54-cpp.WarnOnlyIfThisHasSuspiciousField
+    value:           '0'
+  - key:             cppcoreguidelines-non-private-member-variables-in-classes.IgnoreClassesWithAllMemberVariablesBeingPublic
+    value:           '1'
+  - key:             cert-dcl16-c.NewSuffixes
+    value:           'L;LL;LU;LLU'
+  - key:             modernize-use-override.IgnoreDestructors
+    value:           'false'
+  - key:             modernize-loop-convert.MaxCopySize
+    value:           '16'
+  - key:             google-readability-namespace-comments.SpacesBeforeComments
+    value:           '2'
+  - key:             modernize-make-shared.MakeSmartPtrFunction
+    value:           'std::make_shared'
+  - key:             modernize-loop-convert.UseCxx20ReverseRanges
+    value:           'true'
+  - key:             modernize-use-override.FinalSpelling
+    value:           final
+  - key:             modernize-use-using.IgnoreMacros
+    value:           'true'
+  - key:             cppcoreguidelines-explicit-virtual-functions.IgnoreDestructors
+    value:           '1'
+  - key:             modernize-make-shared.MakeSmartPtrFunctionHeader
+    value:           '<memory>'
+  - key:             llvm-qualified-auto.AddConstToQualified
+    value:           '0'
+  - key:             modernize-loop-convert.NamingStyle
+    value:           CamelCase
+  - key:             modernize-use-emplace.ContainersWithPushBack
+    value:           '::std::vector;::std::list;::std::deque'
+  - key:             modernize-loop-convert.MakeReverseRangeFunction
+    value:           ''
+  - key:             modernize-use-override.AllowOverrideAndFinal
+    value:           'false'
+  - key:             google-readability-function-size.StatementThreshold
+    value:           '800'
+  - key:             llvm-else-after-return.WarnOnConditionVariables
+    value:           '0'
+  - key:             modernize-use-override.OverrideSpelling
+    value:           override
+  - key:             modernize-loop-convert.IncludeStyle
+    value:           llvm
+  - key:             cert-str34-c.DiagnoseSignedUnsignedCharComparisons
+    value:           '0'
+  - key:             modernize-pass-by-value.IncludeStyle
+    value:           llvm
+  - key:             modernize-use-equals-default.IgnoreMacros
+    value:           'true'
+  - key:             fuchsia-header-anon-namespaces.HeaderFileExtensions
+    value:           ';h;hh;hpp;hxx'
+  - key:             google-readability-braces-around-statements.ShortStatementLines
+    value:           '1'
+  - key:             modernize-use-emplace.IgnoreImplicitConstructors
+    value:           'false'
+  - key:             modernize-use-nullptr.NullMacros
+    value:           'NULL'
+  - key:             modernize-use-emplace.SmartPointers
+    value:           '::std::shared_ptr;::std::unique_ptr;::std::auto_ptr;::std::weak_ptr'
+  - key:             modernize-make-shared.IgnoreMacros
+    value:           'true'
+  - key:             modernize-use-emplace.TupleTypes
+    value:           '::std::pair;::std::tuple'
+  - key:             modernize-use-emplace.TupleMakeFunctions
+    value:           '::std::make_pair;::std::make_tuple'
+  - key:             modernize-make-shared.IgnoreDefaultInitialization
+    value:           'true'
+  - key:             llvm-else-after-return.WarnOnUnfixable
+    value:           '0'
+  - key:             modernize-make-shared.IncludeStyle
+    value:           llvm
+...
+
Index: wsclean/external/schaapcommon/.cmake-format.py
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/.cmake-format.py
@@ -0,0 +1,240 @@
+# ----------------------------------
+# Options affecting listfile parsing
+# ----------------------------------
+with section("parse"):
+
+  # Specify structure for custom cmake functions
+  additional_commands = { 'foo': { 'flags': ['BAR', 'BAZ'],
+             'kwargs': {'DEPENDS': '*', 'HEADERS': '*', 'SOURCES': '*'}}}
+
+  # Override configurations per-command where available
+  override_spec = {}
+
+  # Specify variable tags.
+  vartags = []
+
+  # Specify property tags.
+  proptags = []
+
+# -----------------------------
+# Options affecting formatting.
+# -----------------------------
+with section("format"):
+
+  # Disable formatting entirely, making cmake-format a no-op
+  disable = False
+
+  # How wide to allow formatted cmake files
+  line_width = 80
+
+  # How many spaces to tab for indent
+  tab_size = 2
+
+  # If true, lines are indented using tab characters (utf-8 0x09) instead of
+  # <tab_size> space characters (utf-8 0x20). In cases where the layout would
+  # require a fractional tab character, the behavior of the  fractional
+  # indentation is governed by <fractional_tab_policy>
+  use_tabchars = False
+
+  # If <use_tabchars> is True, then the value of this variable indicates how
+  # fractional indentions are handled during whitespace replacement. If set to
+  # 'use-space', fractional indentation is left as spaces (utf-8 0x20). If set
+  # to `round-up` fractional indentation is replaced with a single tab character
+  # (utf-8 0x09) effectively shifting the column to the next tabstop
+  fractional_tab_policy = 'use-space'
+
+  # If an argument group contains more than this many sub-groups (parg or kwarg
+  # groups) then force it to a vertical layout.
+  max_subgroups_hwrap = 2
+
+  # If a positional argument group contains more than this many arguments, then
+  # force it to a vertical layout.
+  max_pargs_hwrap = 6
+
+  # If a cmdline positional group consumes more than this many lines without
+  # nesting, then invalidate the layout (and nest)
+  max_rows_cmdline = 2
+
+  # If true, separate flow control names from their parentheses with a space
+  separate_ctrl_name_with_space = False
+
+  # If true, separate function names from parentheses with a space
+  separate_fn_name_with_space = False
+
+  # If a statement is wrapped to more than one line, than dangle the closing
+  # parenthesis on its own line.
+  dangle_parens = False
+
+  # If the trailing parenthesis must be 'dangled' on its on line, then align it
+  # to this reference: `prefix`: the start of the statement,  `prefix-indent`:
+  # the start of the statement, plus one indentation  level, `child`: align to
+  # the column of the arguments
+  dangle_align = 'prefix'
+
+  # If the statement spelling length (including space and parenthesis) is
+  # smaller than this amount, then force reject nested layouts.
+  min_prefix_chars = 4
+
+  # If the statement spelling length (including space and parenthesis) is larger
+  # than the tab width by more than this amount, then force reject un-nested
+  # layouts.
+  max_prefix_chars = 10
+
+  # If a candidate layout is wrapped horizontally but it exceeds this many
+  # lines, then reject the layout.
+  max_lines_hwrap = 2
+
+  # What style line endings to use in the output.
+  line_ending = 'unix'
+
+  # Format command names consistently as 'lower' or 'upper' case
+  command_case = 'canonical'
+
+  # Format keywords consistently as 'lower' or 'upper' case
+  keyword_case = 'unchanged'
+
+  # A list of command names which should always be wrapped
+  always_wrap = []
+
+  # If true, the argument lists which are known to be sortable will be sorted
+  # lexicographicall
+  enable_sort = True
+
+  # If true, the parsers may infer whether or not an argument list is sortable
+  # (without annotation).
+  autosort = False
+
+  # By default, if cmake-format cannot successfully fit everything into the
+  # desired linewidth it will apply the last, most agressive attempt that it
+  # made. If this flag is True, however, cmake-format will print error, exit
+  # with non-zero status code, and write-out nothing
+  require_valid_layout = False
+
+  # A dictionary mapping layout nodes to a list of wrap decisions. See the
+  # documentation for more information.
+  layout_passes = {}
+
+# ------------------------------------------------
+# Options affecting comment reflow and formatting.
+# ------------------------------------------------
+with section("markup"):
+
+  # What character to use for bulleted lists
+  bullet_char = '*'
+
+  # What character to use as punctuation after numerals in an enumerated list
+  enum_char = '.'
+
+  # If comment markup is enabled, don't reflow the first comment block in each
+  # listfile. Use this to preserve formatting of your copyright/license
+  # statements.
+  first_comment_is_literal = False
+
+  # If comment markup is enabled, don't reflow any comment block which matches
+  # this (regex) pattern. Default is `None` (disabled).
+  literal_comment_pattern = None
+
+  # Regular expression to match preformat fences in comments default=
+  # ``r'^\s*([`~]{3}[`~]*)(.*)$'``
+  fence_pattern = '^\\s*([`~]{3}[`~]*)(.*)$'
+
+  # Regular expression to match rulers in comments default=
+  # ``r'^\s*[^\w\s]{3}.*[^\w\s]{3}$'``
+  ruler_pattern = '^\\s*[^\\w\\s]{3}.*[^\\w\\s]{3}$'
+
+  # If a comment line matches starts with this pattern then it is explicitly a
+  # trailing comment for the preceeding argument. Default is '#<'
+  explicit_trailing_pattern = '#<'
+
+  # If a comment line starts with at least this many consecutive hash
+  # characters, then don't lstrip() them off. This allows for lazy hash rulers
+  # where the first hash char is not separated by space
+  hashruler_min_length = 10
+
+  # If true, then insert a space between the first hash char and remaining hash
+  # chars in a hash ruler, and normalize its length to fill the column
+  canonicalize_hashrulers = True
+
+  # enable comment markup parsing and reflow
+  enable_markup = False
+
+# ----------------------------
+# Options affecting the linter
+# ----------------------------
+with section("lint"):
+
+  # a list of lint codes to disable
+  disabled_codes = []
+
+  # regular expression pattern describing valid function names
+  function_pattern = '[0-9a-z_]+'
+
+  # regular expression pattern describing valid macro names
+  macro_pattern = '[0-9A-Z_]+'
+
+  # regular expression pattern describing valid names for variables with global
+  # (cache) scope
+  global_var_pattern = '[A-Z][0-9A-Z_]+'
+
+  # regular expression pattern describing valid names for variables with global
+  # scope (but internal semantic)
+  internal_var_pattern = '_[A-Z][0-9A-Z_]+'
+
+  # regular expression pattern describing valid names for variables with local
+  # scope
+  local_var_pattern = '[a-z][a-z0-9_]+'
+
+  # regular expression pattern describing valid names for privatedirectory
+  # variables
+  private_var_pattern = '_[0-9a-z_]+'
+
+  # regular expression pattern describing valid names for public directory
+  # variables
+  public_var_pattern = '[A-Z][0-9A-Z_]+'
+
+  # regular expression pattern describing valid names for function/macro
+  # arguments and loop variables.
+  argument_var_pattern = '[a-z][a-z0-9_]+'
+
+  # regular expression pattern describing valid names for keywords used in
+  # functions or macros
+  keyword_pattern = '[A-Z][0-9A-Z_]+'
+
+  # In the heuristic for C0201, how many conditionals to match within a loop in
+  # before considering the loop a parser.
+  max_conditionals_custom_parser = 2
+
+  # Require at least this many newlines between statements
+  min_statement_spacing = 1
+
+  # Require no more than this many newlines between statements
+  max_statement_spacing = 2
+  max_returns = 6
+  max_branches = 12
+  max_arguments = 5
+  max_localvars = 15
+  max_statements = 50
+
+# -------------------------------
+# Options affecting file encoding
+# -------------------------------
+with section("encode"):
+
+  # If true, emit the unicode byte-order mark (BOM) at the start of the file
+  emit_byteorder_mark = False
+
+  # Specify the encoding of the input file. Defaults to utf-8
+  input_encoding = 'utf-8'
+
+  # Specify the encoding of the output file. Defaults to utf-8. Note that cmake
+  # only claims to support utf-8 so be careful when using anything else
+  output_encoding = 'utf-8'
+
+# -------------------------------------
+# Miscellaneous configurations options.
+# -------------------------------------
+with section("misc"):
+
+  # A dictionary containing any per-command configuration overrides. Currently
+  # only `command_case` is supported.
+  per_command = {}
Index: wsclean/external/schaapcommon/.gitignore
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/.gitignore
@@ -0,0 +1,6 @@
+.vscode/
+build/
+builds/
+*~
+.kdev4/
+schaapcommon.kdev4
Index: wsclean/external/schaapcommon/.gitlab-ci.yml
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/.gitlab-ci.yml
@@ -0,0 +1,164 @@
+# Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+workflow:
+  rules:
+    # Don't create a pipeline if a branch has open merge requests, since the MR
+    # also starts a pipeline.
+    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
+      when: never
+    - when: always
+
+stages:
+  - versioning
+  - prepare
+  - linting
+  - build
+  - test
+
+# The 'IMAGE' variables allow reusing docker images between different pipelines.
+# See https://confluence.skatelescope.org/display/SE/Caching+Docker+images+using+GitLab+CI+registry
+versioning:
+  stage: versioning
+  image: bitnami/git
+  script:
+    # Unshallowing ensures that 'git log' works
+    - git fetch --unshallow
+    - echo BASE_IMAGE_1804=${CI_REGISTRY_IMAGE}/base_1804:$(git log -n 1 --pretty=format:%H -- docker/ubuntu_18_04_base) > versions.env
+    - echo BASE_IMAGE_2004=${CI_REGISTRY_IMAGE}/base_2004:$(git log -n 1 --pretty=format:%H -- docker/ubuntu_20_04_base) >> versions.env
+    - echo BASE_IMAGE_2204=${CI_REGISTRY_IMAGE}/base_2204:$(git log -n 1 --pretty=format:%H -- docker/ubuntu_22_04_base) >> versions.env
+    - cat versions.env
+  artifacts:
+    reports:
+      dotenv: versions.env
+
+.prepare:
+  stage: prepare
+  needs: ["versioning"]
+  image: docker:20.10
+  services:
+    - docker:20.10-dind
+  before_script:
+    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
+  script:
+    - |
+      if ! docker manifest inspect $DOCKER_IMAGE > /dev/null; then
+        docker build $DOCKER_BUILD_ARG --tag $DOCKER_IMAGE -f $DOCKER_FILE .
+        docker push $DOCKER_IMAGE
+      fi
+  # Skip the job if there are no changes to the Docker file. This shortcut only
+  # works for push and merge request jobs.
+  # A manual pipeline run will thus create missing docker images.
+  rules:
+    - changes:
+      - $DOCKER_FILE
+
+prepare-base-1804:
+  extends: .prepare
+  variables:
+    DOCKER_IMAGE: $BASE_IMAGE_1804
+    DOCKER_FILE: docker/ubuntu_18_04_base
+
+prepare-base-2004:
+  extends: .prepare
+  variables:
+    DOCKER_IMAGE: $BASE_IMAGE_2004
+    DOCKER_FILE: docker/ubuntu_20_04_base
+
+prepare-base-2204:
+  extends: .prepare
+  variables:
+    DOCKER_IMAGE: $BASE_IMAGE_2204
+    DOCKER_FILE: docker/ubuntu_22_04_base
+
+.needs-1804:
+  needs:
+    - job: versioning
+    - job: prepare-base-1804
+      optional: true
+  image: $BASE_IMAGE_1804
+
+.needs-2004:
+  needs:
+    - job: versioning
+    - job: prepare-base-2004
+      optional: true
+  image: $BASE_IMAGE_2004
+
+.needs-2204:
+  needs:
+    - job: versioning
+    - job: prepare-base-2204
+      optional: true
+  image: $BASE_IMAGE_2204
+
+clang-format:
+  extends: .needs-2204
+  stage: linting
+  script:
+    - ./scripts/run-format.sh
+
+clang-tidy:
+  extends: .needs-2204
+  stage: linting
+  before_script:
+    - git clone https://gitlab.com/aroffringa/aocommon.git
+  script:
+    - export CLANG_TIDY_FIXES=clang-tidy-fixes.yml
+    - mkdir build && cd build
+    - cmake -DAOCOMMON_INCLUDE_DIR=../aocommon/include -DCLANG_TIDY_FIXES_FILE=${CLANG_TIDY_FIXES} -DCLANG_TIDY_WERROR=ON -DBUILD_TESTING=ON ..
+    - make check-clang-tidy
+  allow_failure: true
+  artifacts:
+    when: on_failure
+    paths:
+      - build/clang-tidy-fixes.yml
+
+.build:
+  stage: build
+  before_script:
+    - git clone https://gitlab.com/aroffringa/aocommon.git
+  script:
+    - cmake --version
+    - mkdir build && cd build
+    - cmake -DAOCOMMON_INCLUDE_DIR=../aocommon/include -DBUILD_TESTING=ON -DCMAKE_INSTALL_PREFIX=.. -DCMAKE_CXX_FLAGS="-coverage" -DCMAKE_EXE_LINKER_FLAGS="-coverage" ..
+    - make -j`nproc`
+    - make install
+  artifacts:
+    paths:
+      - aocommon
+      - build
+
+build-1804:
+  extends: [".needs-1804",".build"]
+
+build-2004:
+  extends: [".needs-2004",".build"]
+
+build-2204:
+  extends: [".needs-2204",".build"]
+
+.test:
+  stage: test
+  script:
+     - cd build/
+     - ctest -j`nproc` -T test
+
+test-1804:
+  extends: .test
+  needs: ["versioning","build-1804"]
+  image: $BASE_IMAGE_1804
+
+test-2004:
+  extends: .test
+  needs: ["versioning","build-2004"]
+  image: $BASE_IMAGE_2004
+  after_script:
+    - gcovr -j`nproc` -r .. -e '.*/external/.*' -e '.*/CompilerIdCXX/.*' -e '.*/test/.*'
+
+test-2204:
+  extends: .test
+  needs: ["versioning","build-2204"]
+  image: $BASE_IMAGE_2204
+  after_script:
+    - gcovr -j`nproc` -r .. -e '.*/external/.*' -e '.*/CompilerIdCXX/.*' -e '.*/test/.*'
Index: wsclean/external/schaapcommon/CMakeLists.txt
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/CMakeLists.txt
@@ -0,0 +1,162 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# Top level CMakeLists.txt file for SchaapCommon
+cmake_minimum_required(VERSION 3.7)
+
+# Define a couple of dedicated variables, to prevent that standard CMAKE
+# variables get screwed up when schaapcommon included in another package
+set(SCHAAPCOMMON_PROJECT_NAME schaapcommon)
+set(SCHAAPCOMMON_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+
+project(${SCHAAPCOMMON_PROJECT_NAME})
+
+option(BUILD_TESTING "Build tests" OFF)
+
+set(CMAKE_MODULE_PATH ${SCHAAPCOMMON_SOURCE_DIR}/cmake
+                      ${SCHAAPCOMMON_SOURCE_DIR}/cmake/external)
+
+# CMP0063 is needed to hide symbols in static libraries
+cmake_policy(SET CMP0063 NEW)
+# Suppress warnings related to ROOT variables
+if(POLICY CMP0074)
+  cmake_policy(SET CMP0074 NEW)
+endif()
+
+set(CMAKE_CXX_VISIBILITY_PRESET hidden)
+set(CMAKE_POSITION_INDEPENDENT_CODE True)
+
+# Convenience conditional to distinguish between stand-alone vs dependency builds
+set(SCHAAPCOMMON_MASTER_PROJECT OFF)
+if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
+  set(SCHAAPCOMMON_MASTER_PROJECT ON)
+  set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
+  set(CLANG_TIDY_EXE
+      "clang-tidy"
+      CACHE STRING "clang-tidy executable.")
+  set(CLANG_TIDY_FIXES_FILE
+      ""
+      CACHE STRING "Write clang-tidy fixes to yml file with specified name.")
+  option(CLANG_TIDY_WERROR OFF)
+endif()
+
+if(SCHAAPCOMMON_MASTER_PROJECT)
+  # Require the AOCOMMON headers when compiled in standalone.
+  set(AOCOMMON_INCLUDE_DIR
+      ""
+      CACHE FILEPATH "Path to aocommon include")
+  if("${AOCOMMON_INCLUDE_DIR}" STREQUAL "")
+    message(
+      FATAL_ERROR
+        "AOCOMMON_INCLUDE_DIR is not defined!\n"
+        "Please use 'cmake -DAOCOMMON_INCLUDE_DIR=<aocommon include path>'")
+  endif()
+  if(NOT EXISTS ${AOCOMMON_INCLUDE_DIR}/aocommon/uvector.h)
+    message(
+      FATAL_ERROR
+        "Can't find uvector.h in AOCOMMON_INCLUDE_DIR (\"${AOCOMMON_INCLUDE_DIR}\")"
+    )
+  endif()
+  include_directories(${AOCOMMON_INCLUDE_DIR})
+
+  if(BUILD_TESTING)
+    include(CTest)
+    find_package(
+      Boost
+      COMPONENTS unit_test_framework
+      REQUIRED)
+  endif()
+endif()
+
+# Compile in release mode if schaapcommon is included from external
+# dependency
+if(NOT SCHAAPCOMMON_MASTER_PROJECT)
+  set(CMAKE_BUILD_TYPE Release)
+endif()
+
+# Spawn all compiler warnings
+add_compile_options(-Wall -Wzero-as-null-pointer-constant)
+
+# Load dependencies, could be done a bit neater with CMP0079, i.e.
+# cmake_policy(SET CMP0079 NEW)
+# but requires CMake >= 3.13
+
+# Find and include HDF5
+find_package(
+  HDF5
+  COMPONENTS C CXX
+  REQUIRED)
+add_definitions(${HDF5_DEFINITIONS})
+include_directories(SYSTEM ${HDF5_INCLUDE_DIR})
+
+# Find and include FFTW
+find_library(FFTW3F_LIB fftw3f REQUIRED HINTS ENV FFTW3_LIB)
+find_library(FFTW3F_THREADS_LIB fftw3f_threads REQUIRED HINTS ENV FFTW3_LIB)
+find_path(
+  FFTW3_INCLUDE_DIR
+  NAMES fftw3.h
+  HINTS ENV FFTW3_INCLUDE)
+
+include_directories(SYSTEM ${FFTW3_INCLUDE_DIR})
+
+# Temporary include casacore until this is replaced with aocommon::MC2x2
+find_package(
+  Casacore
+  COMPONENTS casa
+  REQUIRED)
+include_directories(SYSTEM ${CASACORE_INCLUDE_DIR})
+
+# Find and include Boost (geometry) headers
+find_package(Boost REQUIRED)
+include_directories(SYSTEM ${Boost_INCLUDE_DIRS})
+
+# Boost_VERSION has 0's instead of periods for older versions of boost
+string(REPLACE 0 . Boost_VERSION_TMP ${Boost_VERSION})
+if(Boost_VERSION_TMP VERSION_LESS "1.66")
+  add_definitions(-DHAVE_BOOST_LT_166)
+endif()
+
+find_package(Threads REQUIRED)
+
+find_package(GSL REQUIRED)
+include_directories(SYSTEM ${GSL_INCLUDE_DIRS})
+
+# Let schaapcommon be a STATIC library, to reduce the risk on linking problems
+add_library(schaapcommon STATIC "")
+target_link_libraries(
+  ${SCHAAPCOMMON_PROJECT_NAME}
+  ${HDF5_LIBRARIES}
+  ${HDF5_CXX_LIBRARIES}
+  ${CASACORE_LIBRARIES}
+  ${FFTW3F_LIB}
+  ${FFTW3F_THREADS_LIB}
+  ${CMAKE_THREAD_LIBS_INIT}
+  ${GSL_LIBRARIES})
+
+if(SCHAAPCOMMON_MASTER_PROJECT)
+  if(CMAKE_EXPORT_COMPILE_COMMANDS)
+    if(CLANG_TIDY_WERROR)
+      set(CLANG_TIDY_WARNINGS_AS_ERRORS "*")
+    endif()
+
+    file(GLOB_RECURSE ALL_CXX_SOURCE_FILES ${CMAKE_SOURCE_DIR}/src/*.cc)
+    add_custom_target(
+      check-clang-tidy
+      COMMAND
+        ${CLANG_TIDY_EXE} --export-fixes=${CLANG_TIDY_FIXES_FILE}
+        --warnings-as-errors=${CLANG_TIDY_WARNINGS_AS_ERRORS} -p .
+        ${ALL_CXX_SOURCE_FILES})
+  endif()
+
+  # Install targets
+  install(
+    TARGETS schaapcommon
+    ARCHIVE DESTINATION lib
+    LIBRARY DESTINATION lib)
+endif()
+
+# Source directories
+add_subdirectory(src/facets)
+add_subdirectory(src/fft)
+add_subdirectory(src/fitters)
+add_subdirectory(src/h5parm)
Index: wsclean/external/schaapcommon/LICENSE
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/LICENSE
@@ -0,0 +1,677 @@
+                       Copyright 2020 ASTRON
+
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
+
Index: wsclean/external/schaapcommon/README.md
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/README.md
@@ -0,0 +1,11 @@
+# schaapcommon
+This repository contains utilities that are shared among different packages in the schaap-stack, including DP3/WSClean and EveryBeam.
+
+## Requirements
+When compiling `schaapcommon` as a stand-alone (static) library, the `aocommon` headers need to be available. `aocommon` can be cloned from https://gitlab.com/aroffringa/aocommon. To include the headers in the (cmake) build process, use the `AOCOMMON_INCLUDE_DIR` variable.
+
+A `cmake` command typically reads
+
+```
+cmake -DAOCOMMON_INCLUDE_DIR=[PATH_TO_AOCOMMON/aocommon/include] -DCMAKE_INSTALL_PREFIX=[INSTALL_PATH] [PATH_TO_SCHAAPCOMMON]
+```
Index: wsclean/external/schaapcommon/cmake/external/FindCasacore.cmake
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/cmake/external/FindCasacore.cmake
@@ -0,0 +1,265 @@
+# - Try to find Casacore include dirs and libraries
+# Usage:
+#   find_package(Casacore [REQUIRED] [COMPONENTS components...])
+# Valid components are:
+#   casa, coordinates, derivedmscal, fits, images, lattices,
+#   meas, measures, mirlib, ms, msfits, python, scimath, scimath_f, tables
+#
+# Note that most components are dependent on other (more basic) components.
+# In that case, it suffices to specify the "top-level" components; dependent
+# components will be searched for automatically.
+#
+# The dependency tree can be generated using the script get_casacore_deps.sh.
+# For this, you need to have a complete casacore installation, built with shared
+# libraries, at your disposal.
+#
+# The dependencies in this macro were generated against casacore release 1.7.0.
+#
+# Variables used by this module:
+#  CASACORE_ROOT_DIR         - Casacore root directory.
+#  BLAS_LIBS                 - override BLAS library
+#  LAPACK_LIBS               - override LAPACK library
+#
+# Variables defined by this module:
+#  CASACORE_FOUND            - System has Casacore, which means that the
+#                              include dir was found, as well as all
+#                              libraries specified (not cached)
+#  CASACORE_INCLUDE_DIR      - Casacore include directory (cached)
+#  CASACORE_INCLUDE_DIRS     - Casacore include directories (not cached)
+#                              identical to CASACORE_INCLUDE_DIR
+#  CASACORE_LIBRARIES        - The Casacore libraries (not cached)
+#  CASA_${COMPONENT}_LIBRARY - The absolute path of Casacore library
+#                              "component" (cached)
+#  HAVE_AIPSPP               - True if system has Casacore (cached)
+#                              for backward compatibility with AIPS++
+#  HAVE_CASACORE             - True if system has Casacore (cached)
+#                              identical to CASACORE_FOUND
+#  TAQL_EXECUTABLE           - The absolute path of the TaQL executable
+#                              (cached)
+#
+# ATTENTION: The component names need to be in lower case, just as the
+# casacore library names. However, the CMake variables use all upper case.
+
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# - casacore_resolve_dependencies(_result)
+#
+# Resolve the Casacore library dependencies for the given components.
+# The list of dependent libraries will be returned in the variable result.
+# It is sorted from least dependent to most dependent library, so it can be
+# directly fed to the linker.
+#
+#   Usage: casacore_resolve_dependencies(result components...)
+#
+macro(casacore_resolve_dependencies _result)
+  set(${_result} ${ARGN})
+  set(_index 0)
+  # Do a breadth-first search through the dependency graph; append to the
+  # result list the dependent components for each item in that list.
+  # Duplicates will be removed later.
+  while(1)
+    list(LENGTH ${_result} _length)
+    if(NOT _index LESS _length)
+      break()
+    endif(NOT _index LESS _length)
+    list(GET ${_result} ${_index} item)
+    list(APPEND ${_result} ${Casacore_${item}_DEPENDENCIES})
+    math(EXPR _index "${_index}+1")
+  endwhile(1)
+  # Remove all duplicates in the current result list, while retaining only the
+  # last of each duplicate.
+  list(REVERSE ${_result})
+  list(REMOVE_DUPLICATES ${_result})
+  list(REVERSE ${_result})
+endmacro(casacore_resolve_dependencies _result)
+
+
+# - casacore_find_library(_name)
+#
+# Search for the library ${_name}.
+# If library is found, add it to CASACORE_LIBRARIES; if not, add ${_name}
+# to CASACORE_MISSING_COMPONENTS and set CASACORE_FOUND to false.
+#
+#   Usage: casacore_find_library(name)
+#
+macro(casacore_find_library _name)
+  string(TOUPPER ${_name} _NAME)
+  find_library(${_NAME}_LIBRARY ${_name}
+    HINTS ${CASACORE_ROOT_DIR} PATH_SUFFIXES lib)
+  mark_as_advanced(${_NAME}_LIBRARY)
+  if(${_NAME}_LIBRARY)
+    list(APPEND CASACORE_LIBRARIES ${${_NAME}_LIBRARY})
+  else(${_NAME}_LIBRARY)
+    set(CASACORE_FOUND FALSE)
+    list(APPEND CASACORE_MISSING_COMPONENTS ${_name})
+  endif(${_NAME}_LIBRARY)
+endmacro(casacore_find_library _name)
+
+
+# - casacore_find_package(_name)
+#
+# Search for the package ${_name}.
+# If the package is found, add the contents of ${_name}_INCLUDE_DIRS to
+# CASACORE_INCLUDE_DIRS and ${_name}_LIBRARIES to CASACORE_LIBRARIES.
+#
+# If Casacore itself is required, then, strictly speaking, the packages it
+# requires must be present. However, when linking against static libraries
+# they may not be needed. One can override the REQUIRED setting by switching
+# CASACORE_MAKE_REQUIRED_EXTERNALS_OPTIONAL to ON. Beware that this might cause
+# compile and/or link errors.
+#
+#   Usage: casacore_find_package(name [REQUIRED])
+#
+macro(casacore_find_package _name)
+  if("${ARGN}" MATCHES "^REQUIRED$" AND
+      Casacore_FIND_REQUIRED AND
+      NOT CASACORE_MAKE_REQUIRED_EXTERNALS_OPTIONAL)
+    find_package(${_name} REQUIRED)
+  else()
+    find_package(${_name})
+  endif()
+  if(${_name}_FOUND)
+    list(APPEND CASACORE_INCLUDE_DIRS ${${_name}_INCLUDE_DIRS})
+    list(APPEND CASACORE_LIBRARIES ${${_name}_LIBRARIES})
+  endif(${_name}_FOUND)
+endmacro(casacore_find_package _name)
+
+# Define the Casacore components.
+set(Casacore_components
+  casa
+  coordinates
+  derivedmscal
+  fits
+  images
+  lattices
+  meas
+  measures
+  mirlib
+  ms
+  msfits
+  python
+  scimath
+  scimath_f
+  tables
+)
+
+# Define the Casacore components' inter-dependencies.
+set(Casacore_casa_DEPENDENCIES)
+set(Casacore_coordinates_DEPENDENCIES   fits measures casa)
+set(Casacore_derivedmscal_DEPENDENCIES  ms measures tables casa)
+set(Casacore_fits_DEPENDENCIES          measures tables casa)
+set(Casacore_images_DEPENDENCIES        mirlib lattices coordinates fits measures scimath tables casa)
+set(Casacore_lattices_DEPENDENCIES      tables scimath casa)
+set(Casacore_meas_DEPENDENCIES          measures tables casa)
+set(Casacore_measures_DEPENDENCIES      tables casa)
+set(Casacore_mirlib_DEPENDENCIES)
+set(Casacore_ms_DEPENDENCIES            measures scimath tables casa)
+set(Casacore_msfits_DEPENDENCIES        ms fits measures tables casa)
+set(Casacore_python_DEPENDENCIES        casa)
+set(Casacore_scimath_DEPENDENCIES       scimath_f casa)
+set(Casacore_scimath_f_DEPENDENCIES)
+set(Casacore_tables_DEPENDENCIES        casa)
+
+# Initialize variables.
+set(CASACORE_FOUND FALSE)
+set(CASACORE_DEFINITIONS)
+set(CASACORE_LIBRARIES)
+set(CASACORE_MISSING_COMPONENTS)
+
+# Search for the header file first.
+if(NOT CASACORE_INCLUDE_DIR)
+  find_path(CASACORE_INCLUDE_DIR casacore/casa/aips.h
+    HINTS ${CASACORE_ROOT_DIR} PATH_SUFFIXES include)
+  mark_as_advanced(CASACORE_INCLUDE_DIR)
+endif(NOT CASACORE_INCLUDE_DIR)
+
+# Fallback for systems that have old casacore installed in directory not called 'casacore'
+# This fallback can be removed once we move to casacore 2.0 which always puts headers in 'casacore'
+if(NOT CASACORE_INCLUDE_DIR)
+  find_path(CASACORE_INCLUDE_DIR casa/aips.h
+    HINTS ${CASACORE_ROOT_DIR} PATH_SUFFIXES include)
+  mark_as_advanced(CASACORE_INCLUDE_DIR)
+endif(NOT CASACORE_INCLUDE_DIR)
+
+if(NOT CASACORE_INCLUDE_DIR)
+  set(CASACORE_ERROR_MESSAGE "Casacore: unable to find the header file casa/aips.h.\nPlease set CASACORE_ROOT_DIR to the root directory containing Casacore.")
+else(NOT CASACORE_INCLUDE_DIR)
+  # We've found the header file; let's continue.
+  set(CASACORE_FOUND TRUE)
+  # Note that new Casacore uses #include<casacore/casa/...>, while
+  # LOFAR still uses #include<casa/...>. Hence use both in -I path.
+  set(CASACORE_INCLUDE_DIRS ${CASACORE_INCLUDE_DIR} ${CASACORE_INCLUDE_DIR}/casacore)
+
+  # Search for some often used binaries.
+  find_program(TAQL_EXECUTABLE taql
+    HINTS ${CASACORE_ROOT_DIR}/bin)
+  mark_as_advanced(TAQL_EXECUTABLE)
+
+  # If the user specified components explicity, use that list; otherwise we'll
+  # assume that the user wants to use all components.
+  if(NOT Casacore_FIND_COMPONENTS)
+    set(Casacore_FIND_COMPONENTS ${Casacore_components})
+  endif(NOT Casacore_FIND_COMPONENTS)
+
+  # Get a list of all dependent Casacore libraries that need to be found.
+  casacore_resolve_dependencies(_find_components ${Casacore_FIND_COMPONENTS})
+
+  # Find the library for each component, and handle external dependencies
+  foreach(_comp ${_find_components})
+    casacore_find_library(casa_${_comp})
+    if(${_comp} STREQUAL casa)
+      casacore_find_package(HDF5)
+      casacore_find_library(m)
+      list(APPEND CASACORE_LIBRARIES ${CMAKE_DL_LIBS})
+    elseif(${_comp} STREQUAL coordinates)
+      casacore_find_package(WCSLIB REQUIRED)
+    elseif(${_comp} STREQUAL fits)
+      casacore_find_package(CFITSIO REQUIRED)
+    elseif(${_comp} STREQUAL scimath_f)
+      # If only looking for LAPACK, no library will be added if LAPACK
+      # is part of BLAS, as it is customary nowadays. So look for both
+      # to avoid confusing linker errors on symbols used in headers/templates.
+      if(DEFINED ENV{BLAS_LIBS})
+        set(BLAS_FOUND YES)
+        list(APPEND CASACORE_LIBRARIES $ENV{BLAS_LIBS})
+      else()
+        casacore_find_package(BLAS   REQUIRED)
+      endif()
+      if(DEFINED ENV{LAPACK_LIBS})
+        set(LAPACK_FOUND YES)
+        list(APPEND CASACORE_LIBRARIES $ENV{LAPACK_LIBS})
+      else()
+        casacore_find_package(LAPACK REQUIRED)
+      endif()
+    endif(${_comp} STREQUAL casa)
+  endforeach(_comp ${_find_components})
+endif(NOT CASACORE_INCLUDE_DIR)
+
+# Set HAVE_CASACORE; and HAVE_AIPSPP (for backward compatibility with AIPS++).
+if(CASACORE_FOUND)
+  set(HAVE_CASACORE TRUE CACHE INTERNAL "Define if Casacore is installed")
+  set(HAVE_AIPSPP TRUE CACHE INTERNAL "Define if AIPS++/Casacore is installed")
+endif(CASACORE_FOUND)
+
+# Compose diagnostic message if not all necessary components were found.
+if(CASACORE_MISSING_COMPONENTS)
+  set(CASACORE_ERROR_MESSAGE "Casacore: the following components could not be found:\n     ${CASACORE_MISSING_COMPONENTS}")
+endif(CASACORE_MISSING_COMPONENTS)
+
+# Print diagnostics.
+if(CASACORE_FOUND)
+  if(NOT Casacore_FIND_QUIETLY)
+    message(STATUS "Found the following Casacore components: ")
+    foreach(_comp ${_find_components})
+      string(TOUPPER casa_${_comp} _COMP)
+      message(STATUS "  ${_comp}: ${${_COMP}_LIBRARY}")
+    endforeach(_comp ${_find_components})
+  endif(NOT Casacore_FIND_QUIETLY)
+else(CASACORE_FOUND)
+  if(Casacore_FIND_REQUIRED)
+    message(FATAL_ERROR "${CASACORE_ERROR_MESSAGE}")
+  else(Casacore_FIND_REQUIRED)
+    message(STATUS "${CASACORE_ERROR_MESSAGE}")
+  endif(Casacore_FIND_REQUIRED)
+endif(CASACORE_FOUND)
Index: wsclean/external/schaapcommon/cmake/unittest.cmake
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/cmake/unittest.cmake
@@ -0,0 +1,46 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# Generic function for adding a schaapcommon unittest. It creates
+# a 'test' that builds the unittest and a test that runs it.
+# Arguments:
+# - First argument: Module name, e.g., 'h5parm'.
+# - Next arguments: Source file names.
+# Return value:
+# - Sets TEST_NAME to the unit test name in the parent scope.
+
+function(add_unittest MODULE_NAME)
+  set(TEST_NAME "unittests_${MODULE_NAME}")
+  set(TEST_NAME
+      ${TEST_NAME}
+      PARENT_SCOPE)
+  set(FILENAMES ${ARGN})
+
+  # Add boost dynamic link flag for all test files.
+  # https://www.boost.org/doc/libs/1_66_0/libs/test/doc/html/boost_test/usage_variants.html
+  # Without this flag, linking is incorrect and boost performs duplicate delete()
+  # calls after running all tests, in the cleanup phase.
+  set_source_files_properties(${FILENAMES} PROPERTIES COMPILE_DEFINITIONS
+                                                      "BOOST_TEST_DYN_LINK")
+
+  add_executable(${TEST_NAME} ${FILENAMES})
+  target_link_libraries(${TEST_NAME} schaapcommon
+                        ${Boost_UNIT_TEST_FRAMEWORK_LIBRARY})
+  target_include_directories(
+    ${TEST_NAME}
+    PRIVATE
+      "$<BUILD_INTERFACE:${SCHAAPCOMMON_SOURCE_DIR}/include/schaapcommon/${MODULE_NAME}>"
+  )
+
+  # Add test for automatically (re)building the test if needed.
+  add_test(build_${TEST_NAME} ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR}
+           --target ${TEST_NAME})
+  set_tests_properties(build_${TEST_NAME} PROPERTIES FIXTURES_SETUP
+                                                     ${TEST_NAME})
+
+  add_test(NAME ${TEST_NAME} COMMAND ${TEST_NAME} -f JUNIT -k ${TEST_NAME}.xml
+                                     --catch_system_error=yes)
+  set_tests_properties(${TEST_NAME} PROPERTIES LABELS unit FIXTURES_REQUIRED
+                                               ${TEST_NAME})
+
+endfunction()
Index: wsclean/external/schaapcommon/doc/_static/foursources.reg
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/doc/_static/foursources.reg
@@ -0,0 +1,31 @@
+# Region file format: DS9 version 4.1
+global color=green dashlist=8 3 width=1 font="helvetica 10 normal roman" select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
+fk5
+
+# The polygons below were created manually. They create areas around each of the image points.
+# The comments below contain the corresponding 0-based pixel coordinates.
+
+# The 'point' values are artifical values, for testing DS9FacetFile only.
+# These points are selected such that they coincide with one of the vertices that
+# are not located on the boundary.
+
+# Ra+dec@(400,64). Polygon is (379,-9) (377,91) (548,95) (551,-5).
+polygon(23.0,30.5, 23.0,31.5, 21.0,31.5, 21.0,30.5) # text=CygA
+point(23.0,31.5)
+
+# Ra@(400,256). Polygon is (364,129) (366,301) (541,305) (547,128).
+polygon(23.15,31.88, 23.10,33.6, 21.0,33.6, 21.0,31.83) # text=CygAO
+point(23.10,33.6)
+
+# Dec@(256,64). Polygon is (128,-9) (128,128) (384,128) (384,-9).
+polygon(25.91,30.5, 25.93,31.87, 22.92,31.87, 22.94,30.5) # text=CygTJ
+# Test that the reader uses the last point when supplying multiple.
+point(0, 0)
+point(22.92,31.87)
+
+# Center@(256,256). Polygon is (160,160) (160,352) (352,352) (352,160).
+polygon(25.56,32.19 25.58,34.11, 23.26,34.11, 23.29,32.19)
+# No explicit point -> RA() and Dec() should be nan.
+
+# For debugging: Region that covers everything.
+#polygon(33.0,27.0, 33.0,40.0, 17.0,40.0, 17.0,27.0)
Index: wsclean/external/schaapcommon/doc/ds9-facet-file.rst
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/doc/ds9-facet-file.rst
@@ -0,0 +1,78 @@
+DS9 region file
+===============
+
+The tessellation of an image into polygon-shaped geometries - coined facets - can be controlled with a DS9 region file.
+The generic region file format is documented at http://ds9.si.edu/doc/ref/region.html, this pages describes which subset
+of the region file can be parsed by `WSClean <https://gitlab.com/aroffringa/wsclean>`_ and `DP3 <https://git.astron.nl/RD/DP3/>`_ for the specific use case of
+tessellating the sky for direction-dependent calibration.
+
+This page provides user documentation. For in-depth technical details, please consult the `class responsible for parsing the facet file <https://git.astron.nl/RD/schaapcommon/-/blob/master/include/schaapcommon/facets/ds9facetfile.h>`_.
+
+Defining a facet
+~~~~~~~~~~~~~~~~
+Facets are specified using "polygons", where the (ra,dec) coordinates of the polygon vertices are specified sequentially, i.e.
+
+::
+
+    polygon(ra_0, dec_0, ..., ..., ra_n, dec_n)
+
+Please bear in mind:
+
+- the ``(ra,dec)`` coordinates should be given in degrees;
+- a ``polygon`` can have an arbitrary number of vertices;
+- the start and end vertices of the ``polygon`` need not to coincide;
+- the vertices can be placed in arbitrary order (i.e. clockwise or counter-clockwise);
+
+Adding a text label
+~~~~~~~~~~~~~~~~~~~
+Optionally, a polygon can be equipped with a text label and/or a specific
+point of interest. The text label should be specified on the same line as the
+``polygon`` to which it should be attached and should be preceded by a ``#``.
+A valid polygon + label definition thus looks like:
+
+::
+
+    polygon(ra_0, dec_0, ..., ..., ra_n, dec_n) # text="ABCD"
+
+In DP3, this label can be used to refer to the facet. For example, ``ddecal.modelnextsteps.ABCD=[applybeam]`` implies that
+the beam is only applied to direction ``ABCD``.
+
+
+Adding a facet point of interest
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+By default the facet point of interest is the centroid of the facet. To override this behaviour,
+a ``point`` can be attached to a polygon to mark a specific point of interest. This can be useful to
+explicitly mark the position on which direction dependent effects (DDEs) should be evaluated.
+
+Analogous to the ``polygon`` definition, the ``point`` coordinates are provided in ``(ra,dec)``
+in degrees. A ``point`` should be placed on a new line, following the polygon
+definition, i.e.:
+
+::
+
+    polygon(ra_0, dec_0, ..., ..., ra_n, dec_n) # text="ABCD"
+    point(ra_A,dec_A)
+
+
+Only one ``point`` can be attached per ``polygon``. In case multiple points were
+specified, the last one will be used. So in the following example:
+
+::
+
+    polygon(ra_0, dec_0, ..., ..., ra_n, dec_n) # text="ABCD"
+    point(ra_A,dec_A)
+    point(ra_B,dec_B)
+
+the ``point(ra_A,dec_A)`` is ignored and ``point(ra_B,dec_B)`` will be used.
+
+Example facet file
+~~~~~~~~~~~~~~~~~~
+Below a full example of a facet file in DS9 region file format along with its graphical representation is shown. A user-defined point as well as a label is attached
+to three of the facets, the upper left facet has neither of these.
+Obviously, the facet definitions serve illustration purposes only and are otherwise impractical, as they are disjoint and do not
+cover the full image domain.
+
+.. literalinclude:: _static/foursources.reg
+
+.. image:: _static/foursources.png
+  :width: 400
Index: wsclean/external/schaapcommon/docker/ubuntu_18_04_base
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/docker/ubuntu_18_04_base
@@ -0,0 +1,14 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# base
+FROM ubuntu:18.04
+RUN export DEBIAN_FRONTEND=noninteractive && apt-get update && apt-get upgrade -y && \
+# install astronomy packages
+    apt-get -y install libcfitsio-dev wcslib-dev libfftw3-dev libgsl-dev \
+# install misc packages
+    wget git make cmake g++ doxygen \
+# install dependencies
+    libboost-all-dev libhdf5-dev libpython3-dev python3-pip \
+    casacore-dev casacore-tools \
+    && python3 -m pip install gcovr
\ No newline at end of file
Index: wsclean/external/schaapcommon/docker/ubuntu_20_04_base
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/docker/ubuntu_20_04_base
@@ -0,0 +1,18 @@
+# Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# base
+FROM ubuntu:20.04
+RUN export DEBIAN_FRONTEND=noninteractive && apt-get update && apt-get upgrade -y && \
+# install astronomy packages
+    apt-get -y install libcfitsio-dev wcslib-dev libfftw3-dev libgsl-dev \
+# install misc packages
+    wget git make cmake g++ doxygen \
+# install dependencies
+    libboost-all-dev libhdf5-dev libpython3-dev python3-pip \
+    casacore-dev casacore-tools clang-format-12 clang-tidy-12 \
+# The formatter needs a binary named 'clang-format', not 'clang-format-12'.
+# Same for clang-tidy-12.
+    && ln -sf clang-format-12 /usr/bin/clang-format \
+    && ln -sf clang-tidy-12 /usr/bin/clang-tidy \
+    && python3 -m pip install gcovr cmake-format
\ No newline at end of file
Index: wsclean/external/schaapcommon/docker/ubuntu_22_04_base
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/docker/ubuntu_22_04_base
@@ -0,0 +1,18 @@
+# Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# base
+FROM ubuntu:22.04
+RUN export DEBIAN_FRONTEND=noninteractive && apt-get update && apt-get upgrade -y && \
+# install astronomy packages
+    apt-get -y install libcfitsio-dev wcslib-dev libfftw3-dev libgsl-dev \
+# install misc packages
+    wget git make cmake g++ doxygen \
+# install dependencies
+    libboost-all-dev libhdf5-dev libpython3-dev python3-pip \
+    casacore-dev casacore-tools clang-format-12 clang-tidy-12 \
+# The formatter needs a binary named 'clang-format', not 'clang-format-12'.
+# Same for clang-tidy-12.
+    && ln -sf clang-format-12 /usr/bin/clang-format \
+    && ln -sf clang-tidy-12 /usr/bin/clang-tidy \
+    && python3 -m pip install gcovr cmake-format
Index: wsclean/external/schaapcommon/include/schaapcommon/facets/ds9facetfile.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/facets/ds9facetfile.h
@@ -0,0 +1,299 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FACETS_DS9FACETFILE_H_
+#define SCHAAPCOMMON_FACETS_DS9FACETFILE_H_
+
+#include "facet.h"
+
+#include <cmath>
+#include <fstream>
+#include <vector>
+
+namespace schaapcommon {
+namespace facets {
+
+/**
+ * Class for reading facets from a DS9 region file.
+ *
+ * Facets are specified using "polygons", where the (ra,dec)
+ * coordinates of the polygon vertices are specified sequentially, i.e.
+ *
+ * \code{.unparsed}
+ * polygon(ra_0, dec_0, ..., ..., ra_n, dec_n)
+ * \endcode
+ *
+ * Note that the (ra,dec) coordinates should be given in degrees!
+ *
+ * In addition, each polygon can be equipped with text labels and/or a specific
+ * point of interest. The text label should be specified on the same line as the
+ * \c polygon to which it should be attached and should be preceded by a \c #,
+ * e.g.:
+ *
+ * \code{.unparsed}
+ * polygon(ra_0, dec_0, ..., ..., ra_n, dec_n) # text="ABCD"
+ * \endcode
+ *
+ * A \c point can be attached to a polygon to mark a specific point of interest.
+ * Similar to the polygon definition, the coordinates are provided in (ra,dec)
+ * in degrees. A point should be placed on a new line, following the polygon
+ * definition, i.e.:
+ *
+ * \code{.unparsed}
+ * polygon(ra_0, dec_0, ..., ..., ra_n, dec_n) # text="ABCD"
+ * point(ra_A,dec_A)
+ * \endcode
+ *
+ * Only one point can be attached per polygon. In case multiple points were
+ * specified, the last one will be used. So in the following example:
+ *
+ * \code{.unparsed}
+ * polygon(ra_0, dec_0, ..., ..., ra_n, dec_n) # text="ABCD"
+ * point(ra_A,dec_A)
+ * point(ra_B,dec_B)
+ * \endcode
+ * the \c point(ra_A,dec_A) is ignored and \c point(ra_B,dec_B) will be used.
+ */
+class DS9FacetFile {
+ public:
+  enum class TokenType { kEmpty, kWord, kNumber, kSymbol, kComment };
+
+  /**
+   * @brief Construct a new DS9FacetFile object
+   *
+   * @param filename path to DS9 region file
+   */
+  explicit DS9FacetFile(const std::string& filename)
+      : file_(filename),
+        token_(""),
+        type_(TokenType::kEmpty),
+        has_char_(false),
+        char_() {
+    if (!file_) {
+      throw std::runtime_error("Error reading " + filename);
+    }
+    Skip();
+  }
+
+  /**
+   * Read the facets from the file. Be aware that this does not
+   * set the pixel values (x, y) of the vertices, see
+   * @ref Facet::CalculatePixelPositions().
+   */
+  std::vector<Facet> Read() {
+    std::vector<Facet> facets;
+    while (Type() != TokenType::kEmpty) {
+      std::string t = Token();
+      if (t == "global" || t == "fk5") {
+        SkipLine();
+      } else if (Type() == TokenType::kComment) {
+        Skip();
+      } else if (Type() == TokenType::kWord) {
+        Skip();
+
+        if (t == "polygon") {
+          facets.emplace_back();
+          ReadPolygon(facets.back());
+        } else if (t == "point" && !facets.empty()) {
+          ReadPoint(facets.back());
+        }
+      }
+    }
+    return facets;
+  }
+
+  std::vector<std::shared_ptr<Facet>> ReadShared() {
+    std::vector<std::shared_ptr<Facet>> facets;
+    while (Type() != TokenType::kEmpty) {
+      std::string t = Token();
+      if (t == "global" || t == "fk5") {
+        SkipLine();
+      } else if (Type() == TokenType::kComment) {
+        Skip();
+      } else if (Type() == TokenType::kWord) {
+        Skip();
+
+        if (t == "polygon") {
+          facets.emplace_back(std::make_shared<Facet>());
+          ReadPolygon(*facets.back());
+        } else if (t == "point" && !facets.empty()) {
+          ReadPoint(*facets.back());
+        }
+      }
+    }
+    return facets;
+  }
+
+  /**
+   * Take a comment as input e.g. text={direction} and retrieves direction.
+   */
+  static std::string ParseDirectionLabel(TokenType type,
+                                         const std::string& comment) {
+    const std::string classifier = "text=";
+    std::string dir = "";
+
+    if (type == TokenType::kComment &&
+        comment.find(classifier) != std::string::npos) {
+      dir = comment.substr(comment.find(classifier) + classifier.length(),
+                           comment.length());
+      // Remove trailing parts
+      dir = dir.substr(0, dir.find(","))
+                .substr(0, dir.find(" "))
+                .substr(0, dir.find("\n"));
+    }
+
+    return dir;
+  }
+
+ private:
+  void ReadPolygon(Facet& facet) {
+    std::vector<double> vals = ReadNumList();
+    if (vals.size() % 2 != 0) {
+      throw std::runtime_error(
+          "Polygon is expecting an even number of numbers in its list");
+    }
+    auto i = vals.cbegin();
+    while (i != vals.cend()) {
+      const double ra = *i * (M_PI / 180.0);
+      ++i;
+      const double dec = *i * (M_PI / 180.0);
+      ++i;
+      facet.AddVertex(ra, dec);
+    }
+
+    facet.SetDirectionLabel(ParseDirectionLabel(Type(), Token()));
+  }
+
+  void ReadPoint(Facet& facet) {
+    std::vector<double> vals = ReadNumList();
+    if (vals.size() != 2) {
+      throw std::runtime_error(
+          "Point is expecting exactly two numbers in its list");
+    }
+    facet.SetRA(vals[0] * (M_PI / 180.0));
+    facet.SetDec(vals[1] * (M_PI / 180.0));
+  }
+
+  std::vector<double> ReadNumList() {
+    std::vector<double> vals;
+    if (Token() != "(") {
+      throw std::runtime_error("Expecting '(' after polygon keyword");
+    }
+    Skip();
+    while (Token() != ")") {
+      if (Type() != TokenType::kNumber) {
+        throw std::runtime_error("Expected number or ')' after '(' ");
+      }
+      vals.push_back(atof(Token().c_str()));
+      Skip();
+      if (Token() == ",") Skip();
+    }
+    Skip();
+    return vals;
+  }
+
+  std::string Token() const { return token_; }
+
+  TokenType Type() const { return type_; }
+
+  void SkipLine() {
+    char c;
+    while (NextChar(c)) {
+      if (c == '\n') break;
+    }
+    Skip();
+  }
+
+  void Skip() {
+    bool cont = true;
+    type_ = TokenType::kEmpty;
+    token_ = std::string();
+    do {
+      char c;
+      if (NextChar(c)) {
+        switch (type_) {
+          case TokenType::kEmpty:
+            if (IsAlpha(c)) {
+              type_ = TokenType::kWord;
+              token_ += c;
+            } else if (IsWhiteSpace(c)) {
+            } else if (IsNumeric(c)) {
+              type_ = TokenType::kNumber;
+              token_ += c;
+            } else if (c == '(' || c == ')' || c == ',') {
+              type_ = TokenType::kSymbol;
+              token_ += c;
+              cont = false;
+            } else if (c == '#') {
+              type_ = TokenType::kComment;
+            }
+            break;
+          case TokenType::kWord:
+            if (IsAlpha(c) || (c >= '0' && c <= '9')) {
+              token_ += c;
+            } else {
+              cont = false;
+              PushChar(c);
+            }
+            break;
+          case TokenType::kNumber:
+            if (IsNumeric(c)) {
+              token_ += c;
+            } else {
+              cont = false;
+              PushChar(c);
+            }
+            break;
+          case TokenType::kSymbol:
+            PushChar(c);
+            cont = false;
+            break;
+          case TokenType::kComment:
+            if (c == '\n') {
+              cont = false;
+            } else {
+              token_ += c;
+            }
+            break;
+        }
+      } else {
+        cont = false;
+      }
+    } while (cont);
+  }
+
+  bool NextChar(char& c) {
+    if (has_char_) {
+      has_char_ = false;
+      c = char_;
+      return true;
+    } else {
+      file_.read(&c, 1);
+      return file_.good();
+    }
+  }
+  void PushChar(char c) {
+    has_char_ = true;
+    char_ = c;
+  }
+
+  std::ifstream file_;
+  std::string token_;
+  TokenType type_;
+  bool has_char_;
+  char char_;
+
+  constexpr static bool IsAlpha(char c) {
+    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || c == '_';
+  }
+  constexpr static bool IsWhiteSpace(char c) {
+    return c == ' ' || c == '\n' || c == '\r' || c == '\t';
+  }
+  constexpr static bool IsNumeric(char c) {
+    return (c >= '0' && c <= '9') || c == '-' || c == '.';
+  }
+};
+}  // namespace facets
+}  // namespace schaapcommon
+
+#endif  // SCHAAPCOMMON_FACETS_DS9FACETFILE_H_
Index: wsclean/external/schaapcommon/include/schaapcommon/facets/facet.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/facets/facet.h
@@ -0,0 +1,283 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FACETS_FACET_H_
+#define SCHAAPCOMMON_FACETS_FACET_H_
+
+#include <aocommon/io/serialstreamfwd.h>
+
+#include <string>
+#include <vector>
+#include <limits>
+
+namespace schaapcommon {
+namespace facets {
+
+/// Structure for holding ra and dec coordinates.
+struct Coord {
+  constexpr Coord() = default;
+  constexpr Coord(double _ra, double _dec) : ra(_ra), dec(_dec) {}
+
+  void Serialize(aocommon::SerialOStream& stream) const;
+  void Unserialize(aocommon::SerialIStream& stream);
+
+  double ra{0.0};
+  double dec{0.0};
+};
+
+/// Structure for holding pixel coordinates.
+struct Pixel {
+  constexpr Pixel() = default;
+
+  constexpr Pixel(int _x, int _y) : x(_x), y(_y) {}
+
+  constexpr friend Pixel operator+(const Pixel& a, const Pixel& b) {
+    return {a.x + b.x, a.y + b.y};
+  }
+
+  constexpr friend Pixel operator-(const Pixel& a, const Pixel& b) {
+    return {a.x - b.x, a.y - b.y};
+  }
+
+  constexpr friend bool operator==(const Pixel& a, const Pixel& b) {
+    return (a.x == b.x) && (a.y == b.y);
+  }
+
+  constexpr friend bool operator!=(const Pixel& a, const Pixel& b) {
+    return (a.x != b.x) || (a.y != b.y);
+  }
+
+  void Serialize(aocommon::SerialOStream& stream) const;
+  void Unserialize(aocommon::SerialIStream& stream);
+
+  int x{0};
+  int y{0};
+};
+
+class BoundingBox {
+ public:
+  BoundingBox() : min_(0, 0), max_(0, 0) {}
+
+  /**
+   * Creates a bounding box for given pixels.
+   */
+  explicit BoundingBox(const std::vector<Pixel>& pixels, size_t align = 1,
+                       bool make_square = false);
+
+  /**
+   * @return The minimum (x,y) coordinates of the bounding box. For a
+   * Facet - with x-axis positive rightwards and y-axis positive
+   * upward - this coordinate is the lower left point of the bounding box.
+   *
+   */
+  const Pixel& Min() const { return min_; }
+
+  /**
+   * @return The maximum (x,y) coordinates of the bounding box. For a
+   * Facet - with x-axis positive rightwards and y-axis positive
+   * upward - this coordinate is the upper right point of the bounding box.
+   */
+  const Pixel& Max() const { return max_; }
+
+  size_t Width() const { return static_cast<size_t>(max_.x - min_.x); }
+
+  size_t Height() const { return static_cast<size_t>(max_.y - min_.y); }
+
+  /**
+   * Return the centre x and y of the bounding box.
+   */
+  Pixel Centre() const {
+    return {(min_.x + max_.x) / 2, (min_.y + max_.y) / 2};
+  }
+
+  /**
+   * Returns true if the bounding box contains the pixel, otherwise return
+   * false
+   */
+  bool Contains(const Pixel& pixel) const {
+    return (min_.x <= pixel.x) && (min_.y <= pixel.y) && (max_.x > pixel.x) &&
+           (max_.y > pixel.y);
+  }
+
+  void Serialize(aocommon::SerialOStream& stream) const;
+  void Unserialize(aocommon::SerialIStream& stream);
+
+ private:
+  Pixel min_;  // Minimum x and y coordinates.
+  Pixel max_;  // Maximum x and y coordinates.
+};
+
+class Facet {
+ public:
+  Facet()
+      : coords_(),
+        pixels_(),
+        min_y_(0),
+        max_y_(0),
+        dir_(std::numeric_limits<double>::quiet_NaN(),
+             std::numeric_limits<double>::quiet_NaN()),
+        trimmed_box_(),
+        untrimmed_box_() {}
+
+  /**
+   * @brief Add vertex to facet
+   *
+   * @param ra right ascension coordinate of vertex (rad)
+   * @param dec declination coordinate of vertex (rad)
+   */
+  void AddVertex(double ra, double dec) { coords_.emplace_back(ra, dec); }
+
+  /**
+   * @brief Computes the x-coordinates of the intersection points with
+   * the polygonal shaped facet, given a specified y-coordinate.
+   *
+   * @param y_intersect y-coordinate for which to compute intersection points
+   * @return A vector with pairs of x-coordinates for the first and second
+   * intersection point, second > first. If no intersections were found, an
+   * empty vector is returned.
+   */
+  std::vector<std::pair<int, int>> HorizontalIntersections(
+      const int y_intersect) const;
+
+  /**
+   * Right ascension value that points inside this facet.
+   * It is not necessarily the centroid, but rather a
+   * point in the facet where e.g. a label can be placed to
+   * identify the facet.
+   */
+  double RA() const { return dir_.ra; }
+
+  /**
+   * Declination value that points inside this facet.
+   */
+  double Dec() const { return dir_.dec; }
+
+  /**
+   * @brief Compute the centroid of the facet in pixel coordinates.
+   * Internally, pixel coordinates are converted to floats, to avoid rounding
+   * issues in boost::geometry.
+   *
+   * @return Centroid of the facet (in pixel coordinates)
+   */
+  Pixel Centroid() const;
+
+  /**
+   * Get the ra+dec coordinates. This function is mainly for testing purposes.
+   * @return The ra+dec coordinates of the facet.
+   */
+  const std::vector<Coord>& GetCoords() const { return coords_; }
+
+  /**
+   * Get the pixel coordinates. This function is mainly for testing purposes.
+   * @return The pixel coordinates of the facet.
+   */
+  const std::vector<Pixel>& GetPixels() const { return pixels_; }
+
+  const std::string& DirectionLabel() const { return direction_label_; }
+
+  void SetRA(double dir_ra) { dir_.ra = dir_ra; }
+  void SetDec(double dir_dec) { dir_.dec = dir_dec; }
+  void SetDirectionLabel(const std::string& direction_label) {
+    direction_label_ = direction_label;
+  }
+
+  /**
+   * @brief Convert the ra+dec vertex coordinates into x+y pixel coordinates.
+   *
+   * Note that the following coordinate systems are adopted:
+   * ra/dec:
+   *
+   *           ^ dec
+   *           |
+   *           |
+   *   ra <----+
+   *
+   * x/y (image coords):
+   *   y
+   *   ^
+   *   |
+   *   |
+   *   o --> x
+   * where "o" is either the lower left corner of the main image, if
+   * origin_at_centre = false, or the center pixel of the main image, if
+   * origin_at_centre = true
+   *
+   * This function clips the facet to the image borders, if it falls outside
+   * of the range of the image.
+   *
+   * Besides calculating the pixel coordinates, this function:
+   *  - calculates a bounding box for the pixel coordinates using padding,
+   * alignment and squaring parameters.
+   *  - computes the (ra, dec) position of the facet centroid and assign the
+   * vaule to \c dir_ in case \c SetRA or \c SetDec were not invoked.
+   *
+   *
+   * @param phase_centre_ra Right ascension of phase centre of main image (rad)
+   * @param phase_centre_dec Declination of phase centre of main image (rad)
+   * @param px_scale_x Pixel resolution  in l-direction (rad)
+   * @param px_scale_y Pixel resolution in m-direction (rad)
+   * @param width Width of main image, number of pixels
+   * @param height Height of main image, number of pixels
+   * @param shift_l Shift of phase centre in l-direction (rad)
+   * @param shift_m Shift of phase centre in m-direction (rad)
+   * @param padding Padding factor for the bounding box. Should be >= 1.0.
+   * @param align Bounding box alignment. Typically a small power of two.
+   * @param make_square If true, create a square bounding box.
+   */
+  void CalculatePixels(double phase_centre_ra, double phase_centre_dec,
+                       double px_scale_x, double px_scale_y, size_t image_width,
+                       size_t image_height, double shift_l, double shift_m,
+                       double padding = 1.0, size_t align = 1u,
+                       bool make_square = false);
+
+  /**
+   * Get the trimmed bounding box for the facet that was created using the most
+   * recent CalculatePixels call.
+   * The trimmed bounding box contains all pixels and is aligned.
+   * @return The trimmed bounding box for the facet.
+   */
+  const BoundingBox& GetTrimmedBoundingBox() const { return trimmed_box_; };
+
+  /**
+   * Get the untrimmed bounding box for the facet that was created using the
+   * most recent CalculatePixels call.
+   * The untrimmed bounding box is calculated by applying padding to the trimmed
+   * bounding box and then aligning the resulting box.
+   * @return The untrimmed bounding box for the facet.
+   */
+  const BoundingBox& GetUntrimmedBoundingBox() const { return untrimmed_box_; };
+
+  /**
+   * @brief Calculate intersection between polygons \param poly1 and \param
+   * poly2. Makes use of boost::geometry::intersection.
+   *
+   * @param poly1 Polygon 1 (the facet)
+   * @param poly2 Polygon 2 (the full image)
+   * @return std::vector<Pixel> Intersection
+   */
+  static std::vector<Pixel> PolygonIntersection(std::vector<Pixel> poly1,
+                                                std::vector<Pixel> poly2);
+
+  /**
+   * Point-in-polygon: returns true if pixel in polygon (edges included), false
+   * otherwise
+   */
+  bool Contains(const Pixel& pixel) const;
+
+  void Serialize(aocommon::SerialOStream& stream) const;
+  void Unserialize(aocommon::SerialIStream& stream);
+
+ private:
+  std::vector<Coord> coords_;  ///< Ra+Dec coordinates of the Facet vertices.
+  std::vector<Pixel> pixels_;  ///< Pixel coordinates of the Facet vertices.
+  int min_y_;                  ///< Minimum y coordinate for all pixels.
+  int max_y_;                  ///< Maximum y coordinate for all pixels.
+  Coord dir_;  ///< (Custom) facet direction (ra, dec) in radians.
+  std::string direction_label_;  ///< Description of the facet direction.
+  BoundingBox trimmed_box_;      ///< Aligned bounding box for the pixels only.
+  BoundingBox untrimmed_box_;    ///< Aligned bounding box including padding.
+};
+
+}  // namespace facets
+}  // namespace schaapcommon
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/facets/facetimage.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/facets/facetimage.h
@@ -0,0 +1,158 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FACETS_FACETIMAGE_H_
+#define SCHAAPCOMMON_FACETS_FACETIMAGE_H_
+
+#include "facet.h"
+
+#include <aocommon/uvector.h>
+
+namespace schaapcommon {
+namespace facets {
+
+/**
+ * This class allows copying image data between a main image and facets of that
+ * main image. It has an internal data buffer for storing the facet image.
+ */
+class FacetImage {
+ public:
+  /**
+   * @brief Construct a new Facet Image object.
+   *
+   * @param image_width Width of the main image, in pixels.
+   * @param image_height Height of the main image, in pixels.
+   * @param nr_spectral_terms Number of spectral terms to use.
+   * @throw std::invalid_argument If image_width, image_height or
+   *        nr_spectral_terms is zero.
+   */
+  FacetImage(size_t image_width, size_t image_height, size_t nr_spectral_terms);
+
+  /**
+   * Update the facet geometry.
+   * This function initializes the FacetImage for using the given facet.
+   * Call this function before calling any other functions.
+   *
+   * @param facet The facet geometry. This facet should have a properly padded
+   *        and aligned bounding box. This bounding box may extend beyond the
+   *        borders of the main image due to padding or alignment.
+   *        All horizontal intersections should be within the mainimage, though.
+   * @param trimmed True: Use trimmed facet bounding box. False: Use untrimmed
+   *        facet bounding box.
+   */
+  void SetFacet(const Facet& facet, bool trimmed);
+
+  /**
+   * @return The width of the facet.
+   */
+  size_t Width() const { return box_.Width(); }
+
+  /**
+   * @return The height of the facet.
+   */
+  size_t Height() const { return box_.Height(); }
+
+  /**
+   * @return The number of pixels that this facet is displaced in X direction,
+   * relative to origin of main image.
+   */
+  int OffsetX() const { return box_.Min().x; }
+
+  /**
+   * @return The number of pixels that this facet is displaced in Y direction,
+   * relative to origin of main image.
+   */
+  int OffsetY() const { return box_.Min().y; }
+
+  /**
+   * @return The facet image data for the given spectral frequency term.
+   */
+  const float* Data(size_t spectral_term) const {
+    return data_[spectral_term].data();
+  }
+
+  /**
+   * @return The facet image data for the given spectral frequency term.
+   */
+  float* Data(size_t spectral_term) { return data_[spectral_term].data(); }
+
+  /**
+   * @brief Multiply facet image data for all spectral terms with a scalar.
+   */
+  FacetImage& operator*=(float factor);
+
+  /**
+   * @brief Fill the facet buffer with image data.
+   *
+   * @param images Vector of images.
+   *        The outer vector length should match the number of spectral terms.
+   *        The inner vector size should should match the image width and
+   *        image height values passed to the constructor.
+   * @throw std::invalid_argument if 'images' has an incorrect size.
+   * @throw std::runtime_error if SetFacet was not called.
+   */
+  void CopyToFacet(const std::vector<aocommon::UVector<float>>& images);
+
+  /**
+   * @brief Fill the facet buffer with the image data given as a buffer
+   *
+   * @param images Vector of buffered images.
+   *        The vector length should match the number of spectral terms.
+   *        The buffer is assumed to match the image width and image height
+   *        values passed to the constructor
+   * @throw std::runtime_error if SetFacet was not called.
+   */
+  void CopyToFacet(const std::vector<const float*>& images);
+
+  /**
+   * @brief Add data from the facet buffer to main images.
+   *
+   * @param images Vector of images.
+   *        The vector length should match the number of spectral terms.
+   *        The width and height of each image should match the values passed
+   *        to the constructor.
+   * @throw std::runtime_error if SetFacet was not called.
+   */
+  void AddToImage(const std::vector<float*>& images) const;
+
+  /**
+   * @brief Multiply the image values enclosed by the facet with scalar valued
+   * @param factor
+   *
+   * @param images Vector of images.
+   *         The vector length should match the number of spectral terms.
+   *        The width and height of each image should match the values passed
+   *        to the constructor.
+   * @param factor Scalar used for multiplying the image data inside the facet.
+   */
+  void MultiplyImageInsideFacet(std::vector<float*>& images,
+                                float factor) const;
+
+ private:
+  /**
+   * @brief Pre-calculate the horizontal intersections (xmin, xmax)
+   * of for each y-coordinate row in the facet bounding box with the
+   * main image.
+   *
+   * @param facet Facet
+   */
+  void SetHorizontalIntersections(const Facet& facet);
+
+  /**
+   * A vector with one element for each spectral frequency term.
+   * Each inner vector holds the data for a facet image.
+   */
+  std::vector<std::vector<float>> data_;
+  const size_t image_width_;   ///< Width of the main image.
+  const size_t image_height_;  ///< Height of the main image.
+  BoundingBox box_;  ///< Facet bounding box, including padding/alignment.
+
+  /**
+   * For each y value in box_, a vector with start and end x coordinate in the
+   * main image.
+   */
+  std::vector<std::vector<std::pair<int, int>>> horizontal_intersections_;
+};
+}  // namespace facets
+}  // namespace schaapcommon
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/fft/compositefft.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/fft/compositefft.h
@@ -0,0 +1,23 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FFT_COMPOSITEFFT_H_
+#define SCHAAPCOMMON_FFT_COMPOSITEFFT_H_
+
+#include <fftw3.h>
+#include <aocommon/staticfor.h>
+
+namespace schaapcommon {
+namespace fft {
+void FftR2CComposite(fftwf_plan plan_r2c, fftwf_plan plan_c2c,
+                     size_t image_height, size_t image_width, const float* in,
+                     fftwf_complex* out, aocommon::StaticFor<size_t>& loop);
+
+void FftC2RComposite(fftwf_plan plan_c2c, fftwf_plan plan_c2r,
+                     size_t image_height, size_t image_width,
+                     const fftwf_complex* in, float* out,
+                     aocommon::StaticFor<size_t>& loop);
+}  // namespace fft
+}  // namespace schaapcommon
+
+#endif
\ No newline at end of file
Index: wsclean/external/schaapcommon/include/schaapcommon/fft/convolution.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/fft/convolution.h
@@ -0,0 +1,64 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FFT_CONVOLUTION_H_
+#define SCHAAPCOMMON_FFT_CONVOLUTION_H_
+
+#include <cstring>
+
+namespace schaapcommon {
+namespace fft {
+
+/**
+ * @brief Make the FFTW float planner thread safe.
+ */
+void MakeFftwfPlannerThreadSafe();
+
+/**
+ * Convolve an image with a smaller kernel. No preparation of either image is
+ * needed.
+ *
+ * This function assumes that (n+1)/2 is the middle pixel for uneven image
+ * sizes. In the case of even image sizes, the middle falls between two
+ * pixels.
+ *
+ * To ensure thread safety make sure that \c MakeFftwPlannerThreadSafe() is
+ * called at a sufficiently high level before calling this function.
+ */
+void ResizeAndConvolve(float* image, size_t image_width, size_t image_height,
+                       const float* kernel, size_t kernel_size,
+                       size_t thread_count);
+
+/**
+ * Prepare a smaller kernel for convolution with \c Convolve(). The kernel
+ * is zero-padded and translated such that it is correctly centered for the
+ * convolution with the larger image. When the kernel is used more often, it
+ * is more efficient to call \c PrepareConvolutionKernel() or
+ * \c PrepareSmallConvolutionKernel() once and multiple times \c Convolve(),
+ * than calling \c Convolve() or \c ResizeAndConvolve() multiple times.
+ */
+void PrepareSmallConvolutionKernel(float* dest, size_t image_width,
+                                   size_t image_height, const float* kernel,
+                                   size_t kernel_size, size_t thread_count);
+/**
+ * Prepare a kernel for convolution with \c ConvolveSameSize(), by translating
+ * the input buffer such that the center value ends-up at postion 0. The
+ * kernel should be of the same size as the image to be convolved.
+ * Otherwise, \c PrepareSmallConvolutionKernel() should be used.
+ */
+void PrepareConvolutionKernel(float* dest, const float* source,
+                              size_t image_width, size_t image_height,
+                              size_t thread_count);
+
+/**
+ * Convolve an image with an already prepared kernel of the same size.
+ *
+ * To ensure thread safety make sure that \c MakeFftwPlannerThreadSafe() is
+ * called at a sufficiently high level before calling this function.
+ */
+void Convolve(float* image, const float* kernel, size_t image_width,
+              size_t image_height, size_t thread_count);
+}  // namespace fft
+}  // namespace schaapcommon
+
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/fft/resampler.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/fft/resampler.h
@@ -0,0 +1,113 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FFT_RESAMPLER_H_
+#define SCHAAPCOMMON_FFT_RESAMPLER_H_
+
+#include <aocommon/image.h>
+#include <aocommon/lane.h>
+#include <aocommon/uvector.h>
+#include <aocommon/windowfunction.h>
+
+#include <vector>
+#include <thread>
+
+#include <fftw3.h>
+
+namespace schaapcommon {
+namespace fft {
+
+class Resampler {
+ private:
+  struct Task {
+    float *input, *output;
+  };
+
+ public:
+  Resampler(size_t input_width, size_t input_height, size_t output_width,
+            size_t output_height, size_t cpu_count);
+
+  ~Resampler();
+
+  void AddTask(float* input, float* output) {
+    Task task;
+    task.input = input;
+    task.output = output;
+    tasks_.write(task);
+  }
+
+  void Start() {
+    for (size_t i = 0; i != tasks_.capacity(); ++i) {
+      threads_.emplace_back(&Resampler::RunThread, this);
+    }
+  }
+
+  void Finish() {
+    tasks_.write_end();
+    for (std::thread& t : threads_) t.join();
+    threads_.clear();
+    tasks_.clear();
+  }
+
+  void Resample(float* input, float* output) {
+    Task task;
+    task.input = input;
+    task.output = output;
+    RunSingle(task, false);
+  }
+
+  void SingleFT(const float* input, float* real_output,
+                float* imaginary_output);
+
+  /**
+   * Only to be used with SingleFT (it makes resampling thread unsafe!)
+   */
+  void SetTukeyWindow(double inset_size, bool correct_window) {
+    window_function_ = aocommon::WindowFunction::Tukey;
+    tukey_inset_size_ = inset_size;
+    correct_window_ = correct_window;
+    window_row_in_.clear();
+    window_col_in_.clear();
+    window_out_.clear();
+  }
+
+  void SetWindowFunction(aocommon::WindowFunction::Type window,
+                         bool correct_window) {
+    window_function_ = window;
+    correct_window_ = correct_window;
+    window_row_in_.clear();
+    window_col_in_.clear();
+    window_out_.clear();
+  }
+
+ private:
+  void RunThread();
+  void RunSingle(const Task& task, bool skip_window) const;
+  void ApplyWindow(float* data) const;
+  void UnapplyWindow(float* data) const;
+  void MakeWindow(aocommon::UVector<float>& data, size_t width) const;
+  void MakeTukeyWindow(aocommon::UVector<float>& data, size_t width) const;
+
+  size_t input_width_;
+  size_t input_height_;
+  size_t output_width_;
+  size_t output_height_;
+  size_t fft_width_;
+  size_t fft_height_;
+  aocommon::WindowFunction::Type window_function_;
+  double tukey_inset_size_;
+  mutable aocommon::UVector<float> window_row_in_;
+  mutable aocommon::UVector<float> window_col_in_;
+  mutable aocommon::UVector<float> window_out_;
+  bool correct_window_;
+
+  fftwf_plan in_to_f_plan_;
+  fftwf_plan f_to_out_plan_;
+
+  aocommon::Lane<Task> tasks_;
+  std::vector<std::thread> threads_;
+};
+}  // namespace fft
+}  // namespace schaapcommon
+
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/fft/restoreimage.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/fft/restoreimage.h
@@ -0,0 +1,39 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FFT_RESTORE_IMAGE_H_
+#define SCHAAPCOMMON_FFT_RESTORE_IMAGE_H_
+
+#include <cstddef>
+
+namespace schaapcommon {
+namespace fft {
+
+/**
+ * @brief Restore a diffuse image (e.g. produced with a multi-scale clean) using
+ * FFT convolution.
+ *
+ * Caller is assumed to ensure thread safety of the FFT plan creation. This can
+ * be achieved by running \c schaapcommon::fft::MakeFftwPlannerThreadSafe() at a
+ * sufficiently high level in the calling code.
+ *
+ * @param image_data (Residual??) image data buffer
+ * @param model_data Model image data buffer
+ * @param image_width Image height in pixels
+ * @param image_height Image height in pixels
+ * @param beam_major_axis Length of beam major axis [rad??]
+ * @param beam_minor_axis Length of beam minor axis [rad??]
+ * @param beam_position_angle Beam position angle [rad]
+ * @param pixel_scale_l Pixel scale in L-direction [rad]
+ * @param pixel_scale_m Pixel scale in M-direction [rad]
+ * @param thread_count Number of threads to use in convolution.
+ */
+void RestoreImage(float* image_data, const float* model_data,
+                  size_t image_width, size_t image_height,
+                  long double beam_major_axis, long double beam_minor_axis,
+                  long double beam_position_angle, long double pixel_scale_l,
+                  long double pixel_scale_m, size_t thread_count);
+
+}  // namespace fft
+}  // namespace schaapcommon
+#endif
\ No newline at end of file
Index: wsclean/external/schaapcommon/include/schaapcommon/fitters/gaussianfitter.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/fitters/gaussianfitter.h
@@ -0,0 +1,112 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FITTERS_GAUSSIAN_FITTER_H_
+#define SCHAAPCOMMON_FITTERS_GAUSSIAN_FITTER_H_
+
+#include <cstring>
+
+namespace schaapcommon {
+namespace fitters {
+class GaussianFitter {
+ public:
+  void Fit2DGaussianCentred(const float* image, size_t width, size_t height,
+                            double beam_est, double& beam_major,
+                            double& beam_minor, double& beam_pa,
+                            double box_scale_factor = 10.0,
+                            bool verbose = false);
+
+  void Fit2DCircularGaussianCentred(const float* image, size_t width,
+                                    size_t height, double& beam_size,
+                                    double box_scale_factor = 10.0);
+
+  void Fit2DGaussianFull(const float* image, size_t width, size_t height,
+                         double& val, double& pos_x, double& pos_y,
+                         double& beam_major, double& beam_minor,
+                         double& beam_pa, double* floor_level = nullptr);
+
+  const float* Image() const { return image_; }
+  size_t Width() const { return width_; }
+  size_t Height() const { return height_; }
+  size_t ScaleFactor() const { return scale_factor_; }
+  double XInit() const { return x_init_; };
+  double YInit() const { return y_init_; };
+  double PosConstrained() const { return pos_constrained_; };
+
+ private:
+  void Fit2DGaussianCentredInBox(const float* image, size_t width,
+                                 size_t height, double beam_est,
+                                 double& beam_major, double& beam_minor,
+                                 double& beam_pa, size_t box_width,
+                                 size_t box_height, bool verbose);
+
+  void Fit2DCircularGaussianCentredInBox(const float* image, size_t width,
+                                         size_t height, double& beam_size,
+                                         size_t box_width, size_t box_height);
+
+  /**
+   * This function performs a single fit of a Gaussian. The position of the
+   * Gaussian is constrained to be in the centre of the image. The Gaussian is
+   * fitted such that the squared residuals (data - model) are minimal.
+   *
+   * This function is typically used to find the beam-shape of the point-spread
+   * function. The beam estimate is used as initial value for the minor and
+   * major shape.
+   */
+  void SingleFit2DGaussianCentred(const float* image, size_t width,
+                                  size_t height, double beam_est,
+                                  double& beam_major, double& beam_minor,
+                                  double& beam_pa, bool verbose);
+
+  void SingleFit2DCircularGaussianCentred(const float* image, size_t width,
+                                          size_t height, double& beam_size);
+
+  void Fit2DGaussianWithAmplitudeInBox(const float* image, size_t width,
+                                       size_t height, double& val,
+                                       double& pos_x, double& pos_y,
+                                       double& beam_major, double& beam_minor,
+                                       double& beam_pa, double* floor_level,
+                                       size_t x_start, size_t x_end,
+                                       size_t y_start, size_t y_end);
+
+  /**
+   * Fits the position, size and amplitude of a Gaussian. If floor_level is not
+   * a nullptr, the floor (background level, or zero level) is fitted too.
+   */
+  void Fit2DGaussianWithAmplitude(const float* image, size_t width,
+                                  size_t height, double& val, double& pos_x,
+                                  double& pos_y, double& beam_major,
+                                  double& beam_minor, double& beam_pa,
+                                  double* floor_level);
+
+  /**
+   * Like SingleFit2DGaussianCentred(), but includes Gaussian centre X and Y
+   * position and amplitude in the fitted parameters.
+   *
+   * This function can typically be used for source fitting.
+   */
+  void Fit2DGaussianWithAmplitude(double& val, double& pos_x, double& pos_y,
+                                  double& beam_major, double& beam_minor,
+                                  double& beam_pa);
+
+  /**
+   * Like Fit2DGaussianWithAmplitude(), but includes floor_level as fitted
+   * parameter. Floor is the background/zero level on which the Gaussian
+   * resides.
+   */
+  void Fit2DGaussianWithAmplitudeWithFloor(double& val, double& pos_x,
+                                           double& pos_y, double& beam_major,
+                                           double& beam_minor, double& beam_pa,
+                                           double& floor_level);
+
+  const float* image_ = nullptr;
+  size_t width_ = 0;
+  size_t height_ = 0;
+  size_t scale_factor_ = 0;
+  double x_init_ = 0.0;
+  double y_init_ = 0.0;
+  double pos_constrained_ = 0.0;
+};
+}  // namespace fitters
+}  // namespace schaapcommon
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/fitters/nlplfitter.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/fitters/nlplfitter.h
@@ -0,0 +1,62 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FITTERS_NLPL_FITTER_H_
+#define SCHAAPCOMMON_FITTERS_NLPL_FITTER_H_
+
+#include <cmath>
+#include <memory>
+#include <vector>
+
+namespace schaapcommon {
+namespace fitters {
+
+/**
+ * This class fits a power law to a set of points. Note that there is a
+ * linear solution for this problem, but the linear solution requires
+ * all values to be positive, which is not the case for e.g. spectral
+ * energy distributions, because these have noise.
+ * This fitter does not have this requirement.
+ */
+class NonLinearPowerLawFitter {
+ public:
+  using NumT = float;
+
+  NonLinearPowerLawFitter();
+
+  ~NonLinearPowerLawFitter();
+
+  void AddDataPoint(NumT x, NumT y);
+
+  void Fit(NumT& exponent, NumT& factor);
+
+  void Fit(NumT& a, NumT& b, NumT& c);
+
+  /**
+   * @param [out] terms The resulting terms.
+   * Using a pre-allocated vector instead of a return value avoids
+   * memory allocations in this performance-critical function.
+   */
+  void Fit(std::vector<NumT>& terms, size_t n_terms);
+  void FitStable(std::vector<NumT>& terms, size_t n_terms);
+
+  void FastFit(NumT& exponent, NumT& factor);
+
+  static NumT Evaluate(NumT x, const std::vector<NumT>& terms,
+                       NumT reference_frequency_hz = 1.0);
+
+  static long double Evaluate(long double factor, long double exponent,
+                              long double frequency_hz) {
+    return factor * std::pow(frequency_hz, exponent);
+  }
+
+ private:
+  void FitImplementation(std::vector<NumT>& terms, size_t n_terms);
+
+  std::unique_ptr<class NLPLFitterData> data_;
+};
+
+}  // namespace fitters
+}  // namespace schaapcommon
+
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/fitters/polynomialfitter.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/fitters/polynomialfitter.h
@@ -0,0 +1,49 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FITTERS_POLYNOMIAL_FITTER_H_
+#define SCHAAPCOMMON_FITTERS_POLYNOMIAL_FITTER_H_
+
+#include <array>
+#include <vector>
+
+namespace schaapcommon {
+namespace fitters {
+
+class PolynomialFitter {
+ public:
+  using NumT = float;
+
+  void Clear() { data_points_.clear(); }
+
+  void AddDataPoint(NumT x, NumT y, NumT w) {
+    data_points_.emplace_back(std::array<NumT, 3>{{x, y, w}});
+  }
+
+  /**
+   * @param [out] terms The resulting terms.
+   * Using a pre-allocated vector instead of a return value avoids
+   * memory allocations in this performance-critical function.
+   */
+  void Fit(std::vector<NumT>& terms, std::size_t nTerms);
+
+  static NumT Evaluate(NumT x, const std::vector<NumT>& terms) {
+    NumT val = terms[0];
+    NumT f = 1.0;
+    for (std::size_t i = 1; i != terms.size(); ++i) {
+      f *= x;
+      val += f * terms[i];
+    }
+    return val;
+  }
+
+  std::size_t Size() const { return data_points_.size(); }
+
+ private:
+  std::vector<std::array<NumT, 3>> data_points_;
+};
+
+}  // namespace fitters
+}  // namespace schaapcommon
+
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/fitters/spectralfitter.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/fitters/spectralfitter.h
@@ -0,0 +1,116 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_FITTERS_SPECTRAL_FITTER_H_
+#define SCHAAPCOMMON_FITTERS_SPECTRAL_FITTER_H_
+
+#include <vector>
+
+#include <aocommon/image.h>
+
+namespace schaapcommon {
+namespace fitters {
+
+enum class SpectralFittingMode { NoFitting, Polynomial, LogPolynomial };
+
+class SpectralFitter {
+ public:
+  using NumT = float;
+
+  SpectralFitter(SpectralFittingMode mode, size_t n_terms)
+      : mode_(mode), n_terms_(n_terms) {}
+
+  SpectralFittingMode Mode() const { return mode_; }
+
+  void SetMode(SpectralFittingMode mode, size_t n_terms) {
+    mode_ = mode;
+    n_terms_ = n_terms;
+  }
+
+  /**
+   * Fit an array of values to a curve.
+   *
+   * The type of the curve is set in the constructor or with @ref SetMode().
+   * The coordinates are used in case the forced term fitting mode is used, in
+   * which case it is used to look up the spectral index (or other terms) from
+   * a specified image.
+   *
+   * @param [out] terms will hold the fitted terms. The meaning of these terms
+   * depends on the fitted curve type, and are relative to the reference
+   * frequency. Using a pre-allocated vector instead of a return value avoids
+   * memory allocations in this performance-critical function.
+   * @param values array of size @ref NFrequencies() with the values to be
+   * fitted. values[i] should correspond Frequency(i) and Weight(i).
+   * @param x a pixel index giving the horizontal position
+   * @param y a pixel index giving the vertical position
+   */
+  void Fit(std::vector<NumT>& terms, const NumT* values, size_t x,
+           size_t y) const;
+
+  /**
+   * Evaluate the curve at the initialized frequencies.
+   *
+   * @param values array of size @ref NFrequencies() that will be filled with
+   * curve values.
+   * @param terms array of size @ref NTerms() with previously fitted terms.
+   */
+  void Evaluate(NumT* values, const std::vector<NumT>& terms) const;
+
+  /**
+   * Evaluate the curve at a specified frequency.
+   *
+   * @param terms array of size @ref NTerms() with previously fitted terms.
+   * @param frequency Frequency in Hz.
+   */
+  NumT Evaluate(const std::vector<NumT>& terms, double frequency) const;
+
+  /**
+   * Fit an array of values to a curve, and replace those values
+   * with the curve values. This function combines @ref Fit()
+   * and @ref Evaluate().
+   *
+   * @param terms is a UVector of any size, that is used to store the terms.
+   * Having this parameter explicitly is useful to avoid repeated allocation,
+   * to temporarily store the terms: This function is used in the reasonably
+   * critical loops inside deconvolution. It will be resized to @ref NTerms().
+   */
+  void FitAndEvaluate(NumT* values, size_t x, size_t y,
+                      std::vector<NumT>& terms) const {
+    Fit(terms, values, x, y);
+    Evaluate(values, terms);
+  }
+
+  void SetFrequencies(const double* frequencies, const NumT* weights, size_t n);
+
+  double Frequency(size_t index) const { return frequencies_[index]; }
+
+  NumT Weight(size_t index) const { return weights_[index]; }
+
+  size_t NTerms() const { return n_terms_; }
+
+  size_t NFrequencies() const { return frequencies_.size(); }
+
+  double ReferenceFrequency() const { return reference_frequency_; }
+
+  void SetForcedImages(std::vector<aocommon::Image>&& images) {
+    forced_terms_ = std::move(images);
+  }
+
+  bool IsForced() const { return !forced_terms_.empty(); }
+
+ private:
+  void ForcedFit(std::vector<NumT>& terms, const NumT* values, size_t x,
+                 size_t y) const;
+
+  enum SpectralFittingMode mode_;
+  size_t n_terms_;
+  std::vector<double> frequencies_;
+  std::vector<NumT> weights_;
+  double reference_frequency_;
+  std::vector<aocommon::Image> forced_terms_;
+};
+
+}  // namespace fitters
+}  // namespace schaapcommon
+
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/h5parm/h5parm.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/h5parm/h5parm.h
@@ -0,0 +1,98 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_H5PARM_H5PARM_H_
+#define SCHAAPCOMMON_H5PARM_H5PARM_H_
+
+#include "soltab.h"
+
+#include <array>
+#include <utility>
+#include <vector>
+
+namespace schaapcommon {
+namespace h5parm {
+class H5Parm : private H5::H5File {
+ public:
+  struct source_t {
+    char name[128];
+    float dir[2];
+  };
+
+  /// Open existing H5Parm or create a new one
+  /// Default name is given by sol_set_name, if that does not exist continue
+  /// searching for sol000, sol001, etc.
+  /// Only one solset of an H5Parm can be opened at once; this object only
+  /// provides info about one SolSet (even though the file can contain more).
+  explicit H5Parm(const std::string& filename, bool force_new = false,
+                  bool force_new_sol_set = false,
+                  const std::string& sol_set_name = "");
+
+  H5Parm();
+
+  ~H5Parm() override;
+
+  /// Add metadata (directions on the sky in J2000) about named sources
+  void AddSources(const std::vector<std::string>& names,
+                  const std::vector<std::pair<double, double>>& dirs);
+
+  /// Add metadata (positions on earth in ITRF) about antennas
+  void AddAntennas(const std::vector<std::string>& names,
+                   const std::vector<std::array<double, 3>>& positions);
+
+  /// Add metadata about polarizations
+  void AddPolarizations(const std::vector<std::string>& polarizations);
+
+  /// Add a version stamp in the attributes of the group
+  static void AddVersionStamp(H5::Group& node) {
+    SolTab::AddVersionStamp(node);
+  };
+
+  /// Create and return a new soltab. Type is the type as used in BBS
+  SolTab& CreateSolTab(const std::string& name, const std::string& type,
+                       const std::vector<AxisInfo>& axes);
+
+  SolTab& GetSolTab(const std::string& name);
+
+  /// Get the name of the one SolSet used in this H5Parm
+  std::string GetSolSetName() const;
+
+  /// Get the number of SolTabs in the active solset of this h5parm
+  size_t NumSolTabs() const { return sol_tabs_.size(); }
+
+  /// Is the given soltab resent in the active solset of this h5parm
+  bool HasSolTab(const std::string& sol_tab_name) const;
+
+  /// Read the number of sources from the file.
+  size_t GetNumSources() const;
+
+  /// Read sources from the file.
+  std::vector<source_t> GetSources() const;
+
+  /// Get name of the source with coordinates closest to provided (ra, dec)
+  /// coordinates (in J2000)
+  std::string GetNearestSource(double ra, double dec) const;
+
+  /// Is the H5Parm implementation thread safe? If not, H5Parm does not support
+  /// concurrent calls from multiple threads.
+  static bool IsThreadSafe();
+
+ private:
+  struct antenna_t {
+    char name[16];
+    float position[3];
+  };
+
+  struct polarization_t {
+    char name[2];
+  };
+
+  std::vector<source_t> ReadSourceTable(const H5::Group& sol_set) const;
+
+  std::map<std::string, SolTab> sol_tabs_;
+  H5::Group sol_set_;
+};
+}  // namespace h5parm
+}  // namespace schaapcommon
+
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/h5parm/jonesparameters.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/h5parm/jonesparameters.h
@@ -0,0 +1,225 @@
+// Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_H5PARM_JONESPARAMETERS_H_
+#define SCHAAPCOMMON_H5PARM_JONESPARAMETERS_H_
+
+#include <complex>
+#include <vector>
+
+#include "h5parm.h"
+
+#include <casacore/casa/Arrays/Cube.h>
+#include <casacore/casa/Arrays/ArrayMath.h>
+#include <casacore/casa/BasicSL/String.h>
+
+namespace schaapcommon {
+namespace h5parm {
+
+/// @brief Class to extract Jones matrices from an h5parm.
+/// Provides some compatibilty with ParmDB.
+class JonesParameters {
+ public:
+  /**
+   * Type of Jones matrix.
+   * NOTE: SCALARPHASE, SCALARAMPLITUDE, GAIN_RE_IM and FULLJONES_RE_IM are
+   * added to be compatible with ParmDB.
+   */
+  enum CorrectType {
+    GAIN,
+    FULLJONES,
+    SCALARGAIN,
+    TEC,
+    CLOCK,
+    ROTATIONANGLE,
+    SCALARPHASE,
+    PHASE,
+    ROTATIONMEASURE,
+    SCALARAMPLITUDE,
+    AMPLITUDE,
+    GAIN_RE_IM,
+    FULLJONES_RE_IM
+  };
+
+  /**
+   * What to do with missing antennas
+   */
+  enum class MissingAntennaBehavior {
+    kError,  ///< Raise an error on missing antennas
+    kFlag,   ///< Insert flagged parameter values for missing antennas
+    kUnit    ///< Insert a unit Jones matrix for missing antennas
+  };
+
+  /**
+   * Interpolation in time and frequency.
+   */
+  enum class InterpolationType { NEAREST, LINEAR };
+
+  /**
+   * Constructor for JonesParameters with given parm_values. To be used if
+   * parameter values are read externally (e.g. from a ParmDB)
+   * \param freqs Output frequency for sampled values
+   * \param times Output times for sampled values
+   * \param antenna_names Names of the antennas
+   * \param correct_type Correction type of the Jones matrix
+   * \param interpolation_type Interpolation type of the Jones matrix
+   * \param direction Direction number in the H5parm
+   * \param parm_values Parameter values (e.g. TEC values)
+   * \param invert (optional default=false) Invert the parameters
+   * \param sigma_mmse (optional default=0.) Minimum mean square error parameter
+   * (remnant from BBS times, leave at 0 unless you know what you're doing).
+   */
+  JonesParameters(const std::vector<double>& freqs,
+                  const std::vector<double>& times,
+                  const std::vector<std::string>& antenna_names,
+                  CorrectType correct_type,
+                  InterpolationType interpolation_type, hsize_t direction,
+                  std::vector<std::vector<std::vector<double>>>&& parm_values,
+                  bool invert = false, float sigma_mmse = 0.);
+
+  /**
+   * Contructor for JonesParameters. JonesParameters will extract parameter
+   * values itself from an H5Parm.
+   * \param freqs Output frequency for sampled values
+   * \param times Output times for sampled values
+   * \param antenna_names Names of the antennas
+   * \param correct_type Correction type of the Jones matrix
+   * \param interpolation_type Interpolation type of the Jones matrix
+   * \param direction Direction number in the H5parm
+   * \param sol_tab soltab with parameters
+   * \param sol_tab2 (optional default=nullptr) soltab with parameters for
+   * complex values. Shapes of sol_tab and sol_tab2 can differ
+   * \param invert (optional default=false) Invert the parameters
+   * \param sigma_mmse (optional default=0.) Minimum mean square error parameter
+   * (remnant from BBS times, leave at 0 unless you know what you're doing)
+   * \param parm_size (optional default=0) allows to override the vector size
+   * for parm_values
+   * \param missing_antenna_behavior (optional default=kError) what to do with
+   * missing antennas
+   */
+  JonesParameters(const std::vector<double>& freqs,
+                  const std::vector<double>& times,
+                  const std::vector<std::string>& antenna_names,
+                  CorrectType correct_type,
+                  InterpolationType interpolation_type, hsize_t direction,
+                  schaapcommon::h5parm::SolTab* sol_tab,
+                  schaapcommon::h5parm::SolTab* sol_tab2 = nullptr,
+                  bool invert = false, float sigma_mmse = 0.,
+                  unsigned int parm_size = 0,
+                  MissingAntennaBehavior missing_antenna_behavior =
+                      MissingAntennaBehavior::kError);
+
+  /**
+   * Return the Jones matrices as a casacore cube with dimensions (nparms,
+   * nantenna, ntime*nfreq), frequency varies fastest. nparms is 2 for diagonal,
+   * 4 for full jones parameters.
+   */
+  const casacore::Cube<std::complex<float>>& GetParms() const { return parms_; }
+
+  /**
+   * Parse a string into an enum value
+   */
+  static JonesParameters::CorrectType StringToCorrectType(const std::string&);
+
+  /**
+   * Convert CorrectType to string
+   */
+  static std::string CorrectTypeToString(JonesParameters::CorrectType);
+
+  /**
+   * Parse a missing antennabehavior string into an enum value
+   */
+  static MissingAntennaBehavior StringToMissingAntennaBehavior(
+      const std::string&);
+
+  /**
+   * Convert MissingAntennaBehavior enum to string
+   */
+  static std::string MissingAntennaBehaviorToString(MissingAntennaBehavior);
+
+  /**
+   * Parse comma-separated list of (soltab)names into a vector of strings.
+   */
+  [[deprecated(
+      "This function was misused in wsclean, and has been replaced by a direct "
+      "boost::split call -- if it is not used elsewhere it can be "
+      "removed")]] static std::vector<std::string>
+  ParseList(const std::string& list_str);
+
+ private:
+  /**
+   * Fill parms_ with the Jones matrices that correspond to parameters in
+   * parmvalues_. Inverts the Jones matrix if invert is true.
+   * \param ant Antenna number
+   * \param invert (optional default=false) Invert the parameters. This will
+   * ONLY have an effect on RotationMeasure and RotationAngle. Other effects
+   * have to be inverted explicitly by calling Invert()
+   */
+  void MakeComplex(size_t ant, const std::vector<double>& freqs,
+                   CorrectType correct_type, bool invert = false);
+
+  /**
+   * Get the number of parameters for a given @param correct_type.
+   */
+  static unsigned int GetNParms(CorrectType correct_type);
+
+  /**
+   * Get the dimension for parm_values, i.e. the number of parameter names in
+   * the H5Parm.
+   */
+  static unsigned int GetNParmValues(CorrectType correct_type);
+
+  /**
+   * Fill the JonesParameters parameter values from the solution tables
+   * \param sol_tab soltab with parameters
+   * \param sol_tab2 (optional) soltab with parameters for complex values.
+   * Shapes of sol_tab and sol_tab2 can differ
+   * \param freqs Output frequency for sampled values
+   * \param times Output times for sampled values
+   * \param antenna_names Names of the antennas
+   * \param ant Antenna number
+   * \param correct_type Correction type of the Jones matrix
+   * \param interpolation_type Interpolation type of the Jones matrix
+   */
+  void FillParmValues(schaapcommon::h5parm::SolTab* sol_tab,
+                      schaapcommon::h5parm::SolTab* sol_tab2,
+                      const std::vector<double>& freqs,
+                      const std::vector<double>& times,
+                      const std::vector<std::string>& antenna_names, size_t ant,
+                      CorrectType correct_type,
+                      InterpolationType interpolation_type, hsize_t direction);
+
+  /**
+   * Replace values by NaN on places where weight is zero
+   */
+  static void ApplyFlags(std::vector<double>& values,
+                         const std::vector<double>& weights);
+
+  /**
+   *  Static function to invert the complex parameters. Is automatically called
+   * in MakeComplex.
+   * \param parms Reference to the complex parameters that will be inverted
+   * obtained via MakeComplex
+   * \param sigma_mmse (optional default=0.) Minimum mean square error parameter
+   * (remnant from BBS times, leave at 0 unless you know what you're doing).
+   * \param correct_type Correction type of the Jones matrix
+   */
+  static void Invert(casacore::Cube<std::complex<float>>& parms,
+                     float sigma_mmse, CorrectType correct_type);
+
+  /// Parameter values, inner vector has dimension num_times * num_frequencies,
+  /// the middle vector has dimension number_antennas, outer vector has
+  /// dimension num_parameters (e.g. phase and amplitude)
+  /// These are the paramters as they are stored (e.g. TEC values)
+  /// TODO: This probably does not need to be a member
+  std::vector<std::vector<std::vector<double>>> parm_values_;
+  /// Stored Jones matrices, dimensions (nparms, nantenna, ntime*nfreq),
+  /// frequency varies fastest. nparms is 2 for diagonal, 4 for full jones
+  /// parameters.
+  casacore::Cube<std::complex<float>> parms_;
+};
+
+}  // namespace h5parm
+}  // namespace schaapcommon
+
+#endif
Index: wsclean/external/schaapcommon/include/schaapcommon/h5parm/soltab.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/include/schaapcommon/h5parm/soltab.h
@@ -0,0 +1,186 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef SCHAAPCOMMON_H5PARM_SOLTAB_H_
+#define SCHAAPCOMMON_H5PARM_SOLTAB_H_
+
+#include <string>
+#include <vector>
+#include <complex>
+#include <map>
+
+#include <H5Cpp.h>
+
+namespace schaapcommon {
+namespace h5parm {
+
+/// A name and the length of an exis, e.g. ('freq', 800) for 800 frequencies
+struct AxisInfo {
+  std::string name;
+  unsigned int size;
+};
+
+/// @brief SolTab is a solution table as defined in the H5Parm standard. It
+/// contains one solution, e.g. all TEC values, with different axes
+/// for that solution (e.g. time, freq, pol).
+class SolTab : private H5::Group {
+ public:
+  SolTab() = default;
+
+  /// Create a new soltab, add it to its parent
+  SolTab(H5::Group group, const std::string& type,
+         const std::vector<AxisInfo>& axes  /// Axes, fastest varying last
+  );
+
+  /// Create a soltab from a H5::Group (for reading existing files)
+  explicit SolTab(H5::Group& group);
+
+  /// The destructor could check for valid subtables
+  ~SolTab() override;
+
+  /// Add a version stamp in the attributes of the group
+  static void AddVersionStamp(H5::Group& node);
+
+  std::vector<AxisInfo>& GetAxes() { return axes_; }
+
+  const std::vector<AxisInfo>& GetAxes() const { return axes_; }
+
+  AxisInfo GetAxis(unsigned int i) const;
+
+  /// Get an axis, throw an exception if it does not exist
+  AxisInfo GetAxis(const std::string& axis_name) const;
+
+  size_t NumAxes() const { return axes_.size(); }
+
+  bool HasAxis(const std::string& axis_name) const;
+
+  /// Get the index of an axis
+  size_t GetAxisIndex(const std::string& axis_name) const;
+
+  void SetAntennas(const std::vector<std::string>& sol_antennas);
+
+  void SetSources(const std::vector<std::string>& sol_sources);
+
+  void SetPolarizations(const std::vector<std::string>& polarizations);
+
+  void SetFreqs(const std::vector<double>& freqs);
+
+  /// Get the values of a real-valued axis (e.g. "time" or "freq")
+  std::vector<double> GetRealAxis(const std::string& axis_name) const;
+
+  /// Get the values of a string-valued axis (e.g. "dir" or "pol")
+  std::vector<std::string> GetStringAxis(const std::string& axis_name);
+
+  /// Get the index of freq, using nearest neighbor.
+  /// This function assumes that the frequencies are in increasing order.
+  /// @throw std::runtime_error If the frequency is less than a full frequency
+  /// width below the lowest or above the highest frequency
+  hsize_t GetFreqIndex(double freq) const;
+
+  /// Get the index of a time. Matches with 0.5*timeInterval
+  /// This assumes that all times are regularly spaced
+  hsize_t GetTimeIndex(double time) const;
+
+  /// Get the index for a direction name
+  hsize_t GetDirIndex(const std::string& direction_name);
+
+  /// Gets the interval (in s.) between a time slot (default first) and
+  /// the next. Throws error if there is only one time slot.
+  double GetTimeInterval(size_t start = 0) const {
+    return GetInterval("time", start);
+  }
+
+  /// Gets the interval (in s.) between a channel (default first) and
+  /// the next. Throws error if there is only one frequency.
+  double GetFreqInterval(size_t start = 0) const {
+    return GetInterval("freq", start);
+  }
+
+  void SetTimes(const std::vector<double>& times);
+
+  /// Set metadata about an axis (like freq or time))
+  void SetAxisMeta(const std::string& meta_name,
+                   const std::vector<double>& meta_vals);
+
+  /// Set metadata about an axis (like polarization, direction)
+  void SetAxisMeta(const std::string& meta_name, size_t str_len,
+                   const std::vector<std::string>& meta_vals);
+
+  /// Adds a real solution.
+  /// If weights are emtpy, write ones everywhere
+  void SetValues(const std::vector<double>& vals,
+                 const std::vector<double>& weights,
+                 const std::string& history = "");
+
+  /// Add a complex solution, taking either amplitude or phase
+  void SetComplexValues(const std::vector<std::complex<double>>& vals,
+                        const std::vector<double>& weights, bool to_amplitudes,
+                        const std::string& history = "");
+
+  /// Get the name of this SolTab
+  std::string GetName() const;
+
+  std::string GetType() const { return type_; }
+
+  /// Get the values of this SolTab for a given antenna.
+  std::vector<double> GetValues(const std::string& ant_name,
+                                unsigned int starttimeslot, unsigned int ntime,
+                                unsigned int timestep, unsigned int startfreq,
+                                unsigned int nfreq, unsigned int freqstep,
+                                unsigned int pol, unsigned int dir) {
+    return GetValuesOrWeights("val", ant_name, starttimeslot, ntime, timestep,
+                              startfreq, nfreq, freqstep, pol, dir);
+  }
+
+  /// Get the weights of this SolTab for a given antenna.
+  std::vector<double> GetWeights(const std::string& ant_name,
+                                 unsigned int starttimeslot, unsigned int ntime,
+                                 unsigned int timestep, unsigned int startfreq,
+                                 unsigned int nfreq, unsigned int freqstep,
+                                 unsigned int pol, unsigned int dir) {
+    return GetValuesOrWeights("weight", ant_name, starttimeslot, ntime,
+                              timestep, startfreq, nfreq, freqstep, pol, dir);
+  }
+
+  /// Get the values or weights (method made virtual and public to facilitate
+  /// mocking)
+  virtual std::vector<double> GetValuesOrWeights(
+      const std::string& val_or_weight, const std::string& ant_name,
+      const std::vector<double>& times, const std::vector<double>& freqs,
+      unsigned int pol, unsigned int dir, bool nearest);
+
+ private:
+  static double TakeAbs(std::complex<double> c) { return std::abs(c); }
+  static double TakeArg(std::complex<double> c) { return std::arg(c); }
+
+  /// Get the values or weights of this SolTab for a given antenna given an
+  /// antenna name, a direction index, and a (range of) times and frequencies.
+  /// In the returned vector, the freq will be the fastest changing index,
+  /// irrespective of the axis ordering in the underlying h5 data structure.
+  std::vector<double> GetValuesOrWeights(
+      const std::string& val_or_weight, const std::string& ant_name,
+      unsigned int starttimeslot, unsigned int ntime, unsigned int timestep,
+      unsigned int startfreq, unsigned int nfreq, unsigned int freqstep,
+      unsigned int pol, unsigned int dir);
+
+  void ReadAxes();
+
+  void FillCache(std::map<std::string, hsize_t>& cache,
+                 const std::string& table_name);
+
+  /// Get the interval of the axis axis_name
+  double GetInterval(const std::string& axis_name, size_t start = 0) const;
+  hsize_t GetAntIndex(const std::string& ant_name);
+  hsize_t GetNamedIndex(std::map<std::string, hsize_t>& cache,
+                        const std::string& table_name,
+                        const std::string& element_name);
+
+  std::string type_;
+  std::vector<AxisInfo> axes_;
+  std::map<std::string, hsize_t> ant_map_;
+  std::map<std::string, hsize_t> dir_map_;
+};
+}  // namespace h5parm
+}  // namespace schaapcommon
+
+#endif
Index: wsclean/external/schaapcommon/scripts/format.sh
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/scripts/format.sh
@@ -0,0 +1,78 @@
+# Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+# format.sh: Formats source code in a repository in accordance with
+# .clang-format and .cmake-format.py files.
+#
+# This script uses the following variables:
+# - SOURCE_DIR: The directory that contains the source files.
+# - EXCLUDE_DIRS: (Optional) directories that must be excluded from formatting.
+#                 These paths are relative to SOURCE_DIR.
+# - CXX_SOURCES: Patterns of the C++ files, which clang-format should format.
+# - CMAKE_SOURCES: Patterns of the CMake files, which cmake-format should format.
+#
+# A repository that uses format.sh should define its own run-format.sh script
+# that defines these variables and then sources this script.
+# If you want to automatically check formatting in each commit, include the line
+# "./scripts/run-format.sh" to .git/hooks/pre-commit
+# and make sure pre-commit is an executable shell script.
+
+# Disable globbing
+set -e -f
+
+# Check arguments
+if [ -z "$SOURCE_DIR" -o -z "$CXX_SOURCES" -o -z "$CMAKE_SOURCES" ]; then
+  echo "Please define SOURCE_DIR, CXX_SOURCES and CMAKE_SOURCES when using $BASH_SOURCE"
+  exit 1
+fi
+
+# Detect run environment.
+if [ -n "$CI" ]; then
+  DRYRUN=" (dry run on CI)"
+elif [ -n "$GIT_AUTHOR_DATE" ]; then
+  DRYRUN=" (dry run in git hook)"
+fi
+
+# print in bold-face
+echo -e "\e[1mRunning formatters$DRYRUN...\e[0m"
+
+# Convert SOURCES into "-name ext1 -o -name ext2 -o name ext3 ..."
+CXX_FIND_NAMES="-name ${CXX_SOURCES[0]}"
+for i in `seq 1 $((${#CXX_SOURCES[*]} - 1))`; do
+  CXX_FIND_NAMES+=" -o -name ${CXX_SOURCES[$i]}"
+done
+
+CMAKE_FIND_NAMES="-name ${CMAKE_SOURCES[0]}"
+for i in `seq 1 $((${#CMAKE_SOURCES[*]} - 1))`; do
+  CMAKE_FIND_NAMES+=" -o -name ${CMAKE_SOURCES[$i]}"
+done
+
+# Convert EXCLUDE_DIRS into "-path ./dir1 -prune -o -path ./dir2 -prune -o ..."
+FIND_EXCLUDES=
+for e in ${EXCLUDE_DIRS[*]}; do
+  FIND_EXCLUDES+="-path ./$e -prune -o "
+done
+
+cd $SOURCE_DIR
+CXX_FILES=$(find . $FIND_EXCLUDES -type f \( $CXX_FIND_NAMES \) -print)
+CMAKE_FILES=$(find . $FIND_EXCLUDES -type f \( $CMAKE_FIND_NAMES \) -print)
+
+if [ -n "$DRYRUN" ]; then
+  # If the clang-format xml has no replacement entries, all files are formatted.
+  if !(clang-format -style=file --output-replacements-xml $CXX_FILES |
+       grep -q "<replacement ") && cmake-format --check $CMAKE_FILES; then
+    # print in bold-face green
+    echo -e "\e[1m\e[32mGreat job, all files are properly formatted!\e[0m"
+    exit 0;
+  else
+    # Print in bold-face red
+    echo -e "\e[1m\e[31mAt least one file is not properly formatted!\e[0m"
+    echo -e "\e[1m\e[31mRun $0 for formatting all files!\e[0m"
+    exit 1;
+  fi
+else
+  clang-format -i -style=file $CXX_FILES
+  cmake-format -i $CMAKE_FILES
+  # print in bold-face
+  echo -e "\e[1mSuccessfully formatted all files.\e[0m"
+fi
Index: wsclean/external/schaapcommon/scripts/run-format.sh
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/scripts/run-format.sh
@@ -0,0 +1,24 @@
+#!/bin/bash
+
+# Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+#Script configuration for this repo. Adjust it when copying to a different repo.
+
+#The directory that contains the source files.
+SOURCE_DIR=$(dirname "$0")/..
+
+#Directories that must be excluded from formatting. These paths are
+#relative to SOURCE_DIR.
+EXCLUDE_DIRS=(build cmake/external)
+
+#The patterns of the C++ source files, which clang-format should format.
+CXX_SOURCES=(*.cc *.h)
+
+#The patterns of the CMake source files, which cmake-format should format.
+CMAKE_SOURCES=(CMakeLists.txt *.cmake)
+
+#End script configuration.
+
+#The common formatting script has further documentation.
+source $(dirname "$0")/format.sh
Index: wsclean/external/schaapcommon/src/facets/CMakeLists.txt
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/CMakeLists.txt
@@ -0,0 +1,28 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+get_filename_component(MODULE ${CMAKE_CURRENT_SOURCE_DIR} NAME)
+
+set(PUBLIC_HEADER_DIR ${SCHAAPCOMMON_SOURCE_DIR}/include/schaapcommon/${MODULE})
+
+set(PUBLIC_HEADERS "${PUBLIC_HEADER_DIR}/facet.h"
+                   "${PUBLIC_HEADER_DIR}/facetimage.h")
+
+target_sources(
+  ${SCHAAPCOMMON_PROJECT_NAME}
+  PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/facet.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/facetimage.cc)
+
+# Simplifies including the public headers.
+target_include_directories(${SCHAAPCOMMON_PROJECT_NAME}
+                           PRIVATE "$<BUILD_INTERFACE:${PUBLIC_HEADER_DIR}>")
+
+# Install headers and add test directory when built as stand-alone.
+if(SCHAAPCOMMON_MASTER_PROJECT)
+  install(FILES ${PUBLIC_HEADERS}
+          DESTINATION "include/${CMAKE_PROJECT_NAME}/${MODULE}")
+
+  if(BUILD_TESTING)
+    add_subdirectory(test)
+  endif()
+endif()
Index: wsclean/external/schaapcommon/src/facets/facet.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/facet.cc
@@ -0,0 +1,316 @@
+// Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "facet.h"
+
+#include <aocommon/imagecoordinates.h>
+#include <aocommon/io/serialistream.h>
+#include <aocommon/io/serialostream.h>
+
+#include <cassert>
+#include <cmath>
+#include <stdexcept>
+
+#include <boost/geometry.hpp>
+#include <boost/geometry/geometries/register/ring.hpp>
+#include <boost/geometry/geometries/register/point.hpp>
+#include <boost/geometry/geometries/linestring.hpp>
+#include <boost/geometry/algorithms/is_convex.hpp>
+
+// Even though Pixels are int, let boost perform the intersection
+// calculations based on floats to avoid rounding issues
+BOOST_GEOMETRY_REGISTER_POINT_2D(schaapcommon::facets::Pixel, float,
+                                 cs::cartesian, x, y)
+BOOST_GEOMETRY_REGISTER_RING(std::vector<schaapcommon::facets::Pixel>)
+
+namespace schaapcommon {
+namespace facets {
+
+void Coord::Serialize(aocommon::SerialOStream& stream) const {
+  stream.Double(ra).Double(dec);
+}
+
+void Coord::Unserialize(aocommon::SerialIStream& stream) {
+  stream.Double(ra).Double(dec);
+}
+
+void Pixel::Serialize(aocommon::SerialOStream& stream) const {
+  stream.UInt32(x).UInt32(y);
+}
+
+void Pixel::Unserialize(aocommon::SerialIStream& stream) {
+  stream.UInt32(x).UInt32(y);
+}
+
+BoundingBox::BoundingBox(const std::vector<Pixel>& pixels, size_t align,
+                         bool make_square) {
+  if (pixels.empty()) {
+    throw std::invalid_argument("Cannot create boundingbox for 0 pixels");
+  }
+
+  min_ = max_ = pixels.front();
+  for (auto i = pixels.begin() + 1; i != pixels.end(); ++i) {
+    min_.x = std::min(min_.x, i->x);
+    max_.x = std::max(max_.x, i->x);
+    min_.y = std::min(min_.y, i->y);
+    max_.y = std::max(max_.y, i->y);
+  }
+
+  if (make_square) {
+    const size_t width = max_.x - min_.x;
+    const size_t height = max_.y - min_.y;
+    if (width > height) {
+      // Adapt height
+      min_.y -= (width - height) / 2;
+      max_.y = min_.y + width;
+    } else {
+      // Adapt width
+      min_.x -= (height - width) / 2;
+      max_.x = min_.x + height;
+    }
+  }
+
+  if (align > 1) {
+    const size_t width = max_.x - min_.x;
+    const size_t height = max_.y - min_.y;
+    const size_t align_x = width % align ? align - width % align : 0u;
+    const size_t align_y = height % align ? align - height % align : 0u;
+    min_.x -= align_x / 2;
+    min_.y -= align_y / 2;
+    max_.x += (align_x + 1) / 2;
+    max_.y += (align_y + 1) / 2;
+  }
+}
+
+void BoundingBox::Serialize(aocommon::SerialOStream& stream) const {
+  stream.Object(min_).Object(max_);
+}
+
+void BoundingBox::Unserialize(aocommon::SerialIStream& stream) {
+  stream.Object(min_).Object(max_);
+}
+
+std::vector<std::pair<int, int>> Facet::HorizontalIntersections(
+    const int y_intersect) const {
+  std::vector<std::pair<int, int>> result;
+  if (y_intersect < min_y_ || y_intersect >= max_y_) {
+    return result;
+  }
+
+  std::vector<Pixel> poly = pixels_;
+  boost::geometry::correct(poly);
+
+#ifdef HAVE_BOOST_LT_166
+  if (!boost::geometry::is_convex(poly))
+    throw std::runtime_error(
+        "Concave facets are not supported for Boost < 1.66! Make all facets "
+        "convex, or use a newer version of Boost");
+
+  bool found_x1 = false;
+  int x1 = 0;
+  int x2 = 0;
+  size_t i;
+  for (i = 0; i != pixels_.size(); ++i) {
+    const Pixel& p1 = pixels_[i];
+    const Pixel& p2 = pixels_[(i + 1) % pixels_.size()];
+    if ((p1.y <= y_intersect && p2.y > y_intersect) ||
+        (p2.y <= y_intersect && p1.y > y_intersect)) {
+      int x;
+      if (p1.y == y_intersect) {
+        x = p1.x;
+      } else if (p2.y == y_intersect) {
+        x = p2.x;
+      } else {
+        const double beta = double(p2.x - p1.x) / double(p2.y - p1.y);
+        const double xfl = p1.x + beta * (y_intersect - p1.y);
+        x = round(xfl);
+      }
+      if (!found_x1) {
+        x1 = x;
+        found_x1 = true;
+      } else {
+        x2 = x;
+        break;
+      }
+    }
+  }
+
+  // The loop should have found x1 and x2, and then stopped using 'break'.
+  assert(i != pixels_.size());
+  if (x1 != x2) result.push_back(std::minmax(x1, x2));
+#else
+  using Line = boost::geometry::model::linestring<schaapcommon::facets::Pixel>;
+
+  Line l;
+  l.push_back(schaapcommon::facets::Pixel(trimmed_box_.Min().x, y_intersect));
+  l.push_back(schaapcommon::facets::Pixel(trimmed_box_.Max().x, y_intersect));
+  std::vector<Line> intersections;
+  boost::geometry::intersection(l, poly, intersections);
+
+  for (auto intersection : intersections) {
+    result.emplace_back(intersection[0].x, intersection[1].x);
+  }
+#endif
+  return result;
+}
+
+Pixel Facet::Centroid() const {
+  using point_f =
+      boost::geometry::model::point<float, 2, boost::geometry::cs::cartesian>;
+  boost::geometry::model::polygon<point_f> poly;
+
+  point_f x;
+  for (const Pixel& pixel : pixels_) {
+    boost::geometry::append(poly, point_f(pixel.x, pixel.y));
+  }
+  boost::geometry::centroid(poly, x);
+  Pixel p(x.get<0>(), x.get<1>());
+  return p;
+}
+
+void Facet::CalculatePixels(double phase_centre_ra, double phase_centre_dec,
+                            double px_scale_x, double px_scale_y,
+                            size_t image_width, size_t image_height,
+                            double shift_l, double shift_m, double padding,
+                            size_t align, bool make_square) {
+  if (padding < 1.0) {
+    throw std::invalid_argument("Padding factor should be >= 1.0");
+  }
+  if ((align > 1) && ((image_width % align) || (image_height % align))) {
+    throw std::invalid_argument("Image is not aligned");
+  }
+  if (coords_.size() < 3) {
+    throw std::runtime_error("Number of coordinates < 3, facet incomplete!");
+  }
+
+  pixels_.clear();
+  pixels_.reserve(coords_.size());
+  bool need_clip = false;
+  for (const Coord& coord : coords_) {
+    double l, m;
+    int x, y;
+    aocommon::ImageCoordinates::RaDecToLM(coord.ra, coord.dec, phase_centre_ra,
+                                          phase_centre_dec, l, m);
+    l -= shift_l;
+    m -= shift_m;
+    aocommon::ImageCoordinates::LMToXY(l, m, px_scale_x, px_scale_y,
+                                       image_width, image_height, x, y);
+
+    if (!need_clip && (x < 0 || x > static_cast<int>(image_width) || y < 0 ||
+                       y > static_cast<int>(image_height))) {
+      need_clip = true;
+    }
+    pixels_.emplace_back(x, y);
+  }
+
+  if (need_clip) {
+    std::vector<Pixel> image_box{Pixel(0, 0), Pixel(0, image_height),
+                                 Pixel(image_width, image_height),
+                                 Pixel(image_width, 0), Pixel(0, 0)};
+    pixels_ = PolygonIntersection(pixels_, image_box);
+  }
+
+  // Calculate bounding box for the pixels only, and set min_y_ and max_y_.
+  BoundingBox pixel_box(pixels_);
+  min_y_ = pixel_box.Min().y;
+  max_y_ = pixel_box.Max().y;
+
+  // Calculate the trimmed_box_.
+  trimmed_box_ =
+      BoundingBox({pixel_box.Min(), pixel_box.Max()}, align, make_square);
+
+  // Calculate the untrimmed_box_.
+  auto width = static_cast<size_t>(std::ceil(trimmed_box_.Width() * padding));
+  auto height = static_cast<size_t>(std::ceil(trimmed_box_.Height() * padding));
+
+  // Calculate padding. Divide by two since the padding occurs at both sides.
+  const Pixel pad((width - trimmed_box_.Width()) / 2,
+                  (height - trimmed_box_.Height()) / 2);
+
+  // Create the padded, squared and aligned bounding box for the facet.
+  untrimmed_box_ = BoundingBox(
+      {trimmed_box_.Min() - pad, trimmed_box_.Max() + pad}, align, make_square);
+
+  // Calculate customized facet direction pixel
+  if (std::isnan(dir_.ra) || std::isnan(dir_.dec)) {
+    double l;
+    double m;
+
+    const Pixel centroid = Centroid();
+    aocommon::ImageCoordinates::XYToLM(centroid.x, centroid.y, px_scale_x,
+                                       px_scale_x, image_width, image_height, l,
+                                       m);
+    l += shift_l;
+    m += shift_m;
+    aocommon::ImageCoordinates::LMToRaDec(l, m, phase_centre_ra,
+                                          phase_centre_dec, dir_.ra, dir_.dec);
+  }
+}
+
+std::vector<Pixel> Facet::PolygonIntersection(std::vector<Pixel> poly1,
+                                              std::vector<Pixel> poly2) {
+  // Make polygons clockwise and append closing point when needed.
+  // This is the reason why poly1 and poly2 are passed by value.
+  boost::geometry::correct(poly1);
+  boost::geometry::correct(poly2);
+
+  std::vector<std::vector<Pixel>> poly_results;
+  boost::geometry::intersection<std::vector<Pixel>, std::vector<Pixel>>(
+      poly1, poly2, poly_results);
+  if (poly_results.size() != 1) {
+    throw std::runtime_error("Expected 1 intersecting polygon, but found " +
+                             std::to_string(poly_results.size()));
+  }
+  // Return intersection points, except for closing point.
+  poly_results.front().resize(poly_results.front().size() - 1);
+  return std::move(poly_results.front());
+}
+
+bool Facet::Contains(const Pixel& pixel) const {
+  std::vector<Pixel> polygon = pixels_;
+  boost::geometry::correct(polygon);
+
+  bool inClosedPolygon = boost::geometry::covered_by(pixel, polygon);
+
+  if (!inClosedPolygon) {
+    return false;
+  } else {
+    // Pixel is in the closed polygon, but we should exclude it from
+    // zero-length corners and edges that are "owned" by another facet
+    const std::vector<std::pair<int, int>> intersections =
+        HorizontalIntersections(pixel.y);
+    if (intersections.empty()) return false;
+
+    for (const auto& isect : intersections) {
+      if (isect.second == pixel.x) {
+        return false;
+      }
+    }
+    return true;
+  }
+}
+
+void Facet::Serialize(aocommon::SerialOStream& stream) const {
+  stream.ObjectVector(coords_)
+      .ObjectVector(pixels_)
+      .UInt32(min_y_)
+      .UInt32(max_y_)
+      .Object(dir_)
+      .String(direction_label_)
+      .Object(trimmed_box_)
+      .Object(untrimmed_box_);
+}
+
+void Facet::Unserialize(aocommon::SerialIStream& stream) {
+  stream.ObjectVector(coords_)
+      .ObjectVector(pixels_)
+      .UInt32(min_y_)
+      .UInt32(max_y_)
+      .Object(dir_)
+      .String(direction_label_)
+      .Object(trimmed_box_)
+      .Object(untrimmed_box_);
+}
+
+}  // namespace facets
+}  // namespace schaapcommon
Index: wsclean/external/schaapcommon/src/facets/facetimage.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/facetimage.cc
@@ -0,0 +1,163 @@
+// Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "facetimage.h"
+
+#include <algorithm>
+#include <functional>
+
+namespace schaapcommon {
+namespace facets {
+
+FacetImage::FacetImage(size_t image_width, size_t image_height,
+                       size_t nr_spectral_terms)
+    : data_(nr_spectral_terms),
+      image_width_(image_width),
+      image_height_(image_height),
+      box_(),
+      horizontal_intersections_() {
+  if (nr_spectral_terms == 0 || image_width == 0 || image_height == 0) {
+    throw std::invalid_argument("Zero terms/width/height in FacetImage()");
+  }
+}
+
+void FacetImage::SetFacet(const Facet& facet, bool trimmed) {
+  box_ =
+      trimmed ? facet.GetTrimmedBoundingBox() : facet.GetUntrimmedBoundingBox();
+
+  const size_t data_size = box_.Width() * box_.Height();
+  for (std::vector<float>& values : data_) {
+    values.assign(data_size, 0.0);
+  }
+
+  SetHorizontalIntersections(facet);
+}
+
+FacetImage& FacetImage::operator*=(float factor) {
+  for (size_t term = 0; term != data_.size(); ++term) {
+    for (auto& val : data_[term]) val *= factor;
+  }
+  return *this;
+}
+
+void FacetImage::CopyToFacet(
+    const std::vector<aocommon::UVector<float>>& images) {
+  std::vector<const float*> images_ptr;
+  for (const aocommon::UVector<float>& image : images) {
+    if (image.size() != image_width_ * image_height_) {
+      throw std::invalid_argument(
+          "Image size does not match the specified width and height.");
+    }
+    images_ptr.push_back(image.data());
+  }
+  CopyToFacet(images_ptr);
+}
+
+void FacetImage::CopyToFacet(const std::vector<const float*>& images) {
+  if (images.size() != data_.size()) {
+    throw std::invalid_argument(
+        "Image term count does not match facet term count.");
+  }
+
+  if (data_.front().empty()) {
+    throw std::runtime_error(
+        "Facet data buffer is not initialized. Call SetFacet() first.");
+  }
+
+  for (size_t term = 0; term != images.size(); ++term) {
+    float* data_y = data_[term].data();
+    const float* image_y = images[term] + OffsetY() * image_width_;
+
+    for (const std::vector<std::pair<int, int>>& intersections :
+         horizontal_intersections_) {
+      for (const std::pair<int, int>& intersection : intersections) {
+        std::copy_n(image_y + intersection.first,
+                    intersection.second - intersection.first,
+                    data_y + intersection.first - OffsetX());
+      }
+      data_y += Width();
+      image_y += image_width_;
+    }
+  }
+}
+
+void FacetImage::AddToImage(const std::vector<float*>& images) const {
+  if (images.size() != data_.size()) {
+    throw std::invalid_argument(
+        "Image term count does not match facet term count.");
+  }
+
+  if (data_.front().empty()) {
+    throw std::runtime_error(
+        "Facet data buffer is not initialized. Call SetFacet() first.");
+  }
+
+  for (size_t term = 0; term != data_.size(); ++term) {
+    const float* data_y = data_[term].data();
+    float* image_y = images[term] + OffsetY() * image_width_;
+
+    for (const std::vector<std::pair<int, int>>& intersections :
+         horizontal_intersections_) {
+      for (const std::pair<int, int>& intersection : intersections) {
+        const float* facet_begin = data_y + intersection.first - OffsetX();
+        const float* facet_end = data_y + intersection.second - OffsetX();
+        float* image_begin = image_y + intersection.first;
+
+        // Do an addition-assignment
+        std::transform(facet_begin, facet_end, image_begin, image_begin,
+                       std::plus<float>());
+      }
+      data_y += Width();
+      image_y += image_width_;
+    }
+  }
+}
+
+void FacetImage::MultiplyImageInsideFacet(std::vector<float*>& images,
+                                          float factor) const {
+  if (images.size() != data_.size()) {
+    throw std::invalid_argument(
+        "Image term count does not match facet term count.");
+  }
+
+  if (horizontal_intersections_.empty()) {
+    throw std::runtime_error(
+        "Horizontal intersections are not initialized. Call SetFacet() first.");
+  }
+
+  for (size_t term = 0; term != data_.size(); ++term) {
+    float* image_y = images[term] + OffsetY() * image_width_;
+
+    for (const std::vector<std::pair<int, int>>& intersections :
+         horizontal_intersections_) {
+      for (const std::pair<int, int>& intersection : intersections) {
+        float* image_begin = image_y + intersection.first;
+        float* image_end = image_y + intersection.second;
+        // Multiply range with factor
+        std::for_each(image_begin, image_end,
+                      [factor](float& pixel) { pixel *= factor; });
+      }
+      image_y += image_width_;
+    }
+  }
+}
+
+void FacetImage::SetHorizontalIntersections(const Facet& facet) {
+  // Pre-calculate horizontal intersections for each y value.
+  // Check that all intersections are within the main image.
+  horizontal_intersections_.clear();
+  horizontal_intersections_.reserve(box_.Height());
+  for (int y = box_.Min().y; y != box_.Max().y; ++y) {
+    auto isects = facet.HorizontalIntersections(y);
+    for (const std::pair<int, int>& isect : isects) {
+      if (isect.first < 0 || isect.second > static_cast<int>(image_width_) ||
+          y < 0 || y > static_cast<int>(image_height_)) {
+        throw std::invalid_argument("Facet does not fit in main image.");
+      }
+    }
+    horizontal_intersections_.push_back(std::move(isects));
+  }
+}
+
+}  // namespace facets
+}  // namespace schaapcommon
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/facets/test/CMakeLists.txt
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/test/CMakeLists.txt
@@ -0,0 +1,10 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+include(${SCHAAPCOMMON_SOURCE_DIR}/cmake/unittest.cmake)
+
+add_unittest(facets runtests.cc tfacet.cc tfacetimage.cc tds9facetfile.cc)
+
+# Copy test resources.
+configure_file(resources/foursources.reg
+               ${CMAKE_BINARY_DIR}/src/facets/test/foursources.reg COPYONLY)
Index: wsclean/external/schaapcommon/src/facets/test/resources/foursources.reg
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/test/resources/foursources.reg
@@ -0,0 +1,31 @@
+# Region file format: DS9 version 4.1
+global color=green dashlist=8 3 width=1 font="helvetica 10 normal roman" select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
+fk5
+
+# The polygons below were created manually. They create areas around each of the image points.
+# The comments below contain the corresponding 0-based pixel coordinates.
+
+# The 'point' values are artifical values, for testing DS9FacetFile only.
+# These points are selected such that they coincide with one of the vertices that
+# are not located on the boundary.
+
+# Ra+dec@(400,64). Polygon is (379,-9) (377,91) (548,95) (551,-5).
+polygon(23.0,30.5, 23.0,31.5, 21.0,31.5, 21.0,30.5) # text=CygA
+point(23.0,31.5)
+
+# Ra@(400,256). Polygon is (364,129) (366,301) (541,305) (547,128).
+polygon(23.15,31.88, 23.10,33.6, 21.0,33.6, 21.0,31.83) # text=CygAO
+point(23.10,33.6)
+
+# Dec@(256,64). Polygon is (128,-9) (128,128) (384,128) (384,-9).
+polygon(25.91,30.5, 25.93,31.87, 22.92,31.87, 22.94,30.5) # text=CygTJ
+# Test that the reader uses the last point when supplying multiple.
+point(0, 0)
+point(22.92,31.87)
+
+# Center@(256,256). Polygon is (160,160) (160,352) (352,352) (352,160).
+polygon(25.56,32.19 25.58,34.11, 23.26,34.11, 23.29,32.19)
+# No explicit point -> RA() and Dec() should be nan.
+
+# For debugging: Region that covers everything.
+#polygon(33.0,27.0, 33.0,40.0, 17.0,40.0, 17.0,27.0)
Index: wsclean/external/schaapcommon/src/facets/test/runtests.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/test/runtests.cc
@@ -0,0 +1,6 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#define BOOST_TEST_MODULE schaapcommon_facets
+
+#include <boost/test/unit_test.hpp>
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/facets/test/tds9facetfile.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/test/tds9facetfile.cc
@@ -0,0 +1,117 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include <boost/test/unit_test.hpp>
+
+#include "ds9facetfile.h"
+#include "facet.h"
+#include "tfacet.h"
+
+using schaapcommon::facets::DS9FacetFile;
+using schaapcommon::facets::Facet;
+
+BOOST_AUTO_TEST_SUITE(tds9facetfile)
+
+BOOST_AUTO_TEST_CASE(direction_comment) {
+  std::string dir = DS9FacetFile::ParseDirectionLabel(
+      DS9FacetFile::TokenType::kComment, "text=CygA, color=green");
+
+  BOOST_CHECK_EQUAL(dir, "CygA");
+}
+
+BOOST_AUTO_TEST_CASE(direction_comment_reversed) {
+  std::string dir = DS9FacetFile::ParseDirectionLabel(
+      DS9FacetFile::TokenType::kComment, "color=green, text=CygA");
+
+  BOOST_CHECK_EQUAL(dir, "CygA");
+}
+
+BOOST_AUTO_TEST_CASE(direction_empty) {
+  std::string dir = DS9FacetFile::ParseDirectionLabel(
+      DS9FacetFile::TokenType::kComment, "some other comment");
+
+  BOOST_CHECK(dir.empty());
+}
+
+BOOST_AUTO_TEST_CASE(direction_wrong_type) {
+  std::string dir = DS9FacetFile::ParseDirectionLabel(
+      DS9FacetFile::TokenType::kWord, "text=CygA");
+
+  BOOST_CHECK(dir.empty());
+}
+
+// Check if facets are correctly read from DS9 regions file
+BOOST_AUTO_TEST_CASE(read_from_file) {
+  DS9FacetFile facet_file("foursources.reg");
+  DS9FacetFile facet_file_shared("foursources.reg");
+
+  // Values copied from DP3 integration test
+  const double ra = 0.426246;
+  const double dec = 0.578747;
+  const double px_scale_x = 0.000174533;
+  const double px_scale_y = px_scale_x;
+  const size_t full_width = 512;
+  const size_t full_height = full_width;
+
+  std::vector<Facet> facets_out = facet_file.Read();
+  std::vector<std::shared_ptr<Facet>> facets_shared =
+      facet_file_shared.ReadShared();
+
+  BOOST_CHECK_EQUAL(facets_out.size(), 4);
+  BOOST_CHECK_EQUAL(facets_shared.size(), 4);
+
+  for (Facet& facet : facets_out) {
+    facet.CalculatePixels(ra, dec, px_scale_x, px_scale_y, full_width,
+                          full_height, 0.0, 0.0);
+  }
+  for (std::shared_ptr<Facet>& facet : facets_shared) {
+    facet->CalculatePixels(ra, dec, px_scale_x, px_scale_y, full_width,
+                           full_height, 0.0, 0.0);
+  }
+
+  // Text labels
+  const std::array<std::string, 4> kDirectionLabels{"CygA", "CygAO", "CygTJ",
+                                                    ""};
+  // 'point' values from foursources.reg, converted to radians.
+  const std::array<double, 4> kFacetRa{
+      23.0 * M_PI / 180.0, 23.10 * M_PI / 180.0, 22.92 * M_PI / 180.0};
+  const std::array<double, 4> kFacetDec{
+      31.5 * M_PI / 180.0, 33.6 * M_PI / 180.0, 31.87 * M_PI / 180.0};
+
+  // Expected bounding box values for the facets.
+  const std::array<int, 4> bbox_xmin = {377, 364, 128, 160};
+  const std::array<int, 4> bbox_xmax = {512, 512, 384, 352};
+  const std::array<int, 4> bbox_ymin = {0, 128, 0, 160};
+  const std::array<int, 4> bbox_ymax = {94, 304, 128, 352};
+
+  for (size_t idx = 0; idx < facets_out.size(); ++idx) {
+    BOOST_CHECK_EQUAL(facets_out[idx].DirectionLabel(), kDirectionLabels[idx]);
+    if (idx < 3) {
+      BOOST_CHECK_CLOSE(facets_out[idx].RA(), kFacetRa[idx], 1.0e-6);
+      BOOST_CHECK_CLOSE(facets_out[idx].Dec(), kFacetDec[idx], 1.0e-6);
+      BOOST_CHECK_CLOSE(facets_shared[idx]->RA(), kFacetRa[idx], 1.0e-6);
+      BOOST_CHECK_CLOSE(facets_shared[idx]->Dec(), kFacetDec[idx], 1.0e-6);
+    }
+
+    const schaapcommon::facets::BoundingBox box =
+        facets_out[idx].GetUntrimmedBoundingBox();
+    const schaapcommon::facets::BoundingBox box_shared =
+        facets_shared[idx]->GetUntrimmedBoundingBox();
+
+    BOOST_CHECK_EQUAL(box.Min().x, bbox_xmin[idx]);
+    BOOST_CHECK_EQUAL(box.Max().x, bbox_xmax[idx]);
+    BOOST_CHECK_EQUAL(box.Min().y, bbox_ymin[idx]);
+    BOOST_CHECK_EQUAL(box.Max().y, bbox_ymax[idx]);
+    BOOST_CHECK_EQUAL(box_shared.Min().x, bbox_xmin[idx]);
+    BOOST_CHECK_EQUAL(box_shared.Max().x, bbox_xmax[idx]);
+    BOOST_CHECK_EQUAL(box_shared.Min().y, bbox_ymin[idx]);
+    BOOST_CHECK_EQUAL(box_shared.Max().y, bbox_ymax[idx]);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(file_does_not_exist) {
+  BOOST_CHECK_THROW(DS9FacetFile facet_file("does-not-exist.reg"),
+                    std::runtime_error);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: wsclean/external/schaapcommon/src/facets/test/tfacet.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/test/tfacet.cc
@@ -0,0 +1,743 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include <boost/test/unit_test.hpp>
+
+#include "tfacet.h"
+
+#include <aocommon/io/serialistream.h>
+#include <aocommon/io/serialostream.h>
+#include <aocommon/imagecoordinates.h>
+
+using schaapcommon::facets::BoundingBox;
+using schaapcommon::facets::Coord;
+using schaapcommon::facets::Facet;
+using schaapcommon::facets::Pixel;
+
+namespace {
+const double kScale = 0.001;
+const size_t kImageSize = 100;
+
+/**
+ * Creates a facet with a diamond shape.
+ */
+Facet CreateDiamondFacet(int offset_x = 0, int offset_y = 0,
+                         bool set_custom_direction = false) {
+  Facet facet;
+
+  const std::vector<Coord> coords{
+      {0.02, 0.0}, {0.0, 0.01}, {-0.02, 0.0}, {0.0, -0.01}};
+  for (const Coord& c : coords) {
+    facet.AddVertex(c.ra, c.dec);
+  }
+
+  const double ra = offset_x * kScale;
+  const double dec = -offset_y * kScale;
+  const double l = 0.0;
+  const double m = 0.0;
+  if (set_custom_direction) {
+    facet.SetRA(-0.02);
+    facet.SetDec(0.01);
+  }
+  facet.CalculatePixels(ra, dec, kScale, kScale, kImageSize, kImageSize, l, m);
+
+  return facet;
+}
+
+/**
+ * Creates a facet with a rectangular shape.
+ */
+Facet CreateRectangularFacet(double padding, size_t align, bool make_square) {
+  Facet facet;
+
+  const std::vector<Coord> coords{
+      {0.01, -0.02}, {0.01, 0.02}, {-0.01, 0.02}, {-0.01, -0.02}};
+  for (const Coord& c : coords) {
+    facet.AddVertex(c.ra, c.dec);
+  }
+
+  const double ra = 0.0, dec = 0.0, l = 0.0, m = 0.0;
+  facet.CalculatePixels(ra, dec, kScale, kScale, kImageSize, kImageSize, l, m,
+                        padding, align, make_square);
+  const std::vector<Pixel>& pixels = facet.GetPixels();
+  BOOST_REQUIRE_EQUAL(pixels.size(), 4u);
+  BOOST_CHECK_EQUAL(pixels[0], Pixel(40, 30));
+  BOOST_CHECK_EQUAL(pixels[1], Pixel(40, 70));
+  BOOST_CHECK_EQUAL(pixels[2], Pixel(60, 70));
+  BOOST_CHECK_EQUAL(pixels[3], Pixel(60, 30));
+
+  return facet;
+}
+
+/**
+ * Creates a concave facet at given x/y offset, with shape
+ *    o   o
+ *   / \ / \
+ *  o   o   o
+ *   \     /
+ *    \   /
+ *      o
+ */
+Facet CreateConcaveFacet(int offset_x = 0, int offset_y = 0) {
+  Facet facet;
+  const std::vector<Coord> coords{{0.02, 0.0},   {0.0, -0.02}, {-0.02, 0.0},
+                                  {-0.01, 0.01}, {0.0, 0.0},   {0.01, 0.01}};
+  for (const Coord& c : coords) {
+    facet.AddVertex(c.ra, c.dec);
+  }
+
+  const double ra = offset_x * kScale;
+  const double dec = -offset_y * kScale;
+  const double l = 0.0;
+  const double m = 0.0;
+  facet.CalculatePixels(ra, dec, kScale, kScale, kImageSize, kImageSize, l, m);
+  return facet;
+}
+
+/**
+ * Creates a pair of connected facets, to check whether the
+ * calculated facet-line intersections seamlessly match across facet boundaries
+ *  o--- o---------o
+ *  |     \        |
+ *  |   1  \   2   |
+ *  |       \      |
+ *  o -------o-----o
+ *
+ */
+std::pair<Facet, Facet> CreateConnectedFacets() {
+  Facet facet1, facet2;
+  const std::vector<Coord> coords1{
+      {0.05, -0.05}, {0.05, -0.043}, {0.043, -0.041}, {0.041, -0.05}};
+  const std::vector<Coord> coords2{
+      {0.043, -0.041}, {0.034, -0.043}, {0.034, -0.05}, {0.041, -0.05}};
+
+  for (const Coord& c : coords1) {
+    facet1.AddVertex(c.ra, c.dec);
+  }
+
+  for (const Coord& c : coords2) {
+    facet2.AddVertex(c.ra, c.dec);
+  }
+
+  const double ra = 0.0;
+  const double dec = 0.0;
+  const double l = 0.0;
+  const double m = 0.0;
+  facet1.CalculatePixels(ra, dec, kScale, kScale, kImageSize, kImageSize, l, m);
+  facet2.CalculatePixels(ra, dec, kScale, kScale, kImageSize, kImageSize, l, m);
+
+  return std::make_pair(facet1, facet2);
+}
+
+void CheckBoundingBoxes(const Facet& facet, const Pixel& trimmed_min,
+                        const Pixel& trimmed_max, const Pixel& untrimmed_min,
+                        const Pixel& untrimmed_max) {
+  const BoundingBox& trimmed_box = facet.GetTrimmedBoundingBox();
+  BOOST_CHECK_EQUAL(trimmed_box.Min(), trimmed_min);
+  BOOST_CHECK_EQUAL(trimmed_box.Max(), trimmed_max);
+
+  const BoundingBox& untrimmed_box = facet.GetUntrimmedBoundingBox();
+  BOOST_CHECK_EQUAL(untrimmed_box.Min(), untrimmed_min);
+  BOOST_CHECK_EQUAL(untrimmed_box.Max(), untrimmed_max);
+}
+
+void CheckIntersections(const Facet& facet, int y,
+                        const std::vector<std::pair<int, int>>& ref) {
+  std::vector<std::pair<int, int>> isects = facet.HorizontalIntersections(y);
+  BOOST_CHECK_EQUAL(isects.size(), ref.size());
+  for (size_t i = 0; i != isects.size(); ++i) {
+    BOOST_CHECK_EQUAL(isects[i].first, ref[i].first);
+    BOOST_CHECK_EQUAL(isects[i].second, ref[i].second);
+  }
+}
+
+}  // namespace
+
+BOOST_AUTO_TEST_SUITE(facet)
+
+BOOST_AUTO_TEST_CASE(pixel_operators) {
+  const Pixel p1(4, 2);
+  const Pixel p2(2, 1);
+
+  BOOST_CHECK(p1 != p2);
+  const Pixel p3 = p2 + p2;
+  BOOST_CHECK(p1 == p3);
+  const Pixel p4 = p3 - p2;
+  BOOST_CHECK(p4 == p2);
+}
+
+BOOST_AUTO_TEST_CASE(bounding_box_empty) {
+  const BoundingBox box;
+  BOOST_CHECK_EQUAL(box.Min(), Pixel(0, 0));
+  BOOST_CHECK_EQUAL(box.Max(), Pixel(0, 0));
+  BOOST_CHECK_EQUAL(box.Width(), 0);
+  BOOST_CHECK_EQUAL(box.Height(), 0);
+  BOOST_CHECK_EQUAL(box.Centre(), Pixel(0, 0));
+}
+
+BOOST_AUTO_TEST_CASE(bounding_box_no_alignment) {
+  const std::vector<Pixel> pixels{{-1, -20}, {4, 2}, {0, 5}};
+  const BoundingBox box(pixels);
+  BOOST_CHECK_EQUAL(box.Min(), Pixel(-1, -20));
+  BOOST_CHECK_EQUAL(box.Max(), Pixel(4, 5));
+  BOOST_CHECK_EQUAL(box.Width(), 5);
+  BOOST_CHECK_EQUAL(box.Height(), 25);
+  BOOST_CHECK_EQUAL(box.Centre(),
+                    Pixel(1, -7));  // Centre is rounded towards 0.
+}
+
+BOOST_AUTO_TEST_CASE(bounding_box_aligned) {
+  const std::vector<Pixel> pixels{{-1, -20}, {4, 2}, {0, 5}};
+  const size_t align = 4;
+  const BoundingBox box(pixels, align);
+  BOOST_CHECK_EQUAL(box.Min(), Pixel(-2, -21));
+  BOOST_CHECK_EQUAL(box.Max(), Pixel(6, 7));
+  BOOST_CHECK_EQUAL(box.Width() % align, 0);
+  BOOST_CHECK_EQUAL(box.Height() % align, 0);
+  BOOST_CHECK_EQUAL(box.Centre(), Pixel(2, -7));
+}
+
+BOOST_AUTO_TEST_CASE(point_in_bounding_box) {
+  const std::vector<Pixel> pixels{{0, 0}, {0, 10}, {10, 10}, {10, 0}};
+  const BoundingBox box(pixels);
+
+  BOOST_CHECK(box.Contains(Pixel(5, 5)));
+  BOOST_CHECK(!box.Contains(Pixel(10, 10)));
+}
+
+BOOST_AUTO_TEST_CASE(polygon_empty_intersection) {
+  const std::vector<Pixel> poly1{{0, 0}, {0, 10}, {10, 10}, {10, 0}};
+  const std::vector<Pixel> poly2{{11, 11}, {11, 20}, {20, 20}, {20, 11}};
+  // PolygonIntersection should only be invoked in case there is one
+  // intersection
+  BOOST_CHECK_THROW(Facet::PolygonIntersection(poly1, poly2),
+                    std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(polygon_one_intersection) {
+  // Ordering for poly1 and poly2 is on purpose clockwise and anti-clockwise,
+  // respectively
+  const std::vector<Pixel> poly1{{0, 0}, {0, 10}, {10, 10}, {10, 0}};
+  const std::vector<Pixel> poly2{{5, 5}, {15, 5}, {15, 15}, {5, 15}};
+  std::vector<Pixel> poly3 = Facet::PolygonIntersection(poly1, poly2);
+  BOOST_CHECK_EQUAL(poly3[0], Pixel(5, 10));
+  BOOST_CHECK_EQUAL(poly3[1], Pixel(10, 10));
+  BOOST_CHECK_EQUAL(poly3[2], Pixel(10, 5));
+  BOOST_CHECK_EQUAL(poly3[3], Pixel(5, 5));
+}
+
+BOOST_AUTO_TEST_CASE(polygon_two_intersections) {
+  const std::vector<Pixel> poly1{{0, 0}, {0, 10}, {10, 10}, {2, 5}, {10, 0}};
+  const std::vector<Pixel> poly2{{5, 0}, {5, 10}, {15, 10}, {15, 0}};
+  // Intersection would result in two polygons, which is not allowed
+  BOOST_CHECK_THROW(Facet::PolygonIntersection(poly1, poly2),
+                    std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(constructor) {
+  Facet facet;
+
+  // BOOST_CHECK_EQUAL(facet.RA(), );
+  BOOST_CHECK(std::isnan(facet.RA()));
+  // BOOST_CHECK_EQUAL(facet.Dec(), 0.0);
+  BOOST_CHECK(std::isnan(facet.Dec()));
+  BOOST_CHECK(facet.GetPixels().empty());
+  BOOST_CHECK(facet.DirectionLabel().empty());
+
+  CheckBoundingBoxes(facet, Pixel(0, 0), Pixel(0, 0), Pixel(0, 0), Pixel(0, 0));
+  BOOST_CHECK_THROW(facet.CalculatePixels(0.0, 0.0, kScale, kScale, kImageSize,
+                                          kImageSize, 0.0, 0.0),
+                    std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(pixel_positions) {
+  Facet facet;
+
+  const std::vector<Coord> coords{{0, 0}, {0, 0.02}, {0.02, 0.02}, {0.02, 0}};
+  for (const Coord& c : coords) {
+    facet.AddVertex(c.ra, c.dec);
+  }
+
+  {
+    const double ra = 0.0, dec = 0.0, l = 0.0, m = 0.0;
+    facet.CalculatePixels(ra, dec, kScale, kScale, kImageSize, kImageSize, l,
+                          m);
+    const std::vector<Pixel>& pixels = facet.GetPixels();
+    BOOST_REQUIRE_EQUAL(pixels.size(), 4u);
+    BOOST_CHECK_EQUAL(pixels[0], Pixel(50, 50));
+    BOOST_CHECK_EQUAL(pixels[1], Pixel(50, 70));
+    BOOST_CHECK_EQUAL(pixels[2], Pixel(30, 70));
+    BOOST_CHECK_EQUAL(pixels[3], Pixel(30, 50));
+  }
+
+  {
+    const double ra = 0.0, dec = 0.0, l = 0.01, m = 0.02;
+    facet.CalculatePixels(ra, dec, kScale, kScale, kImageSize, kImageSize, l,
+                          m);
+    const std::vector<Pixel>& pixels = facet.GetPixels();
+    BOOST_REQUIRE_EQUAL(pixels.size(), 4u);
+    BOOST_CHECK_EQUAL(pixels[0], Pixel(60, 30));
+    BOOST_CHECK_EQUAL(pixels[1], Pixel(60, 50));
+    BOOST_CHECK_EQUAL(pixels[2], Pixel(40, 50));
+    BOOST_CHECK_EQUAL(pixels[3], Pixel(40, 30));
+  }
+
+  {
+    const double ra = 0.02, dec = 0.01, l = 0.0, m = 0.0;
+    facet.CalculatePixels(ra, dec, kScale, kScale, kImageSize, kImageSize, l,
+                          m);
+    const std::vector<Pixel>& pixels = facet.GetPixels();
+    BOOST_REQUIRE_EQUAL(pixels.size(), 4u);
+    BOOST_CHECK_EQUAL(pixels[0], Pixel(70, 40));
+    BOOST_CHECK_EQUAL(pixels[1], Pixel(70, 60));
+    BOOST_CHECK_EQUAL(pixels[2], Pixel(50, 60));
+    BOOST_CHECK_EQUAL(pixels[3], Pixel(50, 40));
+  }
+}
+
+// Create a diamond facet in the center, so no clipping occurs.
+BOOST_AUTO_TEST_CASE(no_clipping) {
+  Facet facet = CreateDiamondFacet();
+
+  const std::vector<Pixel>& pixels = facet.GetPixels();
+  BOOST_REQUIRE_EQUAL(pixels.size(), 4u);
+  BOOST_CHECK_EQUAL(pixels[0], Pixel(30, 50));
+  BOOST_CHECK_EQUAL(pixels[1], Pixel(50, 60));
+  BOOST_CHECK_EQUAL(pixels[2], Pixel(70, 50));
+  BOOST_CHECK_EQUAL(pixels[3], Pixel(50, 40));
+
+  // Check facet centroid
+  const Pixel centroid = facet.Centroid();
+  BOOST_CHECK_EQUAL(centroid, Pixel(50, 50));
+  BOOST_CHECK_EQUAL(facet.RA(), 0.0);
+  BOOST_CHECK_EQUAL(facet.Dec(), 0.0);
+}
+
+// Create a diamond in the top right corner of the image.
+BOOST_AUTO_TEST_CASE(clip_top_right) {
+  const int offset_x = 50;
+  const int offset_y = offset_x;
+  Facet facet = CreateDiamondFacet(offset_x, offset_y);
+
+  const std::vector<Pixel>& pixels = facet.GetPixels();
+  // Facet clipped to triangle
+  BOOST_REQUIRE_EQUAL(pixels.size(), 3u);
+  BOOST_CHECK_EQUAL(pixels[0], Pixel(100, 90));
+  BOOST_CHECK_EQUAL(pixels[1], Pixel(80, 100));
+  BOOST_CHECK_EQUAL(pixels[2], Pixel(100, 100));
+  Pixel centroid_ref((pixels[0].x + pixels[1].x + pixels[2].x) / 3,
+                     (pixels[0].y + pixels[1].y + pixels[2].y) / 3);
+  BOOST_CHECK_EQUAL(facet.Centroid(), centroid_ref);
+
+  // Manually convert centroid to ra,dec coords, and check
+  const double phase_centre_ra = offset_x * kScale;
+  const double phase_centre_dec = -offset_y * kScale;
+  double l;
+  double m;
+  double ra;
+  double dec;
+  aocommon::ImageCoordinates::XYToLM(facet.Centroid().x, facet.Centroid().y,
+                                     kScale, kScale, kImageSize, kImageSize, l,
+                                     m);
+
+  aocommon::ImageCoordinates::LMToRaDec(l, m, phase_centre_ra, phase_centre_dec,
+                                        ra, dec);
+  BOOST_CHECK_CLOSE(facet.RA(), ra, 1e-6);
+  BOOST_CHECK_CLOSE(facet.Dec(), dec, 1e-6);
+}
+
+// Create a diamond in the bottom left corner of the image.
+BOOST_AUTO_TEST_CASE(clip_bottom_left) {
+  const bool set_custom_direction = true;
+  Facet facet = CreateDiamondFacet(-50, -50, set_custom_direction);
+
+  const std::vector<Pixel>& pixels = facet.GetPixels();
+  // Facet clipped to triangle
+  BOOST_REQUIRE_EQUAL(pixels.size(), 3u);
+  BOOST_CHECK_EQUAL(pixels[0], Pixel(0, 10));
+  BOOST_CHECK_EQUAL(pixels[1], Pixel(20, 0));
+  BOOST_CHECK_EQUAL(pixels[2], Pixel(0, 0));
+  Pixel centroid_ref((pixels[0].x + pixels[1].x + pixels[2].x) / 3,
+                     (pixels[0].y + pixels[1].y + pixels[2].y) / 3);
+  BOOST_CHECK_EQUAL(facet.Centroid(), centroid_ref);
+  // Custom (ra, dec) direction reproduced?
+  BOOST_CHECK_EQUAL(facet.RA(), -0.02);
+  BOOST_CHECK_EQUAL(facet.Dec(), 0.01);
+}
+
+BOOST_AUTO_TEST_CASE(point_in_polygon) {
+  Facet facet = CreateDiamondFacet();
+
+  BOOST_CHECK(facet.Contains(Pixel(50, 50)));
+  // Pixel on edge that is owned by the facet
+  BOOST_CHECK(facet.Contains(Pixel(30, 50)));
+  // Pixel on edge that is not owned by the facet
+  BOOST_CHECK(!facet.Contains(Pixel(50, 60)));
+  BOOST_CHECK(!facet.Contains(Pixel(70, 50)));
+  // Pixel outside facet
+  BOOST_CHECK(!facet.Contains(Pixel(29, 50)));
+  BOOST_CHECK(!facet.Contains(Pixel(50, 61)));
+}
+
+BOOST_AUTO_TEST_CASE(facet_bounding_boxes) {
+  // Invalid padding
+  BOOST_CHECK_THROW(CreateRectangularFacet(0.99, 1, false),
+                    std::invalid_argument);
+
+  // Invalid alignment
+  BOOST_CHECK_THROW(CreateRectangularFacet(1.0, 42, false),
+                    std::invalid_argument);
+
+  // No padding, no alignment, no squaring.
+  CheckBoundingBoxes(CreateRectangularFacet(1.0, 1, false), Pixel(40, 30),
+                     Pixel(60, 70), Pixel(40, 30), Pixel(60, 70));
+
+  // Only enable padding.
+  CheckBoundingBoxes(CreateRectangularFacet(1.5, 1, false), Pixel(40, 30),
+                     Pixel(60, 70), Pixel(35, 20), Pixel(65, 80));
+
+  // Enable alignment, facet should not change
+  CheckBoundingBoxes(CreateRectangularFacet(1.0, 4, false), Pixel(40, 30),
+                     Pixel(60, 70), Pixel(40, 30), Pixel(60, 70));
+
+  // Only enable squaring.
+  CheckBoundingBoxes(CreateRectangularFacet(1.0, 1, true), Pixel(30, 30),
+                     Pixel(70, 70), Pixel(30, 30), Pixel(70, 70));
+
+  // Enable everything and use a non-power-of-two alignment.
+  CheckBoundingBoxes(CreateRectangularFacet(1.5, 25, true), Pixel(25, 25),
+                     Pixel(75, 75), Pixel(13, 13), Pixel(88, 88));
+}
+
+BOOST_AUTO_TEST_CASE(horizontal_intersections_no_pixels) {
+  const Facet facet;
+  CheckIntersections(facet, 0, {});
+  CheckIntersections(facet, 42, {});
+}
+
+BOOST_AUTO_TEST_CASE(horizontal_intersections_rectangle) {
+  Facet facet = CreateRectangularFacet(1.0, 1, false);
+
+  // Specified y is below the facet.
+  CheckIntersections(facet, 20, {});
+
+  // Specified y is at the bottom of the facet or intersects the facet.
+  for (int y = 30; y < 70; ++y) {
+    CheckIntersections(facet, y, {std::make_pair(40, 60)});
+  }
+
+  // Specified y is at the top of the facet.
+  // Since the facet ranges *until* the top, the result should be empty.
+  CheckIntersections(facet, 70, {});
+
+  // Specified y is above the facet.
+  CheckIntersections(facet, 90, {});
+}
+
+BOOST_AUTO_TEST_CASE(horizontal_intersections_diamond) {
+  // See the clip_large_box test for the pixel coordinates of the diamond.
+  Facet facet = CreateDiamondFacet();
+
+  // Specified y is below the facet.
+  CheckIntersections(facet, 20, {});
+
+  // Specified y is at the bottom of the facet.
+  // Result is empty (0, 0), since only valid intersections are half-open
+  // intervals.
+  CheckIntersections(facet, 40, {});
+
+  // Specified y intersects at 1/4 of the facet height.
+  CheckIntersections(facet, 45, {std::make_pair(40, 60)});
+
+  // Specified y intersects middle of the facet.
+  CheckIntersections(facet, 50, {std::make_pair(30, 70)});
+
+  // Specified y intersects at 3/4 of the facet height.
+  CheckIntersections(facet, 55, {std::make_pair(40, 60)});
+
+  // Specified y is at the top of the facet.
+  // Since the facet ranges *until* the top, the result should be empty.
+  CheckIntersections(facet, 60, {});
+
+  // Specified y is above the facet.
+  CheckIntersections(facet, 90, {});
+}
+
+BOOST_AUTO_TEST_CASE(horizontal_intersections_clipped_facet) {
+  // Create diamond facet in lower left corner, with pixels extending
+  // beyond image boundaries, resulting in a clipped, triangular facet
+  Facet facet = CreateDiamondFacet(-50, -50);
+
+  // Specified y is at the top of the facet.
+  // Since the facet ranges *until* the top, the result should be empty.
+  CheckIntersections(facet, 10, {});
+
+  // Specified y is at the bottom of the facet.
+  CheckIntersections(facet, 0, {std::make_pair(0, 20)});
+
+  // Specified y intersects at half the facet height
+  CheckIntersections(facet, 5, {std::make_pair(0, 10)});
+}
+
+BOOST_AUTO_TEST_CASE(horizontal_intersections_concave_facet) {
+  Facet facet = CreateConcaveFacet();
+#ifdef HAVE_BOOST_LT_166
+  // Intersections for concave facet not supported
+  BOOST_CHECK_THROW(CheckIntersections(facet, 30, {}), std::runtime_error);
+#else
+  // Specified y is at bottom of facet
+  CheckIntersections(facet, 30, {});
+
+  // Specified y cuts halfway through "convex" part
+  CheckIntersections(facet, 40, {std::make_pair(40, 60)});
+
+  // Just before "concavity" starts
+  CheckIntersections(facet, 50, {std::make_pair(30, 70)});
+
+  // Halfway "concave facets"
+  CheckIntersections(facet, 55,
+                     {std::make_pair(35, 45), std::make_pair(55, 65)});
+
+  // Just below max-y vertices
+  CheckIntersections(facet, 59,
+                     {std::make_pair(39, 41), std::make_pair(59, 61)});
+
+  // Empty at top
+  CheckIntersections(facet, 60, {});
+  BOOST_CHECK_EQUAL(facet.Centroid(), Pixel(50, 46));
+#endif
+}
+
+BOOST_AUTO_TEST_CASE(check_facet_alignment) {
+  std::pair<Facet, Facet> facets = CreateConnectedFacets();
+
+  for (int y = 0; y != 8; ++y) {
+    std::vector<std::pair<int, int>> isects1 =
+        facets.first.HorizontalIntersections(y);
+    std::vector<std::pair<int, int>> isects2 =
+        facets.second.HorizontalIntersections(y);
+
+    BOOST_CHECK_EQUAL(isects1[0].first, 0u);
+    BOOST_CHECK_EQUAL(isects2[0].second, 16u);
+    // Checks continuity between facets
+    BOOST_CHECK_EQUAL(isects1[0].second, isects2[0].first);
+  }
+}
+
+namespace {
+void CheckEncapsulates(const BoundingBox& untrimmed_box,
+                       const BoundingBox& trimmed_box) {
+  BOOST_CHECK_LE(untrimmed_box.Min().x, trimmed_box.Min().x);
+  BOOST_CHECK_GE(untrimmed_box.Max().x, trimmed_box.Max().x);
+  BOOST_CHECK_LE(untrimmed_box.Min().y, trimmed_box.Min().y);
+  BOOST_CHECK_GE(untrimmed_box.Max().y, trimmed_box.Max().y);
+}
+
+void CheckEncapsulates(const BoundingBox& trimmed_box, const Pixel& min_coord,
+                       const Pixel& max_coord, int image_size) {
+  // Checks are slightly counter-intuitive, but due to the
+  // coordinate system conventions. See documentation for CalculatePixels
+  BOOST_CHECK_LE(trimmed_box.Min().x, -min_coord.x + image_size / 2);
+  BOOST_CHECK_LE(trimmed_box.Min().y, min_coord.y + image_size / 2);
+  BOOST_CHECK_GE(trimmed_box.Max().x, -max_coord.x + image_size / 2);
+  BOOST_CHECK_GE(trimmed_box.Max().y, max_coord.y + image_size / 2);
+}
+}  // namespace
+
+BOOST_AUTO_TEST_CASE(square_bounding_box) {
+  /**
+   * These and the next 4 auto test cases check the make_square=true option. In
+   * particular they make sure that if a bounding box requires extra padding to
+   * make it square-shaped whether a) the bounding boxes still really
+   * encapsulate all coordinates; b) the bounding boxes are still properly
+   * aligned; and c) the bounding boxes are square shaped.
+   */
+  const Pixel min_coord(0, 2);
+  const Pixel mid_coord(5, 5);
+  const Pixel max_coord(10, 8);
+  const std::vector<Coord> coords{{min_coord.x * kScale, min_coord.y * kScale},
+                                  {mid_coord.x * kScale, mid_coord.y * kScale},
+                                  {max_coord.x * kScale, max_coord.y * kScale}};
+  Facet facet;
+  for (const Coord& c : coords) {
+    facet.AddVertex(c.ra, c.dec);
+  }
+
+  const double l = 0.0;
+  const double m = 0.0;
+  const double ra = 0.0;
+  const double dec = 0.0;
+  const bool make_square = true;
+  const double padding = 1.4;
+  const size_t align = 4;
+  const int image_size = 100;
+  facet.CalculatePixels(ra, dec, kScale, kScale, image_size, image_size, l, m,
+                        padding, align, make_square);
+
+  const BoundingBox& trimmed_box = facet.GetTrimmedBoundingBox();
+  BOOST_CHECK_EQUAL(trimmed_box.Width(), trimmed_box.Height());
+  CheckEncapsulates(trimmed_box, min_coord, max_coord, image_size);
+
+  const BoundingBox& untrimmed_box = facet.GetUntrimmedBoundingBox();
+  CheckEncapsulates(untrimmed_box, trimmed_box);
+  BOOST_CHECK_EQUAL(untrimmed_box.Width(), untrimmed_box.Height());
+  BOOST_CHECK_EQUAL(untrimmed_box.Width() % 4, 0);
+}
+
+BOOST_AUTO_TEST_CASE(square_bounding_box_near_right_edge) {
+  const Pixel min_coord(-49, -49);
+  const Pixel max_coord(-48, 2);
+  const std::vector<Coord> coords{{min_coord.x * kScale, min_coord.y * kScale},
+                                  {min_coord.x * kScale, max_coord.y * kScale},
+                                  {max_coord.x * kScale, max_coord.y * kScale}};
+  Facet facet;
+  for (const Coord& c : coords) {
+    facet.AddVertex(c.ra, c.dec);
+  }
+
+  const bool make_square = true;
+  const double padding = 1.4;
+  const size_t align = 4;
+  const int image_size = 100;
+  facet.CalculatePixels(0.0, 0.0, kScale, kScale, image_size, image_size, 0.0,
+                        0.0, padding, align, make_square);
+
+  const BoundingBox& trimmed_box = facet.GetTrimmedBoundingBox();
+  BOOST_CHECK_EQUAL(trimmed_box.Width(), trimmed_box.Height());
+  CheckEncapsulates(trimmed_box, min_coord, max_coord, image_size);
+
+  const BoundingBox& untrimmed_box = facet.GetUntrimmedBoundingBox();
+  CheckEncapsulates(untrimmed_box, trimmed_box);
+  BOOST_CHECK_EQUAL(untrimmed_box.Width(), untrimmed_box.Height());
+  BOOST_CHECK_EQUAL(untrimmed_box.Width() % 4, 0);
+}
+
+BOOST_AUTO_TEST_CASE(square_bounding_box_near_bottom_edge) {
+  const Pixel min_coord(2, -49);
+  const Pixel max_coord(49, -48);
+  const std::vector<Coord> coords{{min_coord.x * kScale, min_coord.y * kScale},
+                                  {max_coord.x * kScale, min_coord.y * kScale},
+                                  {max_coord.x * kScale, max_coord.y * kScale}};
+  Facet facet;
+  for (const Coord& c : coords) {
+    facet.AddVertex(c.ra, c.dec);
+  }
+
+  const bool make_square = true;
+  const double padding = 1.4;
+  const size_t align = 4;
+  const int image_size = 100;
+  facet.CalculatePixels(0.0, 0.0, kScale, kScale, image_size, image_size, 0.0,
+                        0.0, padding, align, make_square);
+
+  const BoundingBox& trimmed_box = facet.GetTrimmedBoundingBox();
+  BOOST_CHECK_EQUAL(trimmed_box.Width(), trimmed_box.Height());
+  CheckEncapsulates(trimmed_box, min_coord, max_coord, image_size);
+
+  const BoundingBox& untrimmed_box = facet.GetUntrimmedBoundingBox();
+  CheckEncapsulates(untrimmed_box, trimmed_box);
+  BOOST_CHECK_EQUAL(untrimmed_box.Width(), untrimmed_box.Height());
+  BOOST_CHECK_EQUAL(untrimmed_box.Width() % 4, 0);
+}
+
+BOOST_AUTO_TEST_CASE(square_bounding_box_near_left_edge) {
+  const Pixel min_coord(48, 2);
+  const Pixel max_coord(50, 49);
+  const std::vector<Coord> coords{{min_coord.x * kScale, min_coord.y * kScale},
+                                  {max_coord.x * kScale, min_coord.y * kScale},
+                                  {max_coord.x * kScale, max_coord.y * kScale}};
+  Facet facet;
+  for (const Coord& c : coords) {
+    facet.AddVertex(c.ra, c.dec);
+  }
+
+  const bool make_square = true;
+  const double padding = 1.4;
+  const size_t align = 4;
+  const int image_size = 100;
+  facet.CalculatePixels(0.0, 0.0, kScale, kScale, image_size, image_size, 0.0,
+                        0.0, padding, align, make_square);
+
+  const BoundingBox& trimmed_box = facet.GetTrimmedBoundingBox();
+  BOOST_CHECK_EQUAL(trimmed_box.Width(), trimmed_box.Height());
+  CheckEncapsulates(trimmed_box, min_coord, max_coord, image_size);
+
+  const BoundingBox& untrimmed_box = facet.GetUntrimmedBoundingBox();
+  CheckEncapsulates(untrimmed_box, trimmed_box);
+  BOOST_CHECK_EQUAL(untrimmed_box.Width(), untrimmed_box.Height());
+  BOOST_CHECK_EQUAL(untrimmed_box.Width() % 4, 0);
+}
+
+BOOST_AUTO_TEST_CASE(square_bounding_box_near_top_edge) {
+  const Pixel min_coord(2, 48);
+  const Pixel max_coord(49, 50);
+  const std::vector<Coord> coords{{min_coord.x * kScale, min_coord.y * kScale},
+                                  {min_coord.x * kScale, max_coord.y * kScale},
+                                  {max_coord.x * kScale, max_coord.y * kScale}};
+  Facet facet;
+  for (const Coord& c : coords) {
+    facet.AddVertex(c.ra, c.dec);
+  }
+
+  const bool make_square = true;
+  const double padding = 1.4;
+  const size_t align = 4;
+  const int image_size = 100;
+  facet.CalculatePixels(0.0, 0.0, kScale, kScale, image_size, image_size, 0.0,
+                        0.0, padding, align, make_square);
+
+  const BoundingBox& trimmed_box = facet.GetTrimmedBoundingBox();
+  BOOST_CHECK_EQUAL(trimmed_box.Width(), trimmed_box.Height());
+  CheckEncapsulates(trimmed_box, min_coord, max_coord, image_size);
+
+  const BoundingBox& untrimmed_box = facet.GetUntrimmedBoundingBox();
+  CheckEncapsulates(untrimmed_box, trimmed_box);
+  BOOST_CHECK_EQUAL(untrimmed_box.Width(), untrimmed_box.Height());
+  BOOST_CHECK_EQUAL(untrimmed_box.Width() % 4, 0);
+}
+
+BOOST_AUTO_TEST_CASE(serialization) {
+  // Since a facet contains Coord, Boundingbox and Pixel objects, this test
+  // covers serialization of those objects, too.
+
+  const double kRa = 42.0;
+  const double kDec = 43.0;
+  const std::string kDirection = "FirstLeftThenRight";
+
+  // Create a facet with different bounding boxes. See facet_bounding_boxes
+  // test.
+  Facet input = CreateRectangularFacet(1.5, 25, true);
+  BOOST_CHECK_EQUAL(input.RA(), 0.0);
+  BOOST_CHECK_EQUAL(input.Dec(), 0.0);
+  input.SetRA(kRa);
+  input.SetDec(kDec);
+  input.SetDirectionLabel(kDirection);
+  aocommon::SerialOStream ostr;
+  input.Serialize(ostr);
+
+  aocommon::SerialIStream istr(std::move(ostr));
+  Facet output;
+  output.Unserialize(istr);
+
+  BOOST_REQUIRE_EQUAL(output.GetCoords().size(), 4u);
+  BOOST_REQUIRE_EQUAL(output.GetPixels().size(), 4u);
+  for (size_t i = 0; i < input.GetCoords().size(); ++i) {
+    BOOST_CHECK_EQUAL(input.GetCoords()[i].ra, output.GetCoords()[i].ra);
+    BOOST_CHECK_EQUAL(input.GetCoords()[i].dec, output.GetCoords()[i].dec);
+    BOOST_CHECK_EQUAL(input.GetPixels()[i], output.GetPixels()[i]);
+  }
+  BOOST_CHECK_EQUAL(output.RA(), kRa);
+  BOOST_CHECK_EQUAL(output.Dec(), kDec);
+  BOOST_CHECK_EQUAL(input.Centroid(), output.Centroid());
+  BOOST_CHECK_EQUAL(output.DirectionLabel(), kDirection);
+  BOOST_CHECK_EQUAL(input.GetTrimmedBoundingBox().Min(),
+                    output.GetTrimmedBoundingBox().Min());
+  BOOST_CHECK_EQUAL(input.GetTrimmedBoundingBox().Max(),
+                    output.GetTrimmedBoundingBox().Max());
+  BOOST_CHECK_EQUAL(input.GetUntrimmedBoundingBox().Min(),
+                    output.GetUntrimmedBoundingBox().Min());
+  BOOST_CHECK_EQUAL(input.GetUntrimmedBoundingBox().Max(),
+                    output.GetUntrimmedBoundingBox().Max());
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: wsclean/external/schaapcommon/src/facets/test/tfacet.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/test/tfacet.h
@@ -0,0 +1,27 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#ifndef TFACET_H_
+#define TFACET_H_
+
+// This headers contains common code for facet tests.
+// tfacet.cc contains both the implementation(s) for this header
+// and the facet tests.
+
+#include "facet.h"
+
+#include <ostream>
+
+namespace schaapcommon {
+namespace facets {
+
+// This operator allows using BOOST_CHECK_EQUAL on Pixel objects.
+inline std::ostream& operator<<(std::ostream& stream, const Pixel& pixel) {
+  stream << "Pixel(" << pixel.x << ", " << pixel.y << ")";
+  return stream;
+}
+
+}  // namespace facets
+}  // namespace schaapcommon
+
+#endif  // TFACET_H_
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/facets/test/tfacetimage.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/facets/test/tfacetimage.cc
@@ -0,0 +1,379 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include <boost/test/unit_test.hpp>
+
+#include "facetimage.h"
+#include "tfacet.h"
+
+#include <aocommon/uvector.h>
+
+#include <iostream>
+
+using schaapcommon::facets::BoundingBox;
+using schaapcommon::facets::Facet;
+using schaapcommon::facets::FacetImage;
+using schaapcommon::facets::Pixel;
+
+namespace utf = boost::unit_test;
+
+BOOST_AUTO_TEST_SUITE(facetimage)
+
+namespace {
+
+const double kScale = 0.001;
+const size_t kImageSize = 100;
+const size_t kNTerms = 2;
+const double kPadding = 1.25;
+const size_t kAlign = 4;
+
+/// Creates a facet with pixels (0, 0), (size, 0), (size, size), (0, size).
+Facet CreateSquareFacet(size_t size) {
+  Facet facet;
+
+  const double radecZero = kScale * kImageSize / 2;
+  const double radecSize = radecZero - size * kScale;
+  facet.AddVertex(radecZero, -radecZero);
+  facet.AddVertex(radecSize, -radecZero);
+  facet.AddVertex(radecSize, -radecSize);
+  facet.AddVertex(radecZero, -radecSize);
+
+  const double ra = 0.0, dec = 0.0, l = 0.0, m = 0.0;
+  facet.CalculatePixels(ra, dec, kScale, kScale, kImageSize, kImageSize, l, m,
+                        kPadding, kAlign, true);
+  const std::vector<Pixel>& pixels = facet.GetPixels();
+  BOOST_REQUIRE_EQUAL(pixels.size(), 4u);
+  BOOST_CHECK_EQUAL(pixels[0], Pixel(0, 0));
+  BOOST_CHECK_EQUAL(pixels[1], Pixel(size, 0));
+  BOOST_CHECK_EQUAL(pixels[2], Pixel(size, size));
+  BOOST_CHECK_EQUAL(pixels[3], Pixel(0, size));
+
+  return facet;
+}
+
+/**
+ * Fill the data for a facet with a value.
+ * Use a different value in the padding area.
+ */
+void FillFacetData(float* data, const Facet& facet, float value) {
+  const float pad_value = -42.0f;
+
+  const BoundingBox unpadded_box(facet.GetPixels());
+  const BoundingBox& padded_box = facet.GetUntrimmedBoundingBox();
+
+  // Check that the padded box is larger on all sides.
+  BOOST_REQUIRE_LT(padded_box.Min().x, unpadded_box.Min().x);
+  BOOST_REQUIRE_LT(padded_box.Min().y, unpadded_box.Min().y);
+  BOOST_REQUIRE_GT(padded_box.Max().x, unpadded_box.Max().x);
+  BOOST_REQUIRE_GT(padded_box.Max().y, unpadded_box.Max().y);
+
+  const int pad_top = unpadded_box.Min().y - padded_box.Min().y;
+  for (int y = 0; y < pad_top; ++y) {
+    std::fill_n(data, padded_box.Width(), pad_value);
+    data += padded_box.Width();
+  }
+
+  const int pad_left = unpadded_box.Min().x - padded_box.Min().x;
+  const int pad_right = padded_box.Max().x - unpadded_box.Max().x;
+  for (int y = unpadded_box.Min().y; y < unpadded_box.Max().y; ++y) {
+    std::fill_n(data, pad_left, pad_value);
+    data += pad_left;
+    std::fill_n(data, unpadded_box.Width(), value);
+    data += unpadded_box.Width();
+    std::fill_n(data, pad_right, pad_value);
+    data += pad_right;
+  }
+
+  const int pad_bottom = padded_box.Max().y - unpadded_box.Max().y;
+  for (int y = 0; y < pad_bottom; ++y) {
+    std::fill_n(data, padded_box.Width(), pad_value);
+    data += padded_box.Width();
+  }
+}
+
+}  // namespace
+
+BOOST_AUTO_TEST_CASE(constructor) {
+  FacetImage fi(kImageSize, kImageSize, kNTerms);
+  BOOST_CHECK_EQUAL(fi.Width(), 0);
+  BOOST_CHECK_EQUAL(fi.Height(), 0);
+  BOOST_CHECK_EQUAL(fi.OffsetX(), 0);
+  BOOST_CHECK_EQUAL(fi.OffsetY(), 0);
+
+  // When SetFacet was not called, CopyToFacet should throw.
+  std::vector<aocommon::UVector<float>> input_images;
+  for (std::size_t i = 0; i < kNTerms; ++i) {
+    input_images.emplace_back(kImageSize * kImageSize);
+  }
+  BOOST_CHECK_THROW(fi.CopyToFacet(input_images), std::runtime_error);
+
+  // When SetFacet was not called, AddToImage should throw.
+  std::vector<float*> output_images(kNTerms);
+  BOOST_CHECK_THROW(fi.AddToImage(output_images), std::runtime_error);
+
+  BOOST_CHECK_THROW(FacetImage(0, kImageSize, kNTerms), std::invalid_argument);
+  BOOST_CHECK_THROW(FacetImage(kImageSize, 0, kNTerms), std::invalid_argument);
+  BOOST_CHECK_THROW(FacetImage(kImageSize, kImageSize, 0),
+                    std::invalid_argument);
+}
+
+BOOST_AUTO_TEST_CASE(set_facet) {
+  const Facet facet = CreateSquareFacet(40);
+  BOOST_CHECK_EQUAL(facet.GetTrimmedBoundingBox().Min(), Pixel(0, 0));
+  BOOST_CHECK_EQUAL(facet.GetTrimmedBoundingBox().Max(), Pixel(40, 40));
+
+  // Padding increases the facet to -5...45.
+  // Alignment rounds -5 down to -6 and 45 up to 46, yielding (46 -- 6) % 4 = 0
+  BOOST_CHECK_EQUAL(facet.GetUntrimmedBoundingBox().Min(), Pixel(-6, -6));
+  BOOST_CHECK_EQUAL(facet.GetUntrimmedBoundingBox().Max(), Pixel(46, 46));
+
+  FacetImage fi(kImageSize, kImageSize, kNTerms);
+  // Trimmed box
+  fi.SetFacet(facet, true);
+  BOOST_CHECK_EQUAL(fi.Width(), 40);
+  BOOST_CHECK_EQUAL(fi.Height(), 40);
+  BOOST_CHECK_EQUAL(fi.OffsetX(), 0);
+  BOOST_CHECK_EQUAL(fi.OffsetY(), 0);
+
+  // Untrimmed, padded box
+  fi.SetFacet(facet, false);
+  BOOST_CHECK_EQUAL(fi.Width(), 52);
+  BOOST_CHECK_EQUAL(fi.Height(), 52);
+  BOOST_CHECK_EQUAL(fi.OffsetX(), -6);
+  BOOST_CHECK_EQUAL(fi.OffsetY(), -6);
+}
+
+BOOST_AUTO_TEST_CASE(copy_to_facet) {
+  const size_t kFacetSize = 30;
+
+  const Facet facet = CreateSquareFacet(kFacetSize);
+
+  std::vector<aocommon::UVector<float>> input_images;
+  for (size_t term = 0; term < kNTerms; ++term) {
+    aocommon::UVector<float> image(kImageSize * kImageSize);
+    for (size_t y = 0; y < kImageSize; ++y) {
+      for (size_t x = 0; x < kImageSize; ++x) {
+        image[y * kImageSize + x] = x + y + term + 0.5;
+      }
+    }
+    input_images.push_back(std::move(image));
+  }
+
+  FacetImage facet_image(kImageSize, kImageSize, kNTerms);
+  facet_image.SetFacet(facet, false);
+  facet_image.CopyToFacet(input_images);
+
+  for (size_t term = 0; term < kNTerms; ++term) {
+    const float* data = facet_image.Data(term);
+    for (int y = facet.GetUntrimmedBoundingBox().Min().y;
+         y < facet.GetUntrimmedBoundingBox().Max().y; ++y) {
+      for (int x = facet.GetUntrimmedBoundingBox().Min().x;
+           x < facet.GetUntrimmedBoundingBox().Max().x; ++x) {
+        // Values in the padding and alignment areas should be zero.
+        float ref_value = 0.0;
+        if (x >= 0 && x < static_cast<int>(kFacetSize) && y >= 0 &&
+            y < static_cast<int>(kFacetSize)) {
+          ref_value = x + y + term + 0.5;
+        }
+        BOOST_CHECK_CLOSE(*data, ref_value, 1e-8);
+        ++data;
+      }
+    }
+  }
+}
+
+BOOST_AUTO_TEST_CASE(multiply) {
+  const size_t kFacetSize = 30;
+
+  const Facet facet = CreateSquareFacet(kFacetSize);
+
+  std::vector<aocommon::UVector<float>> input_images(kNTerms);
+  for (size_t term = 0; term < kNTerms; ++term) {
+    input_images[term].assign(kImageSize * kImageSize, term + 1.0f);
+  }
+
+  FacetImage facet_image(kImageSize, kImageSize, kNTerms);
+  facet_image.SetFacet(facet, false);
+  facet_image.CopyToFacet(input_images);
+
+  BOOST_CHECK_NO_THROW(facet_image *= 2.0);
+
+  for (size_t term = 0; term < kNTerms; ++term) {
+    const float* data = facet_image.Data(term);
+    for (int y = facet.GetUntrimmedBoundingBox().Min().y;
+         y < facet.GetUntrimmedBoundingBox().Max().y; ++y) {
+      for (int x = facet.GetUntrimmedBoundingBox().Min().x;
+           x < facet.GetUntrimmedBoundingBox().Max().x; ++x) {
+        // Values in the padding and alignment areas should be zero.
+        float ref_value = 0.0;
+        if (x >= 0 && x < static_cast<int>(kFacetSize) && y >= 0 &&
+            y < static_cast<int>(kFacetSize)) {
+          ref_value = 2.0f * (term + 1.0f);
+        }
+        BOOST_CHECK_CLOSE(*data, ref_value, 1e-8);
+        ++data;
+      }
+    }
+  }
+}
+
+BOOST_AUTO_TEST_CASE(add_facet_to_image) {
+  // Properties of the main image:
+  const size_t image_width = kImageSize * 2;
+  const size_t image_height = kImageSize;
+  const double dl = 0.002;
+  const double dm = dl;
+  const double phase_centre_ra = 0.0;
+  const double phase_centre_dec = 0.0;
+  const double shift_l = 0.0;
+  const double shift_m = 0.0;
+
+  // Make a facet in the lower left corner and upper right corner
+  // (please note coord system conventions!)
+  Facet facet1;
+  Facet facet2;
+
+  std::vector<std::pair<double, double>> coords{
+      {0.1, -0.05}, {0.05, -0.05}, {0.05, -0.03}, {0.1, -0.03}};
+
+  for (const auto& coord : coords) {
+    facet1.AddVertex(coord.first, coord.second);
+    // Mirror in origin
+    facet2.AddVertex(-1 * coord.first, -1 * coord.second);
+  }
+
+  // Calculate pixel position of facet vertices in main image
+  facet1.CalculatePixels(phase_centre_ra, phase_centre_dec, dl, dm, image_width,
+                         image_height, shift_l, shift_m, kPadding, kAlign,
+                         false);
+  facet2.CalculatePixels(phase_centre_ra, phase_centre_dec, dl, dm, image_width,
+                         image_height, shift_l, shift_m, kPadding, kAlign,
+                         true);
+
+  std::vector<std::vector<float>> output_images;
+  std::vector<float*> output_ptrs;
+  for (size_t term = 0; term < kNTerms; ++term) {
+    output_images.emplace_back(image_width * image_height, 0.0f);
+    output_ptrs.push_back(output_images.back().data());
+  }
+
+  FacetImage facet_image(image_width, image_height, kNTerms);
+
+  facet_image.SetFacet(facet1, false);
+  // Initialize facet1 with odd numbers.
+  for (size_t term = 0; term < kNTerms; ++term) {
+    FillFacetData(facet_image.Data(term), facet1, 1 + term * 2);
+  }
+  facet_image.AddToImage(output_ptrs);
+
+  facet_image.SetFacet(facet2, false);
+  // Initialize facet2 with even numbers.
+  for (size_t term = 0; term < kNTerms; ++term) {
+    FillFacetData(facet_image.Data(term), facet2, 2 + term * 2);
+  }
+  facet_image.AddToImage(output_ptrs);
+
+  // Create unpadded bounding boxes for the facets: AddToImage should not use
+  // data in the padding area.
+  const BoundingBox box1(facet1.GetPixels());
+  const BoundingBox box2(facet2.GetPixels());
+
+  for (size_t term = 0; term < kNTerms; ++term) {
+    for (int y = 0; y < static_cast<int>(image_height); ++y) {
+      for (int x = 0; x < static_cast<int>(image_width); ++x) {
+        const float result_pixel = output_images[term][y * image_width + x];
+        if (y >= box1.Min().y && y < box1.Max().y && x >= box1.Min().x &&
+            x < box1.Max().x) {
+          // Check if "facet1" value was assigned.
+          BOOST_CHECK_CLOSE(result_pixel, 1 + term * 2, 1e-8);
+        } else if (y >= box2.Min().y && y < box2.Max().y && x >= box2.Min().x &&
+                   x < box2.Max().x) {
+          // Check if "facet2" value was assigned.
+          BOOST_CHECK_CLOSE(result_pixel, 2 + term * 2, 1e-8);
+        } else {
+          // Check if the value is still zero.
+          BOOST_CHECK_CLOSE(result_pixel, 0.0f, 1e-8);
+        }
+      }
+    }
+  }
+}
+
+BOOST_AUTO_TEST_CASE(multiply_image_inside_facet) {
+  // Properties of the main image:
+  const size_t image_width = kImageSize * 2;
+  const size_t image_height = kImageSize;
+  const double dl = 0.002;
+  const double dm = dl;
+  const double phase_centre_ra = 0.0;
+  const double phase_centre_dec = 0.0;
+  const double shift_l = 0.0;
+  const double shift_m = 0.0;
+
+  // Make a facet in the lower left corner and upper right corner
+  // (please note coord system conventions!)
+  Facet facet1;
+  Facet facet2;
+
+  std::vector<std::pair<double, double>> coords{
+      {0.1, -0.05}, {0.05, -0.05}, {0.05, -0.03}, {0.1, -0.03}};
+
+  for (const auto& coord : coords) {
+    facet1.AddVertex(coord.first, coord.second);
+    // Mirror in origin
+    facet2.AddVertex(-1 * coord.first, -1 * coord.second);
+  }
+
+  // Calculate pixel position of facet vertices in main image
+  facet1.CalculatePixels(phase_centre_ra, phase_centre_dec, dl, dm, image_width,
+                         image_height, shift_l, shift_m, kPadding, kAlign,
+                         false);
+  facet2.CalculatePixels(phase_centre_ra, phase_centre_dec, dl, dm, image_width,
+                         image_height, shift_l, shift_m, kPadding, kAlign,
+                         true);
+
+  std::vector<std::vector<float>> output_images;
+  std::vector<float*> output_ptrs;
+  for (size_t term = 0; term < kNTerms; ++term) {
+    output_images.emplace_back(image_width * image_height, 1.0f);
+    output_ptrs.push_back(output_images.back().data());
+  }
+
+  FacetImage facet_image(image_width, image_height, kNTerms);
+
+  BOOST_CHECK_THROW(facet_image.MultiplyImageInsideFacet(output_ptrs, 1.0f),
+                    std::runtime_error);
+
+  facet_image.SetFacet(facet1, false);
+  BOOST_CHECK_NO_THROW(facet_image.MultiplyImageInsideFacet(output_ptrs, 2.0f));
+
+  facet_image.SetFacet(facet2, false);
+  BOOST_CHECK_NO_THROW(facet_image.MultiplyImageInsideFacet(output_ptrs, 4.0f));
+
+  // Create unpadded bounding boxes for the facets: AddToImage should not use
+  // data in the padding area.
+  const BoundingBox box1(facet1.GetPixels());
+  const BoundingBox box2(facet2.GetPixels());
+
+  for (size_t term = 0; term < kNTerms; ++term) {
+    for (int y = 0; y < static_cast<int>(image_height); ++y) {
+      for (int x = 0; x < static_cast<int>(image_width); ++x) {
+        const float result_pixel = output_images[term][y * image_width + x];
+        if (y >= box1.Min().y && y < box1.Max().y && x >= box1.Min().x &&
+            x < box1.Max().x) {
+          // Check if "facet1" value was assigned.
+          BOOST_CHECK_CLOSE(result_pixel, 2.0f, 1e-8);
+        } else if (y >= box2.Min().y && y < box2.Max().y && x >= box2.Min().x &&
+                   x < box2.Max().x) {
+          // Check if "facet2" value was assigned.
+          BOOST_CHECK_CLOSE(result_pixel, 4.0f, 1e-8);
+        } else {
+          // Check if the value is still one.
+          BOOST_CHECK_CLOSE(result_pixel, 1.0f, 1e-8);
+        }
+      }
+    }
+  }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: wsclean/external/schaapcommon/src/fft/CMakeLists.txt
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/CMakeLists.txt
@@ -0,0 +1,31 @@
+# Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+get_filename_component(MODULE ${CMAKE_CURRENT_SOURCE_DIR} NAME)
+
+set(PUBLIC_HEADER_DIR ${SCHAAPCOMMON_SOURCE_DIR}/include/schaapcommon/${MODULE})
+
+set(PUBLIC_HEADERS
+    ${PUBLIC_HEADER_DIR}/convolution.h ${PUBLIC_HEADER_DIR}/resampler.h
+    ${PUBLIC_HEADER_DIR}/restoreimage.h)
+
+target_sources(
+  ${SCHAAPCOMMON_PROJECT_NAME}
+  PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/convolution.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/compositefft.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/resampler.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/restoreimage.cc)
+
+# Simplifies including the public headers.
+target_include_directories(${SCHAAPCOMMON_PROJECT_NAME}
+                           PRIVATE "$<BUILD_INTERFACE:${PUBLIC_HEADER_DIR}>")
+
+# Install headers and add test directory when built as stand-alone.
+if(SCHAAPCOMMON_MASTER_PROJECT)
+  install(FILES ${PUBLIC_HEADERS}
+          DESTINATION "include/${CMAKE_PROJECT_NAME}/${MODULE}")
+
+  if(BUILD_TESTING)
+    add_subdirectory(test)
+  endif()
+endif()
Index: wsclean/external/schaapcommon/src/fft/compositefft.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/compositefft.cc
@@ -0,0 +1,166 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "compositefft.h"
+
+#include <algorithm>
+#include <cstring>
+
+namespace {
+
+// Partially unroll rows/columns with a factor of kUnroll
+constexpr size_t kUnroll = 4;
+
+// With kUnroll > 1, the temporary buffers need to be aligned
+// for FFTW to work correctly.
+constexpr size_t kAlignment = 64;
+
+size_t RoundUp(size_t a, size_t b) { return ((a + b) / b) * b; }
+
+}  // namespace
+
+namespace schaapcommon {
+namespace fft {
+void FftR2CComposite(fftwf_plan plan_r2c, fftwf_plan plan_c2c,
+                     size_t image_height, size_t image_width, const float* in,
+                     fftwf_complex* out, aocommon::StaticFor<size_t>& loop) {
+  const size_t complex_width = image_width / 2 + 1;
+  const size_t complex_size = image_height * complex_width;
+
+  fftwf_complex* temp1 = fftwf_alloc_complex(complex_size);
+
+  loop.Run(0, image_height, [&](size_t y_start, size_t y_end) {
+    fftwf_complex* temp2 = fftwf_alloc_complex(complex_width);
+    float* temp2_ptr = reinterpret_cast<float*>(temp2);
+    for (size_t y = y_start; y < y_end; y++) {
+      float* temp1_ptr = reinterpret_cast<float*>(&temp1[y * complex_width]);
+      std::copy_n(&in[y * image_width], image_width, temp2_ptr);
+      fftwf_execute_dft_r2c(plan_r2c, temp2_ptr, temp2);
+      std::copy_n(temp2_ptr, 2 * complex_width, temp1_ptr);
+    }
+    fftwf_free(temp2);
+  });
+
+  loop.Run(0, complex_width, [&](size_t x_start, size_t x_end) {
+    // Partially kUnroll over columns
+    size_t padded_height = RoundUp(image_height, kAlignment);
+    fftwf_complex* temp2 = fftwf_alloc_complex(kUnroll * padded_height);
+
+    for (size_t x = x_start; x < x_end; x += kUnroll) {
+      // Copy input
+      for (size_t y = 0; y < image_height; y++) {
+        for (size_t i = 0; i < kUnroll; i++) {
+          if ((x + i) < x_end) {
+            float* temp1_ptr =
+                reinterpret_cast<float*>(&temp1[y * complex_width + x + i]);
+            float* temp2_ptr =
+                reinterpret_cast<float*>(&temp2[i * padded_height + y]);
+            std::copy_n(temp1_ptr, 2, temp2_ptr);
+          }
+        }
+      }
+
+      // Perform 1D FFT over columns
+      for (size_t i = 0; i < kUnroll; i++) {
+        fftwf_complex* temp2_ptr = &temp2[i * padded_height];
+        fftwf_execute_dft(plan_c2c, temp2_ptr, temp2_ptr);
+      }
+
+      // Transpose output
+      for (size_t y = 0; y < image_height; y++) {
+        for (size_t i = 0; i < kUnroll; i++) {
+          if ((x + i) < x_end) {
+            float* temp2_ptr =
+                reinterpret_cast<float*>(&temp2[i * padded_height + y]);
+            float* out_ptr =
+                reinterpret_cast<float*>(&out[y * complex_width + x + i]);
+            std::copy_n(temp2_ptr, 2, out_ptr);
+          }
+        }
+      }
+    }
+
+    fftwf_free(temp2);
+  });
+
+  fftwf_free(temp1);
+}
+
+void FftC2RComposite(fftwf_plan plan_c2c, fftwf_plan plan_c2r,
+                     size_t image_height, size_t image_width,
+                     const fftwf_complex* in, float* out,
+                     aocommon::StaticFor<size_t>& loop) {
+  const size_t complex_width = image_width / 2 + 1;
+
+  size_t padded_height = RoundUp(image_height, kAlignment);
+  size_t padded_size = padded_height * complex_width;
+  fftwf_complex* temp1 = fftwf_alloc_complex(padded_size);
+
+  loop.Run(0, complex_width, [&](size_t x_start, size_t x_end) {
+    for (size_t x = x_start; x < x_end; x += kUnroll) {
+      // Transpose input
+      for (size_t y = 0; y < image_height; y++) {
+        for (size_t i = 0; i < kUnroll; i++) {
+          if ((x + i) < x_end) {
+            const float* in_ptr =
+                reinterpret_cast<const float*>(&in[y * complex_width + x + i]);
+            float* temp1_ptr =
+                reinterpret_cast<float*>(&temp1[(x + i) * padded_height + y]);
+            std::copy_n(in_ptr, 2, temp1_ptr);
+          }
+        }
+      }
+
+      // Perform 1D C2C FFT over columns
+      for (size_t i = 0; i < kUnroll; i++) {
+        if ((x + i) < x_end) {
+          fftwf_complex* temp1_ptr = &temp1[(x + i) * padded_height];
+          fftwf_execute_dft(plan_c2c, temp1_ptr, temp1_ptr);
+        }
+      }
+    }
+  });
+
+  loop.Run(0, image_height, [&](size_t y_start, size_t y_end) {
+    size_t paddedWidth = RoundUp(complex_width, kAlignment);
+    fftwf_complex* temp2 = fftwf_alloc_complex(kUnroll * paddedWidth);
+
+    for (size_t y = y_start; y < y_end; y += kUnroll) {
+      // Transpose input
+      for (size_t x = 0; x < complex_width; x++) {
+        for (size_t i = 0; i < kUnroll; i++) {
+          if ((y + i) < y_end) {
+            float* temp1_ptr =
+                reinterpret_cast<float*>(&temp1[x * padded_height + y + i]);
+            float* temp2_ptr =
+                reinterpret_cast<float*>(&temp2[i * paddedWidth + x]);
+            std::copy_n(temp1_ptr, 2, temp2_ptr);
+          }
+        }
+      }
+
+      // Perform 1D C2R FFT over rows
+      for (size_t i = 0; i < kUnroll; i++) {
+        if ((y + i) < y_end) {
+          fftwf_complex* temp2_ptr = &temp2[i * paddedWidth];
+          fftwf_execute_dft_c2r(plan_c2r, temp2_ptr,
+                                reinterpret_cast<float*>(temp2_ptr));
+        }
+      }
+
+      // Copy output
+      for (size_t i = 0; i < kUnroll; i++) {
+        if ((y + i) < y_end) {
+          float* temp2_ptr = reinterpret_cast<float*>(&temp2[i * paddedWidth]);
+          std::copy_n(temp2_ptr, image_width, &out[(y + i) * image_width]);
+        }
+      }
+    }
+
+    fftwf_free(temp2);
+  });
+
+  fftwf_free(temp1);
+}
+}  // namespace fft
+}  // namespace schaapcommon
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fft/convolution.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/convolution.cc
@@ -0,0 +1,174 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "convolution.h"
+
+#include <complex>
+#include <stdexcept>
+
+#include <aocommon/uvector.h>
+#include <aocommon/staticfor.h>
+
+#include <fftw3.h>
+
+#include "compositefft.h"
+
+#include <iostream>
+
+namespace schaapcommon {
+namespace fft {
+
+void MakeFftwfPlannerThreadSafe() { fftwf_make_planner_thread_safe(); }
+
+void ResizeAndConvolve(float* image, size_t image_width, size_t image_height,
+                       const float* kernel, size_t kernel_size,
+                       size_t thread_count) {
+  aocommon::UVector<float> scaled_kernel(image_width * image_height, 0.0);
+  PrepareSmallConvolutionKernel(scaled_kernel.data(), image_width, image_height,
+                                kernel, kernel_size, thread_count);
+  Convolve(image, scaled_kernel.data(), image_width, image_height,
+           thread_count);
+}
+
+void PrepareSmallConvolutionKernel(float* dest, size_t image_width,
+                                   size_t image_height, const float* kernel,
+                                   size_t kernel_size, size_t thread_count) {
+  if (kernel_size > image_width || kernel_size > image_height) {
+    throw std::runtime_error("Kernel size > image dimension");
+  }
+  aocommon::StaticFor<size_t> loop(thread_count);
+  loop.Run(0, kernel_size / 2, [&](size_t y_start, size_t y_end) {
+    const float* kernel_iter = &kernel[y_start * kernel_size];
+    for (size_t y = y_start; y != y_end; ++y) {
+      const size_t y_dest = image_height - kernel_size / 2 + y;
+      const size_t x_first = image_width - kernel_size / 2;
+      float* dest_iter = &dest[y_dest * image_width + x_first];
+      for (size_t x = 0; x != kernel_size / 2; ++x) {
+        *dest_iter = *kernel_iter;
+        ++kernel_iter;
+        ++dest_iter;
+      }
+      dest_iter = &dest[y_dest * image_width];
+      for (size_t x = kernel_size / 2; x != kernel_size; ++x) {
+        *dest_iter = *kernel_iter;
+        ++kernel_iter;
+        ++dest_iter;
+      }
+    }
+  });
+  loop.Run(kernel_size / 2, kernel_size, [&](size_t y_start, size_t y_end) {
+    const float* kernel_iter = &kernel[y_start * kernel_size];
+    for (size_t y = y_start; y != y_end; ++y) {
+      size_t x_first = image_width - kernel_size / 2;
+      float* dest_iter = &dest[x_first + (y - kernel_size / 2) * image_width];
+      for (size_t x = 0; x != kernel_size / 2; ++x) {
+        *dest_iter = *kernel_iter;
+        ++kernel_iter;
+        ++dest_iter;
+      }
+      dest_iter = &dest[(y - kernel_size / 2) * image_width];
+      for (size_t x = kernel_size / 2; x != kernel_size; ++x) {
+        *dest_iter = *kernel_iter;
+        ++kernel_iter;
+        ++dest_iter;
+      }
+    }
+  });
+}
+
+void PrepareConvolutionKernel(float* dest, const float* source,
+                              size_t image_width, size_t image_height,
+                              size_t thread_count) {
+  aocommon::StaticFor<size_t> loop(thread_count);
+  loop.Run(0, image_height / 2, [&](size_t y_start, size_t y_end) {
+    const float* source_iter = &source[y_start * image_width];
+    for (size_t y = y_start; y != y_end; ++y) {
+      size_t y_dest = image_height - image_height / 2 + y;
+      size_t x_first = image_width - image_width / 2;
+      float* dest_iter = &dest[y_dest * image_width + x_first];
+      for (size_t x = 0; x != image_width / 2; ++x) {
+        *dest_iter = *source_iter;
+        ++source_iter;
+        ++dest_iter;
+      }
+      dest_iter = &dest[y_dest * image_width];
+      for (size_t x = image_width / 2; x != image_width; ++x) {
+        *dest_iter = *source_iter;
+        ++source_iter;
+        ++dest_iter;
+      }
+    }
+  });
+  loop.Run(image_height / 2, image_height, [&](size_t y_start, size_t y_end) {
+    const float* source_iter = &source[y_start * image_width];
+    for (size_t y = y_start; y != y_end; ++y) {
+      size_t x_first = image_width - image_width / 2;
+      float* dest_iter = &dest[x_first + (y - image_height / 2) * image_width];
+      for (size_t x = 0; x != image_width / 2; ++x) {
+        *dest_iter = *source_iter;
+        ++source_iter;
+        ++dest_iter;
+      }
+      dest_iter = &dest[(y - image_height / 2) * image_width];
+      for (size_t x = image_width / 2; x != image_width; ++x) {
+        *dest_iter = *source_iter;
+        ++source_iter;
+        ++dest_iter;
+      }
+    }
+  });
+}
+
+void Convolve(float* image, const float* kernel, size_t image_width,
+              size_t image_height, size_t thread_count) {
+  const size_t image_size = image_width * image_height;
+  const size_t complex_width = image_width / 2 + 1;
+  const size_t complex_size = complex_width * image_height;
+  float* temp_data = fftwf_alloc_real(image_size);
+  fftwf_complex* fft_image_data = fftwf_alloc_complex(complex_size);
+  fftwf_complex* fft_kernel_data = fftwf_alloc_complex(complex_size);
+
+  fftwf_plan plan_r2c =
+      fftwf_plan_dft_r2c_1d(image_width, nullptr, nullptr, FFTW_ESTIMATE);
+  fftwf_plan plan_c2c_forward = fftwf_plan_dft_1d(
+      image_height, nullptr, nullptr, FFTW_FORWARD, FFTW_ESTIMATE);
+  fftwf_plan plan_c2c_backward = fftwf_plan_dft_1d(
+      image_height, nullptr, nullptr, FFTW_BACKWARD, FFTW_ESTIMATE);
+  fftwf_plan plan_c2r =
+      fftwf_plan_dft_c2r_1d(image_width, nullptr, nullptr, FFTW_ESTIMATE);
+
+  aocommon::StaticFor<size_t> loop(thread_count);
+
+  FftR2CComposite(plan_r2c, plan_c2c_forward, image_height, image_width, image,
+                  fft_image_data, loop);
+
+  std::copy_n(kernel, image_size, temp_data);
+  FftR2CComposite(plan_r2c, plan_c2c_forward, image_height, image_width,
+                  temp_data, fft_kernel_data, loop);
+
+  const float fact = 1.0 / image_size;
+  loop.Run(0, image_height, [&](size_t y_start, size_t y_end) {
+    for (size_t y = y_start; y != y_end; ++y) {
+      for (size_t x = 0; x != complex_width; ++x) {
+        const size_t i = y * complex_width + x;
+        reinterpret_cast<std::complex<float>*>(fft_image_data)[i] *=
+            fact * reinterpret_cast<std::complex<float>*>(fft_kernel_data)[i];
+      }
+    }
+  });
+
+  FftC2RComposite(plan_c2c_backward, plan_c2r, image_height, image_width,
+                  fft_image_data, image, loop);
+
+  fftwf_free(fft_image_data);
+  fftwf_free(fft_kernel_data);
+  fftwf_free(temp_data);
+
+  fftwf_destroy_plan(plan_r2c);
+  fftwf_destroy_plan(plan_c2c_forward);
+  fftwf_destroy_plan(plan_c2c_backward);
+  fftwf_destroy_plan(plan_c2r);
+}
+
+}  // namespace fft
+}  // namespace schaapcommon
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fft/resampler.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/resampler.cc
@@ -0,0 +1,252 @@
+#include "resampler.h"
+
+#include <complex>
+
+using aocommon::WindowFunction;
+namespace schaapcommon {
+namespace fft {
+
+Resampler::Resampler(size_t input_width, size_t input_height,
+                     size_t output_width, size_t output_height,
+                     size_t cpu_count)
+    : input_width_(input_width),
+      input_height_(input_height),
+      output_width_(output_width),
+      output_height_(output_height),
+      fft_width_(std::max(input_width, output_width)),
+      fft_height_(std::max(input_height, output_height)),
+      window_function_(WindowFunction::Rectangular),
+      tukey_inset_size_(0.0),
+      correct_window_(false),
+      tasks_(cpu_count) {
+  float* input_data = reinterpret_cast<float*>(
+      fftwf_malloc(fft_width_ * fft_height_ * sizeof(float)));
+  fftwf_complex* fft_data = reinterpret_cast<fftwf_complex*>(
+      fftwf_malloc(fft_width_ * fft_height_ * sizeof(fftwf_complex)));
+  in_to_f_plan_ = fftwf_plan_dft_r2c_2d(input_height_, input_width_, input_data,
+                                        fft_data, FFTW_ESTIMATE);
+  f_to_out_plan_ = fftwf_plan_dft_c2r_2d(output_height_, output_width_,
+                                         fft_data, input_data, FFTW_ESTIMATE);
+  fftwf_free(fft_data);
+  fftwf_free(input_data);
+}
+
+Resampler::~Resampler() {
+  Finish();
+  fftwf_destroy_plan(in_to_f_plan_);
+  fftwf_destroy_plan(f_to_out_plan_);
+}
+
+void Resampler::RunThread() {
+  Task task;
+  while (tasks_.read(task)) {
+    RunSingle(task, false);
+  }
+}
+
+void Resampler::RunSingle(const Task& task, bool skip_window) const {
+  float* end_ptr = task.input + input_width_ * input_height_;
+  for (float* i = task.input; i != end_ptr; ++i) {
+    if (!std::isfinite(*i)) *i = 0.0;
+  }
+
+  if (window_function_ != WindowFunction::Rectangular && !skip_window) {
+    ApplyWindow(task.input);
+  }
+
+  const size_t fft_in_width = input_width_ / 2 + 1;
+  std::complex<float>* fft_data = reinterpret_cast<std::complex<float>*>(
+      fftwf_malloc(fft_in_width * input_height_ * sizeof(std::complex<float>)));
+  fftwf_execute_dft_r2c(in_to_f_plan_, task.input,
+                        reinterpret_cast<fftwf_complex*>(fft_data));
+
+  const size_t fft_out_width = output_width_ / 2 + 1;
+  // TODO this can be done without allocating more mem!
+  std::complex<float>* new_fft_data =
+      reinterpret_cast<std::complex<float>*>(fftwf_malloc(
+          fft_out_width * output_height_ * sizeof(std::complex<float>)));
+  std::uninitialized_fill_n(new_fft_data, fft_out_width * output_height_,
+                            std::complex<float>(0));
+
+  const size_t old_mid_x = input_width_ / 2;
+  const size_t new_mid_x = output_width_ / 2;
+
+  const size_t min_width = std::min(input_width_, output_width_);
+  const size_t min_height = std::min(input_height_, output_height_);
+
+  const size_t min_mid_x = min_width / 2;
+  const size_t min_mid_y = min_height / 2;
+
+  const float factor = 1.0 / (min_width * min_height);
+
+  for (size_t y = 0; y != min_height; ++y) {
+    size_t old_y = y - min_mid_y + input_height_;
+    size_t newY = y - min_mid_y + output_height_;
+    if (old_y >= input_height_) old_y -= input_height_;
+    if (newY >= output_height_) newY -= output_height_;
+
+    // The last dimension is stored half
+    for (size_t x = 0; x != min_mid_x; ++x) {
+      const size_t old_x = x;
+      const size_t new_x = x;
+      const size_t old_index = old_x + old_y * (old_mid_x + 1);
+      const size_t new_index = new_x + newY * (new_mid_x + 1);
+
+      new_fft_data[new_index] = fft_data[old_index] * factor;
+
+      // if((x == 0 && newY == 0) || (x==min_mid_x-1 && y==min_height-1))
+      //	std::cout << new_fft_data[new_index] << " (" << old_x << " , "
+      //<<
+      // old_y << ") - (" << new_x << " , " << newY << ")\n";
+    }
+    if (input_width_ >= output_width_) {
+      const size_t old_index = input_width_ / 2 + old_y * (old_mid_x + 1);
+      const size_t new_index = output_width_ / 2 + newY * (new_mid_x + 1);
+      new_fft_data[new_index] = fft_data[old_index] * factor;
+    }
+  }
+
+  fftwf_free(fft_data);
+
+  fftwf_execute_dft_c2r(f_to_out_plan_,
+                        reinterpret_cast<fftwf_complex*>(new_fft_data),
+                        task.output);
+
+  fftwf_free(new_fft_data);
+
+  if (correct_window_ && window_function_ != WindowFunction::Rectangular &&
+      !skip_window) {
+    UnapplyWindow(task.output);
+  }
+}
+
+void Resampler::SingleFT(const float* input, float* real_output,
+                         float* imaginary_output) {
+  aocommon::UVector<float> data(input_width_ * input_height_);
+  const size_t half_width = input_width_ / 2;
+  const size_t half_height = input_height_ / 2;
+  for (size_t y = 0; y != input_height_; ++y) {
+    size_t y_in = y + half_height;
+    if (y_in >= input_height_) y_in -= input_height_;
+    float* row_out_ptr = &data[y * input_width_];
+    const float* row_in_ptr = &input[y_in * input_width_];
+    for (size_t x = 0; x != input_width_; ++x) {
+      size_t x_in = x + half_width;
+      if (x_in >= input_width_) x_in -= input_width_;
+      if (std::isfinite(row_in_ptr[x_in])) {
+        row_out_ptr[x] = row_in_ptr[x_in];
+      } else {
+        row_out_ptr[x] = 0.0;
+      }
+    }
+  }
+
+  const size_t fft_in_width = input_width_ / 2 + 1;
+  std::complex<float>* fft_data = reinterpret_cast<std::complex<float>*>(
+      fftwf_malloc(fft_in_width * input_height_ * sizeof(std::complex<float>)));
+
+  fftwf_execute_dft_r2c(in_to_f_plan_, data.data(),
+                        reinterpret_cast<fftwf_complex*>(fft_data));
+
+  const size_t mid_x = input_width_ / 2;
+  const size_t mid_y = input_height_ / 2;
+
+  const float factor = 1.0 / sqrt(input_width_ * input_height_);
+
+  for (size_t y = 0; y != input_height_; ++y) {
+    size_t old_y = y + mid_y;
+    if (old_y >= input_height_) old_y -= input_height_;
+
+    // The last dimension is stored half
+    for (size_t x = 0; x != mid_x + 1; ++x) {
+      const size_t old_index = x + old_y * (mid_x + 1);
+      const size_t newIndex1 = mid_x - x + y * input_width_;
+
+      const std::complex<float>& val = fft_data[old_index] * factor;
+
+      real_output[newIndex1] = val.real();
+      imaginary_output[newIndex1] = val.imag();
+      if (x != mid_x) {
+        size_t yTo = input_height_ - y;
+        if (yTo == input_height_) yTo = 0;
+        size_t newIndex2 = mid_x + x + yTo * input_width_;
+        real_output[newIndex2] = val.real();
+        imaginary_output[newIndex2] = -val.imag();
+      }
+    }
+  }
+
+  fftwf_free(fft_data);
+}
+
+void Resampler::MakeWindow(aocommon::UVector<float>& data, size_t width) const {
+  if (window_function_ == WindowFunction::Tukey) {
+    MakeTukeyWindow(data, width);
+  } else {
+    data.resize(width);
+    for (size_t x = 0; x != width; ++x) {
+      data[x] = WindowFunction::Evaluate(window_function_, width, x) + 1e-5;
+    }
+  }
+}
+
+void Resampler::MakeTukeyWindow(aocommon::UVector<float>& data,
+                                size_t width) const {
+  // Make a Tukey window, which consists of
+  // left: a cosine going from 0 to 1
+  // mid: all 1
+  // right: a cosine going from 1 to 0
+  data.resize(width);
+  for (size_t x = 0; x != width; ++x) {
+    // left part of Tukey window
+    const double x_sh = (0.5 + x) * 2;
+    if (x_sh < width - tukey_inset_size_) {
+      const double pos = x_sh / (width - tukey_inset_size_);
+      data[x] = (std::cos((pos + 1.0) * M_PI) + 1.0) * 0.5;
+    } else if (x_sh < width + tukey_inset_size_) {
+      data[x] = 1.0;
+    } else {
+      const double pos =
+          (x_sh - (width + tukey_inset_size_)) / (width - tukey_inset_size_);
+      data[x] = (std::cos(pos * M_PI) + 1.0) * 0.5;
+    }
+  }
+}
+
+void Resampler::ApplyWindow(float* data) const {
+  if (window_row_in_.empty()) {
+    MakeWindow(window_row_in_, input_width_);
+    MakeWindow(window_col_in_, input_height_);
+    if (correct_window_) {
+      aocommon::UVector<float> window_image_in(input_width_ * input_height_);
+      float* in_ptr = window_image_in.data();
+      for (size_t y = 0; y != input_height_; ++y) {
+        for (size_t x = 0; x != input_width_; ++x) {
+          *in_ptr = window_row_in_[x] * window_col_in_[y];
+          ++in_ptr;
+        }
+      }
+
+      window_out_.resize(output_width_ * output_height_);
+      Task task;
+      task.input = window_image_in.data();
+      task.output = window_out_.data();
+      RunSingle(task, true);
+    }
+  }
+  for (size_t y = 0; y != input_height_; ++y) {
+    for (size_t x = 0; x != input_width_; ++x) {
+      *data *= window_row_in_[x] * window_col_in_[y];
+      ++data;
+    }
+  }
+}
+
+void Resampler::UnapplyWindow(float* data) const {
+  size_t n = output_width_ * output_height_;
+  for (size_t i = 0; i != n; ++i) {
+    data[i] /= window_out_[i];
+  }
+}
+}  // namespace fft
+}  // namespace schaapcommon
Index: wsclean/external/schaapcommon/src/fft/restoreimage.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/restoreimage.cc
@@ -0,0 +1,95 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "restoreimage.h"
+
+#include <cmath>
+#include <array>
+#include <vector>
+
+#include <aocommon/imagecoordinates.h>
+#include <aocommon/uvector.h>
+
+#include "convolution.h"
+
+namespace schaapcommon {
+namespace fft {
+void RestoreImage(float* image_data, const float* model_data,
+                  size_t image_width, size_t image_height,
+                  long double beam_major_axis, long double beam_minor_axis,
+                  long double beam_position_angle, long double pixel_scale_l,
+                  long double pixel_scale_m, size_t thread_count) {
+  if (beam_major_axis == 0.0 && beam_minor_axis == 0.0) {
+    for (size_t j = 0; j != image_width * image_height; ++j) {
+      image_data[j] += model_data[j];
+    }
+  } else {
+    // Using the FWHM formula for a Gaussian:
+    const long double sigma_major =
+        beam_major_axis / (2.0L * std::sqrt(2.0L * std::log(2.0L)));
+    const long double sigma_minor =
+        beam_minor_axis / (2.0L * std::sqrt(2.0L * std::log(2.0L)));
+
+    // Position angle is angle from North:
+    const long double angle = beam_position_angle + M_PI_2;
+    const long double cos_angle = std::cos(angle);
+    const long double sin_angle = std::sin(angle);
+
+    // Make rotation matrix
+    std::array<long double, 4> transf;
+    transf[0] = cos_angle;
+    transf[1] = -sin_angle;
+    transf[2] = sin_angle;
+    transf[3] = cos_angle;
+
+    const double sigma_max = std::max(std::fabs(sigma_major * transf[0]),
+                                      std::fabs(sigma_major * transf[1]));
+    // Multiply with scaling matrix to make variance 1.
+    transf[0] /= sigma_major;
+    transf[1] /= sigma_major;
+    transf[2] /= sigma_minor;
+    transf[3] /= sigma_minor;
+
+    const size_t min_dimension = std::min(image_width, image_height);
+    size_t bounding_box_size = std::min<size_t>(
+        std::ceil(sigma_max * 40.0 / std::min(pixel_scale_l, pixel_scale_m)),
+        min_dimension);
+    if (bounding_box_size % 2 != 0) {
+      ++bounding_box_size;
+    }
+    if (bounding_box_size > std::min(image_width, image_height)) {
+      bounding_box_size = std::min(image_width, image_height);
+    }
+    aocommon::UVector<float> kernel(bounding_box_size * bounding_box_size);
+    auto iter = kernel.begin();
+    for (size_t y = 0; y != bounding_box_size; ++y) {
+      for (size_t x = 0; x != bounding_box_size; ++x) {
+        long double l;
+        long double m;
+        aocommon::ImageCoordinates::XYToLM<long double>(
+            x, y, pixel_scale_l, pixel_scale_m, bounding_box_size,
+            bounding_box_size, l, m);
+        const long double l_transf = l * transf[0] + m * transf[1];
+        const long double m_transf = l * transf[2] + m * transf[3];
+        // Kernel value is evaluation of a Gaussian with unit-valued
+        // coefficients
+        const long double dist_squared =
+            l_transf * l_transf + m_transf * m_transf;
+        *iter = std::exp(-0.5 * dist_squared);
+        ++iter;
+      }
+    }
+
+    aocommon::UVector<float> convolved_model(
+        model_data, model_data + image_width * image_height);
+
+    schaapcommon::fft::ResizeAndConvolve(convolved_model.data(), image_width,
+                                         image_height, kernel.data(),
+                                         bounding_box_size, thread_count);
+    for (size_t j = 0; j != image_width * image_height; ++j) {
+      image_data[j] += convolved_model[j];
+    }
+  }
+}
+}  // namespace fft
+}  // namespace schaapcommon
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fft/test/CMakeLists.txt
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/test/CMakeLists.txt
@@ -0,0 +1,6 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+include(${SCHAAPCOMMON_SOURCE_DIR}/cmake/unittest.cmake)
+
+add_unittest(fft runtests.cc tconvolution.cc tresampler.cc trestoreimage.cc)
Index: wsclean/external/schaapcommon/src/fft/test/runtests.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/test/runtests.cc
@@ -0,0 +1,6 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#define BOOST_TEST_MODULE schaapcommon_fft
+
+#include <boost/test/unit_test.hpp>
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fft/test/tconvolution.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/test/tconvolution.cc
@@ -0,0 +1,84 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include <boost/test/unit_test.hpp>
+
+#include "convolution.h"
+
+#include <aocommon/image.h>
+#include <iostream>
+
+namespace {
+constexpr size_t kWidth = 4;
+constexpr size_t kHeight = 4;
+constexpr size_t kThreadCount = 2;
+}  // namespace
+
+BOOST_AUTO_TEST_SUITE(fft_convolution)
+
+BOOST_AUTO_TEST_CASE(prepare_kernel) {
+  // Values are chosen such that a translation to the origin yields the values
+  // in ascending order.
+  aocommon::Image kernel_in(kWidth, kHeight,
+                            {10.0, 11.0, 8.0, 9.0, 14.0, 15.0, 12.0, 13.0, 2.0,
+                             3.0, 0.0, 1.0, 6.0, 7.0, 4.0, 5.0});
+  aocommon::Image kernel_out(kWidth, kHeight);
+  schaapcommon::fft::PrepareConvolutionKernel(
+      kernel_out.Data(), kernel_in.Data(), kWidth, kHeight, kThreadCount);
+  for (size_t i = 0; i != kernel_out.Size(); ++i) {
+    BOOST_CHECK_CLOSE(kernel_out[i], static_cast<float>(i), 1e-4);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(prepare_small_kernel) {
+  BOOST_CHECK_EQUAL(kWidth, kHeight);
+  aocommon::Image kernel_in(kWidth / 2, kHeight / 2, {16.0, 13.0, 4.0, 1.0});
+  aocommon::Image kernel_out(kWidth, kHeight, 0.0);
+  BOOST_CHECK_THROW(schaapcommon::fft::PrepareSmallConvolutionKernel(
+                        kernel_out.Data(), kWidth, kHeight, kernel_in.Data(),
+                        kWidth * 2, kThreadCount),
+                    std::runtime_error);
+
+  schaapcommon::fft::PrepareSmallConvolutionKernel(kernel_out.Data(), kWidth,
+                                                   kHeight, kernel_in.Data(),
+                                                   kWidth / 2, kThreadCount);
+
+  // kernel_out should have non-zero corner values only
+  for (size_t i = 0; i != kernel_out.Size(); ++i) {
+    if (i != 0 && i != (kWidth - 1) && i != (kWidth * (kHeight - 1)) &&
+        i != kWidth * kHeight - 1) {
+      BOOST_CHECK_CLOSE(kernel_out[i], 0.0f, 1e-4);
+    } else {
+      BOOST_CHECK_CLOSE(kernel_out[i], static_cast<float>(i + 1), 1e-4);
+    }
+  }
+}
+
+BOOST_AUTO_TEST_CASE(convolve) {
+  const float dirac_scale = 0.5;
+  aocommon::Image image(kWidth, kHeight);
+  for (size_t i = 0; i != image.Size(); ++i) {
+    image[i] = i;
+  }
+  aocommon::Image kernel(kWidth, kHeight, 0.0);
+  aocommon::Image image_ref = image;
+
+  kernel[kWidth * kHeight / 2 + kWidth / 2] = dirac_scale * 1.0f;
+
+  schaapcommon::fft::MakeFftwfPlannerThreadSafe();
+  BOOST_CHECK_THROW(schaapcommon::fft::ResizeAndConvolve(
+                        image.Data(), kWidth, kHeight, kernel.Data(),
+                        kWidth * 2, kThreadCount),
+                    std::runtime_error);
+
+  schaapcommon::fft::ResizeAndConvolve(image.Data(), kWidth, kHeight,
+                                       kernel.Data(), kWidth, kThreadCount);
+
+  // Convolution with (scaled) dirac kernel should return same signal,
+  // scaled by a constant factor.
+  for (size_t i = 0; i != image.Size(); ++i) {
+    BOOST_CHECK_CLOSE(image[i], image_ref[i] * dirac_scale, 1e-4);
+  }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fft/test/tresampler.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/test/tresampler.cc
@@ -0,0 +1,140 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include <boost/test/unit_test.hpp>
+
+#include "resampler.h"
+
+#include <cmath>
+
+#include <aocommon/image.h>
+
+using schaapcommon::fft::Resampler;
+
+namespace {
+constexpr size_t kInputWidth = 16;
+constexpr size_t kInputHeight = 16;
+
+constexpr size_t kFactorLow = 2;
+constexpr size_t kOutputWidthLow = kInputWidth / kFactorLow;
+constexpr size_t kOutputHeightLow = kInputHeight / kFactorLow;
+
+constexpr size_t kFactorHigh = 4;
+constexpr size_t kOutputWidthHigh = kInputWidth * kFactorHigh;
+constexpr size_t kOutputHeightHigh = kInputWidth * kFactorHigh;
+
+constexpr size_t kThreadCount = 1;
+
+/**
+ * @brief Construct a signal on the image. Tune wave number \c k such that
+ * signal is periodic.
+ */
+void ConstructSignal(aocommon::Image& image, float k) {
+  for (size_t i = 0; i < image.Size(); ++i) {
+    const size_t col = i % image.Width();
+    const size_t row = i / image.Width();
+    image[i] = std::sin(k * col) + std::cos(k * row);
+  }
+}
+
+void CheckResampledImage(const aocommon::Image& image_low_resolution,
+                         const aocommon::Image& image_high_resolution,
+                         bool scale_results) {
+  BOOST_CHECK_EQUAL(image_low_resolution.Width(),
+                    image_low_resolution.Height());
+  BOOST_CHECK_EQUAL(image_high_resolution.Width(),
+                    image_high_resolution.Height());
+  BOOST_CHECK(image_high_resolution.Width() >= image_low_resolution.Width());
+
+  const size_t scale_factor =
+      image_high_resolution.Width() / image_low_resolution.Width();
+
+  size_t dummy_index = 0;
+  for (size_t i = 0; i != image_high_resolution.Size(); ++i) {
+    const size_t row = i / image_high_resolution.Width();
+    const size_t col = i % image_high_resolution.Width();
+
+    if ((row % scale_factor == 0) && (col % scale_factor == 0)) {
+      if (scale_results) {
+        BOOST_CHECK_SMALL(
+            image_high_resolution[i] * scale_factor * scale_factor -
+                image_low_resolution[dummy_index],
+            static_cast<float>(1e-5));
+      } else {
+        BOOST_CHECK_SMALL(
+            image_high_resolution[i] - image_low_resolution[dummy_index],
+            static_cast<float>(1e-5));
+      }
+      ++dummy_index;
+    }
+  }
+  BOOST_CHECK_EQUAL(dummy_index, image_low_resolution.Size());
+}
+
+}  // namespace
+
+BOOST_AUTO_TEST_SUITE(fft_resampler)
+
+BOOST_AUTO_TEST_CASE(downsample_regular_window) {
+  BOOST_CHECK(kFactorLow >= 1);
+
+  Resampler resampler(kInputWidth, kInputHeight, kOutputWidthLow,
+                      kOutputHeightLow, kThreadCount);
+
+  aocommon::Image input_image(kInputWidth, kInputHeight);
+  aocommon::Image output_image(kOutputWidthLow, kOutputHeightLow, 0);
+  ConstructSignal(input_image, 0.125 * M_PI);
+
+  resampler.Resample(input_image.Data(), output_image.Data());
+
+  const bool scale_output = true;
+  CheckResampledImage(output_image, input_image, scale_output);
+}
+
+BOOST_AUTO_TEST_CASE(downsample_tukey_window) {
+  BOOST_CHECK(kFactorLow >= 1);
+
+  Resampler resampler(kInputWidth, kInputHeight, kOutputWidthLow,
+                      kOutputHeightLow, kThreadCount);
+
+  aocommon::Image input_image(kInputWidth, kInputHeight);
+  aocommon::Image output_image(kOutputWidthLow, kOutputHeightLow, 0);
+  ConstructSignal(input_image, 0.125 * M_PI);
+
+  resampler.SetTukeyWindow(kInputWidth, kInputWidth);
+  resampler.Resample(input_image.Data(), output_image.Data());
+
+  const bool scale_output = false;
+  CheckResampledImage(output_image, input_image, scale_output);
+}
+
+BOOST_AUTO_TEST_CASE(upsample_tukey_window) {
+  Resampler resampler(kInputWidth, kInputHeight, kOutputWidthHigh,
+                      kOutputHeightHigh, kThreadCount);
+
+  aocommon::Image input_image(kInputWidth, kInputHeight);
+  aocommon::Image output_image(kOutputWidthHigh, kOutputHeightHigh, 0);
+  ConstructSignal(input_image, 0.125 * M_PI);
+
+  resampler.SetTukeyWindow(kInputWidth, kInputWidth);
+  resampler.Resample(input_image.Data(), output_image.Data());
+
+  const bool scale_output = false;
+  CheckResampledImage(input_image, output_image, scale_output);
+}
+
+BOOST_AUTO_TEST_CASE(upsample_regular_window) {
+  Resampler resampler(kInputWidth, kInputHeight, kOutputWidthHigh,
+                      kOutputHeightHigh, kThreadCount);
+
+  aocommon::Image input_image(kInputWidth, kInputHeight);
+  aocommon::Image output_image(kOutputWidthHigh, kOutputHeightHigh, 0);
+  ConstructSignal(input_image, 0.125 * M_PI);
+
+  resampler.Resample(input_image.Data(), output_image.Data());
+
+  const bool scale_output = false;
+  CheckResampledImage(input_image, output_image, scale_output);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fft/test/trestoreimage.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fft/test/trestoreimage.cc
@@ -0,0 +1,118 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include <boost/test/unit_test.hpp>
+
+#include "restoreimage.h"
+
+#include <cmath>
+
+#include <aocommon/image.h>
+#include <aocommon/imagecoordinates.h>
+
+#include "convolution.h"
+
+#include <iostream>
+
+using schaapcommon::fft::MakeFftwfPlannerThreadSafe;
+using schaapcommon::fft::RestoreImage;
+
+namespace {
+constexpr size_t kWidth = 16;
+constexpr size_t kHeight = 16;
+constexpr double kFluxDensity = 5.0;
+constexpr long double kPixelScaleL = M_PI / (180.0 * 60.0);  // 1 amin
+constexpr long double kPixelScaleM = kPixelScaleL;           // 1 amin
+constexpr long double kBeamAxis = 2 * kPixelScaleL;
+constexpr size_t kThreadCount = 2;
+
+struct ImageFixture {
+  ImageFixture() : model(kWidth, kHeight, 0.0), restored(kWidth, kHeight, 0.0) {
+    BOOST_CHECK_EQUAL(kWidth, kHeight);
+    // Assign center pixel value of 0.
+    model[kHeight / 2 * kWidth + kWidth / 2] = kFluxDensity;
+  }
+
+  aocommon::Image model;
+  aocommon::Image restored;
+};
+
+}  // namespace
+
+BOOST_AUTO_TEST_SUITE(restore_image)
+
+BOOST_FIXTURE_TEST_CASE(restore_no_beam, ImageFixture) {
+  RestoreImage(restored.Data(), model.Data(), kWidth, kHeight, 0.0, 0.0, 0.0,
+               kPixelScaleL, kPixelScaleM, kThreadCount);
+
+  for (size_t i = 0; i != restored.Size(); ++i) {
+    BOOST_CHECK_SMALL(std::abs(restored[i] - model[i]), 1e-7f);
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(restore_circular_beam, ImageFixture) {
+  MakeFftwfPlannerThreadSafe();
+
+  RestoreImage(restored.Data(), model.Data(), kWidth, kHeight, kBeamAxis,
+               kBeamAxis, 0.0, kPixelScaleL, kPixelScaleM, kThreadCount);
+
+  // Compute stddev using the full width half maximum (FWHM) formula for a
+  // Gaussian:
+  const long double sigma =
+      kBeamAxis / (2.0L * std::sqrt(2.0L * std::log(2.0L)));
+
+  for (size_t i = 0; i != restored.Size(); ++i) {
+    const size_t x = i % restored.Width();
+    const size_t y = i / restored.Width();
+    // Convert to l,m coordinates
+    double l;
+    double m;
+    aocommon::ImageCoordinates::XYToLM<double>(x, y, kPixelScaleL, kPixelScaleM,
+                                               kWidth, kHeight, l, m);
+    // Computed distance scaled by stddev
+    const double dist_squared = (l * l + m * m) / (sigma * sigma);
+    const double gaussian = kFluxDensity * std::exp(-0.5 * dist_squared);
+    BOOST_CHECK_SMALL(std::abs(restored[i] - gaussian), 1e-7);
+
+    if (x == kWidth / 2 && y == kHeight / 2) {
+      BOOST_CHECK_CLOSE(restored[i], kFluxDensity, 1e-8);
+    }
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(restore_elliptical_beam, ImageFixture) {
+  MakeFftwfPlannerThreadSafe();
+
+  const long double beam_axis_major = 1.5 * kBeamAxis;
+  const long double beam_axis_minor = kBeamAxis;
+  RestoreImage(restored.Data(), model.Data(), kWidth, kHeight, beam_axis_major,
+               beam_axis_minor, 0.0, kPixelScaleL, kPixelScaleM, kThreadCount);
+
+  // Compute stddev using the full width half maximum (FWHM) formula for a
+  // Gaussian:
+  const long double sigma_major =
+      beam_axis_major / (2.0L * std::sqrt(2.0L * std::log(2.0L)));
+  const long double sigma_minor =
+      beam_axis_minor / (2.0L * std::sqrt(2.0L * std::log(2.0L)));
+
+  for (size_t i = 0; i != restored.Size(); ++i) {
+    const size_t x = i % restored.Width();
+    const size_t y = i / restored.Width();
+    // Convert to l,m coordinates
+    double l;
+    double m;
+    aocommon::ImageCoordinates::XYToLM<double>(x, y, kPixelScaleL, kPixelScaleM,
+                                               kWidth, kHeight, l, m);
+    // Computed distance scaled by stddev
+    const double dist_squared = (l / sigma_minor) * (l / sigma_minor) +
+                                (m / sigma_major) * (m / sigma_major);
+    const double gaussian = kFluxDensity * std::exp(-0.5 * dist_squared);
+    BOOST_CHECK_SMALL(std::abs(restored[i] - gaussian), 3e-7);
+
+    if (x == kWidth / 2 && y == kHeight / 2) {
+      BOOST_CHECK_CLOSE(restored[i], kFluxDensity, 1e-8);
+    }
+  }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fitters/CMakeLists.txt
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/CMakeLists.txt
@@ -0,0 +1,32 @@
+# Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+get_filename_component(MODULE ${CMAKE_CURRENT_SOURCE_DIR} NAME)
+
+set(PUBLIC_HEADER_DIR ${SCHAAPCOMMON_SOURCE_DIR}/include/schaapcommon/${MODULE})
+
+set(PUBLIC_HEADERS
+    ${PUBLIC_HEADER_DIR}/gaussianfitter.h ${PUBLIC_HEADER_DIR}/nlplfitter.h
+    ${PUBLIC_HEADER_DIR}/polynomialfitter.h
+    ${PUBLIC_HEADER_DIR}/spectralfitter.h)
+
+target_sources(
+  ${SCHAAPCOMMON_PROJECT_NAME}
+  PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/gaussianfitter.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/nlplfitter.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/polynomialfitter.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/spectralfitter.cc)
+
+# Simplifies including the public headers.
+target_include_directories(${SCHAAPCOMMON_PROJECT_NAME}
+                           PRIVATE "$<BUILD_INTERFACE:${PUBLIC_HEADER_DIR}>")
+
+# Install headers and add test directory when built as stand-alone.
+if(SCHAAPCOMMON_MASTER_PROJECT)
+  install(FILES ${PUBLIC_HEADERS}
+          DESTINATION "include/${CMAKE_PROJECT_NAME}/${MODULE}")
+
+  if(BUILD_TESTING)
+    add_subdirectory(test)
+  endif()
+endif()
Index: wsclean/external/schaapcommon/src/fitters/gaussianfitter.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/gaussianfitter.cc
@@ -0,0 +1,784 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "gaussianfitter.h"
+
+#include <cmath>
+#include <iostream>
+
+#include <gsl/gsl_vector.h>
+#include <gsl/gsl_multifit_nlin.h>
+
+#include <aocommon/matrix2x2.h>
+#include <aocommon/uvector.h>
+
+using aocommon::Matrix2x2;
+
+namespace schaapcommon {
+namespace fitters {
+
+namespace {
+
+const long double kSigmaToBeam = 2.0L * std::sqrt(2.0L * std::log(2.0L));
+
+void ToAnglesAndFwhm(double sx, double sy, double beta, double& ellipse_major,
+                     double& ellipse_minor, double& ellipse_phase_angle) {
+  const double beta_factor = 1.0 - beta * beta;
+  double cov[4];
+  cov[0] = sx * sx / beta_factor;
+  cov[1] = beta * sx * sy / beta_factor;
+  cov[2] = cov[1];
+  cov[3] = sy * sy / beta_factor;
+
+  double e1, e2, vec1[2], vec2[2];
+  Matrix2x2::EigenValuesAndVectors(cov, e1, e2, vec1, vec2);
+  if (std::isfinite(e1)) {
+    ellipse_major = std::sqrt(std::fabs(e1)) * kSigmaToBeam;
+    ellipse_minor = std::sqrt(std::fabs(e2)) * kSigmaToBeam;
+    if (ellipse_major < ellipse_minor) {
+      std::swap(ellipse_major, ellipse_minor);
+      vec1[0] = vec2[0];
+      vec1[1] = vec2[1];
+    }
+    ellipse_phase_angle = -std::atan2(vec1[0], vec1[1]);
+  } else {
+    ellipse_major = std::sqrt(std::fabs(sx)) * kSigmaToBeam;
+    ellipse_minor = std::sqrt(std::fabs(sx)) * kSigmaToBeam;
+    ellipse_phase_angle = 0.0;
+  }
+}
+
+/**
+ * Calculates a two dimensional gaussian with the specified parameters.
+ * @param x X coordinate.
+ * @param y Y coordinate.
+ * @param sx Sigma value for the x direction.
+ * @param sy Sigma value for the y direction.
+ * @param beta Beta value.
+ */
+double GaussCentered(double x, double y, double sx, double sy, double beta) {
+  return std::exp(-x * x / (2.0 * sx * sx) + beta * x * y / (sx * sy) -
+                  y * y / (2.0 * sy * sy));
+}
+
+/**
+ * Calculates a circular two dimensional gaussian with the specified parameters.
+ * @param x X coordinate.
+ * @param y Y coordinate.
+ * @param s Sigma value for both x and y directions.
+ */
+double GaussCircularCentered(double x, double y, double s) {
+  return std::exp((-x * x - y * y) / (2.0 * s * s));
+}
+
+/**
+ * Fitting function for SingleFit2DGaussianCentred(). Calculates the sum of the
+ * squared errors(/residuals).
+ */
+int FittingCentered(const gsl_vector* xvec, void* data, gsl_vector* f) {
+  const GaussianFitter& fitter = *static_cast<const GaussianFitter*>(data);
+  const double sx = gsl_vector_get(xvec, 0);
+  const double sy = gsl_vector_get(xvec, 1);
+  const double beta = gsl_vector_get(xvec, 2);
+  const size_t width = fitter.Width();
+  const size_t height = fitter.Height();
+  const int x_mid = width / 2;
+  const int y_mid = height / 2;
+  const double scale = 1.0 / fitter.ScaleFactor();
+
+  size_t data_index = 0;
+  for (size_t yi = 0; yi != height; ++yi) {
+    double y = (yi - y_mid) * scale;
+    for (size_t xi = 0; xi != width; ++xi) {
+      double x = (xi - x_mid) * scale;
+      double e = GaussCentered(x, y, sx, sy, beta) - fitter.Image()[data_index];
+      gsl_vector_set(f, data_index, e);
+      ++data_index;
+    }
+  }
+  return GSL_SUCCESS;
+}
+
+int FittingCircularCentered(const gsl_vector* xvec, void* data, gsl_vector* f) {
+  const GaussianFitter& fitter = *static_cast<const GaussianFitter*>(data);
+  const double s = gsl_vector_get(xvec, 0);
+  const size_t width = fitter.Width();
+  const size_t height = fitter.Height();
+  const int x_mid = width / 2;
+  const int y_mid = height / 2;
+  const double scale = 1.0 / fitter.ScaleFactor();
+
+  size_t data_index = 0;
+  for (size_t yi = 0; yi != height; ++yi) {
+    double y = (yi - y_mid) * scale;
+    for (size_t xi = 0; xi != width; ++xi) {
+      double x = (xi - x_mid) * scale;
+      double e = GaussCircularCentered(x, y, s) - fitter.Image()[data_index];
+      gsl_vector_set(f, data_index, e);
+      ++data_index;
+    }
+  }
+  return GSL_SUCCESS;
+}
+
+/**
+ * Derivative function belong with SingleFit2DGaussianCentred().
+ */
+int FittingDerivativeCentered(const gsl_vector* xvec, void* data,
+                              gsl_matrix* J) {
+  const GaussianFitter& fitter = *static_cast<const GaussianFitter*>(data);
+  const double sx = gsl_vector_get(xvec, 0);
+  const double sy = gsl_vector_get(xvec, 1);
+  const double beta = gsl_vector_get(xvec, 2);
+  const size_t width = fitter.Width();
+  const size_t height = fitter.Height();
+  const int x_mid = width / 2;
+  const int y_mid = height / 2;
+  const double scale = 1.0 / fitter.ScaleFactor();
+
+  size_t data_index = 0;
+  for (size_t yi = 0; yi != height; ++yi) {
+    double y = (yi - y_mid) * scale;
+    for (size_t xi = 0; xi != width; ++xi) {
+      double x = (xi - x_mid) * scale;
+      double exp_term = GaussCentered(x, y, sx, sy, beta);
+      double dsx =
+          (beta * x * y / (sx * sx * sy) + x * x / (sx * sx * sx)) * exp_term;
+      double dsy =
+          (beta * x * y / (sy * sy * sx) + y * y / (sy * sy * sy)) * exp_term;
+      double dbeta = x * y / (sx * sy) * exp_term;
+      gsl_matrix_set(J, data_index, 0, dsx);
+      gsl_matrix_set(J, data_index, 1, dsy);
+      gsl_matrix_set(J, data_index, 2, dbeta);
+      ++data_index;
+    }
+  }
+  return GSL_SUCCESS;
+}
+
+int FittingDerivativeCircularCentered(const gsl_vector* xvec, void* data,
+                                      gsl_matrix* J) {
+  const GaussianFitter& fitter = *static_cast<const GaussianFitter*>(data);
+  const double s = gsl_vector_get(xvec, 0);
+  const size_t width = fitter.Width();
+  const size_t height = fitter.Height();
+  const int x_mid = width / 2, y_mid = height / 2;
+  const double scale = 1.0 / fitter.ScaleFactor();
+
+  size_t data_index = 0;
+  for (size_t yi = 0; yi != height; ++yi) {
+    double y = (yi - y_mid) * scale;
+    for (size_t xi = 0; xi != width; ++xi) {
+      double x = (xi - x_mid) * scale;
+      double exp_term = GaussCircularCentered(x, y, s);
+      // derivative of exp((-x*x - y*y)/(2.0*s*s)) to s
+      // = (-x*x - y*y)/2.0*-2/(s*s*s)
+      // = (-x*x - y*y)/(-s*s*s)
+      // = (x*x + y*y)/(s*s*s)
+      double ds = ((x * x + y * y) / (s * s * s)) * exp_term;
+      gsl_matrix_set(J, data_index, 0, ds);
+      ++data_index;
+    }
+  }
+  return GSL_SUCCESS;
+}
+
+/**
+ * Squared error and derivative function together.
+ */
+int FittingBothCentered(const gsl_vector* x, void* data, gsl_vector* f,
+                        gsl_matrix* J) {
+  FittingCentered(x, data, f);
+  FittingDerivativeCentered(x, data, J);
+  return GSL_SUCCESS;
+}
+
+int FittingBothCircularCentered(const gsl_vector* x, void* data, gsl_vector* f,
+                                gsl_matrix* J) {
+  FittingCircularCentered(x, data, f);
+  FittingDerivativeCircularCentered(x, data, J);
+  return GSL_SUCCESS;
+}
+
+int FittingWithAmplitude(const gsl_vector* xvec, void* data, gsl_vector* f) {
+  const GaussianFitter& fitter = *static_cast<const GaussianFitter*>(data);
+  const double v = gsl_vector_get(xvec, 0);
+  const double xc = gsl_vector_get(xvec, 1);
+  const double yc = gsl_vector_get(xvec, 2);
+  const double sx = gsl_vector_get(xvec, 3);
+  const double sy = gsl_vector_get(xvec, 4);
+  const double beta = gsl_vector_get(xvec, 5);
+  const size_t width = fitter.Width();
+  const size_t height = fitter.Height();
+  const int x_mid = width / 2;
+  const int y_mid = height / 2;
+  const double scale = 1.0 / fitter.ScaleFactor();
+
+  size_t data_index = 0;
+  for (int yi = 0; yi != int(height); ++yi) {
+    double yS = yc + (yi - y_mid) * scale;
+    for (int xi = 0; xi != int(width); ++xi) {
+      double xS = xc + (xi - x_mid) * scale;
+      double e =
+          GaussCentered(xS, yS, sx, sy, beta) * v - fitter.Image()[data_index];
+      gsl_vector_set(f, data_index, e);
+      ++data_index;
+    }
+  }
+  return GSL_SUCCESS;
+}
+
+int FittingDerivativeWithAmplitude(const gsl_vector* xvec, void* data,
+                                   gsl_matrix* J) {
+  const GaussianFitter& fitter = *static_cast<const GaussianFitter*>(data);
+  const double scale = 1.0 / fitter.ScaleFactor();
+  const double v = gsl_vector_get(xvec, 0);
+  const double xc = gsl_vector_get(xvec, 1);
+  const double yc = gsl_vector_get(xvec, 2);
+  const double sx = gsl_vector_get(xvec, 3);
+  const double sy = gsl_vector_get(xvec, 4);
+  const double beta = gsl_vector_get(xvec, 5);
+  if (fitter.PosConstrained() != 0.0 &&
+      (std::fabs(xc - fitter.XInit()) > fitter.PosConstrained() * scale ||
+       std::fabs(yc - fitter.YInit()) > fitter.PosConstrained() * scale)) {
+    std::cout << "GSL_EDOM\n";
+    return GSL_EDOM;
+  }
+  const size_t width = fitter.Width();
+  const size_t height = fitter.Height();
+  const int x_mid = width / 2;
+  const int y_mid = height / 2;
+
+  size_t data_index = 0;
+  for (int yi = 0; yi != int(height); ++yi) {
+    double y = yc + (yi - y_mid) * scale;
+    for (int xi = 0; xi != int(width); ++xi) {
+      // TODO I need to go over the signs -- ds, dy, dsx, dsy in particular
+      double x = xc + (xi - x_mid) * scale;
+      double exp_term = GaussCentered(x, y, sx, sy, beta);
+      double dv = exp_term;
+      exp_term *= v;
+      double dx = (-beta * y / (sx * sy) - x / (sx * sx)) * exp_term;
+      double dy = (-beta * x / (sy * sx) - y / (sy * sy)) * exp_term;
+      double dsx =
+          (beta * x * y / (sx * sx * sy) + x * x / (sx * sx * sx)) * exp_term;
+      double dsy =
+          (beta * x * y / (sy * sy * sx) + y * y / (sy * sy * sy)) * exp_term;
+      double dbeta = x * y / (sx * sy) * exp_term;
+      gsl_matrix_set(J, data_index, 0, dv);
+      gsl_matrix_set(J, data_index, 1, dx);
+      gsl_matrix_set(J, data_index, 2, dy);
+      gsl_matrix_set(J, data_index, 3, dsx);
+      gsl_matrix_set(J, data_index, 4, dsy);
+      gsl_matrix_set(J, data_index, 5, dbeta);
+      ++data_index;
+    }
+  }
+  return GSL_SUCCESS;
+}
+
+int FittingBothWithAmplitude(const gsl_vector* x, void* data, gsl_vector* f,
+                             gsl_matrix* J) {
+  FittingWithAmplitude(x, data, f);
+  FittingDerivativeWithAmplitude(x, data, J);
+  return GSL_SUCCESS;
+}
+
+int FittingWithAmplitudeAndFloor(const gsl_vector* xvec, void* data,
+                                 gsl_vector* f) {
+  const GaussianFitter& fitter = *static_cast<const GaussianFitter*>(data);
+  const double scale = 1.0 / fitter.ScaleFactor();
+  const double v = gsl_vector_get(xvec, 0);
+  const double xc = gsl_vector_get(xvec, 1);
+  const double yc = gsl_vector_get(xvec, 2);
+  const double sx = gsl_vector_get(xvec, 3);
+  const double sy = gsl_vector_get(xvec, 4);
+  const double beta = gsl_vector_get(xvec, 5);
+  const double fl = gsl_vector_get(xvec, 6);
+  if (fitter.PosConstrained() != 0.0 &&
+      (std::fabs(xc - fitter.XInit()) > fitter.PosConstrained() * scale ||
+       std::fabs(yc - fitter.YInit()) > fitter.PosConstrained() * scale)) {
+    return GSL_EDOM;
+  }
+  const size_t width = fitter.Width();
+  const size_t height = fitter.Height();
+  const int x_mid = width / 2;
+  const int y_mid = height / 2;
+
+  size_t data_index = 0;
+  for (int yi = 0; yi != int(height); ++yi) {
+    double yS = yc + (yi - y_mid) * scale;
+    for (int xi = 0; xi != int(width); ++xi) {
+      double xS = xc + (xi - x_mid) * scale;
+      double e = GaussCentered(xS, yS, sx, sy, beta) * v -
+                 fitter.Image()[data_index] + fl;
+      gsl_vector_set(f, data_index, e);
+      ++data_index;
+    }
+  }
+  return GSL_SUCCESS;
+}
+
+int FittingDerivativeWithAmplitudeAndFloor(const gsl_vector* xvec, void* data,
+                                           gsl_matrix* J) {
+  const GaussianFitter& fitter = *static_cast<const GaussianFitter*>(data);
+  const double v = gsl_vector_get(xvec, 0);
+  const double xc = gsl_vector_get(xvec, 1);
+  const double yc = gsl_vector_get(xvec, 2);
+  const double sx = gsl_vector_get(xvec, 3);
+  const double sy = gsl_vector_get(xvec, 4);
+  const double beta = gsl_vector_get(xvec, 5);
+  const size_t width = fitter.Width();
+  const size_t height = fitter.Height();
+  const int x_mid = width / 2;
+  const int y_mid = height / 2;
+  const double scale = 1.0 / fitter.ScaleFactor();
+
+  size_t data_index = 0;
+  for (int yi = 0; yi != int(height); ++yi) {
+    double y = yc + (yi - y_mid) * scale;
+    for (int xi = 0; xi != int(width); ++xi) {
+      double x = xc + (xi - x_mid) * scale;
+      double exp_term = GaussCentered(x, y, sx, sy, beta);
+      double dv = exp_term;
+      exp_term *= v;
+      double dx = (-beta * y / (sx * sy) - x / (sx * sx)) * exp_term;
+      double dy = (-beta * x / (sy * sx) - y / (sy * sy)) * exp_term;
+      double dsx =
+          (beta * x * y / (sx * sx * sy) + x * x / (sx * sx * sx)) * exp_term;
+      double dsy =
+          (beta * x * y / (sy * sy * sx) + y * y / (sy * sy * sy)) * exp_term;
+      double dbeta = x * y / (sx * sy) * exp_term;
+      double dfl = 1.0;
+      gsl_matrix_set(J, data_index, 0, dv);
+      gsl_matrix_set(J, data_index, 1, dx);
+      gsl_matrix_set(J, data_index, 2, dy);
+      gsl_matrix_set(J, data_index, 3, dsx);
+      gsl_matrix_set(J, data_index, 4, dsy);
+      gsl_matrix_set(J, data_index, 5, dbeta);
+      gsl_matrix_set(J, data_index, 6, dfl);
+      ++data_index;
+    }
+  }
+  return GSL_SUCCESS;
+}
+
+int FittingBothWithAmplitudeAndFloor(const gsl_vector* x, void* data,
+                                     gsl_vector* f, gsl_matrix* J) {
+  FittingWithAmplitudeAndFloor(x, data, f);
+  FittingDerivativeWithAmplitudeAndFloor(x, data, J);
+  return GSL_SUCCESS;
+}
+
+}  // namespace
+
+void GaussianFitter::Fit2DGaussianCentred(
+    const float* image, size_t width, size_t height, double beam_estimate,
+    double& beam_major, double& beam_minor, double& beam_phase_angle,
+    double box_scale_factor, bool verbose) {
+  size_t preferred_size = std::max<size_t>(
+      std::ceil(box_scale_factor), std::ceil(beam_estimate * box_scale_factor));
+  if (preferred_size % 2 != 0) ++preferred_size;
+  if (preferred_size < width || preferred_size < height) {
+    size_t n_iterations = 0;
+    bool box_was_large_enough;
+    do {
+      size_t box_width = std::min(preferred_size, width);
+      size_t box_height = std::min(preferred_size, height);
+      if (verbose) std::cout << "Fit initial value:" << beam_estimate << "\n";
+      Fit2DGaussianCentredInBox(image, width, height, beam_estimate, beam_major,
+                                beam_minor, beam_phase_angle, box_width,
+                                box_height, verbose);
+      if (verbose) {
+        std::cout << "Fit result:" << beam_major << " x " << beam_minor
+                  << " px, " << beam_phase_angle << " (box was " << box_width
+                  << " x " << box_height << ")\n";
+      }
+
+      box_was_large_enough =
+          (beam_major * box_scale_factor * 0.8 < box_width ||
+           box_width >= width) &&
+          (beam_major * box_scale_factor * 0.8 < box_height ||
+           box_height >= height);
+      if (!box_was_large_enough) {
+        preferred_size =
+            std::max<size_t>(std::ceil(box_scale_factor),
+                             std::ceil(beam_major * box_scale_factor));
+        if (preferred_size % 2 != 0) ++preferred_size;
+        beam_estimate = std::max(beam_major, beam_estimate);
+      }
+      ++n_iterations;
+    } while (!box_was_large_enough && n_iterations < 5);
+  } else {
+    if (verbose) std::cout << "Image is as large as the fitting box.\n";
+    SingleFit2DGaussianCentred(image, width, height, beam_estimate, beam_major,
+                               beam_minor, beam_phase_angle, verbose);
+  }
+}
+
+void GaussianFitter::Fit2DCircularGaussianCentred(const float* image,
+                                                  size_t width, size_t height,
+                                                  double& beam_size,
+                                                  double box_scale_factor) {
+  double initial_value = beam_size;
+  size_t preferred_size = std::max<size_t>(
+      std::ceil(box_scale_factor), std::ceil(beam_size * box_scale_factor));
+  if (preferred_size % 2 != 0) ++preferred_size;
+  if (preferred_size < width || preferred_size < height) {
+    size_t box_width = std::min(preferred_size, width);
+    size_t box_height = std::min(preferred_size, height);
+    size_t n_iterations = 0;
+    bool box_was_large_enough;
+    do {
+      Fit2DCircularGaussianCentredInBox(image, width, height, beam_size,
+                                        box_width, box_height);
+
+      box_was_large_enough = (beam_size * box_scale_factor * 0.8 < box_width ||
+                              width >= box_width) &&
+                             (beam_size * box_scale_factor * 0.8 < box_height ||
+                              height >= box_height);
+      if (!box_was_large_enough) {
+        preferred_size =
+            std::max<size_t>(std::ceil(box_scale_factor),
+                             std::ceil(beam_size * box_scale_factor));
+        if (preferred_size % 2 != 0) ++preferred_size;
+        beam_size = std::max(initial_value, beam_size);
+      }
+      ++n_iterations;
+    } while (!box_was_large_enough && n_iterations < 5);
+  } else {
+    SingleFit2DCircularGaussianCentred(image, width, height, beam_size);
+  }
+}
+
+void GaussianFitter::Fit2DGaussianFull(const float* image, size_t width,
+                                       size_t height, double& val,
+                                       double& pos_x, double& pos_y,
+                                       double& beam_major, double& beam_minor,
+                                       double& beam_phase_angle,
+                                       double* floor_level) {
+  size_t preferred_size = std::max<size_t>(10, std::ceil(beam_major * 10.0));
+  if (preferred_size % 2 != 0) ++preferred_size;
+  if (preferred_size < width || preferred_size < height) {
+    size_t x_start =
+        std::max<int>(0, int(std::round(pos_x)) - int(preferred_size) / 2);
+    size_t x_end =
+        std::min(width, size_t(std::round(pos_x)) + preferred_size / 2);
+    size_t y_start =
+        std::max<int>(0, int(std::round(pos_y)) - int(preferred_size) / 2);
+    size_t y_end =
+        std::min(height, size_t(std::round(pos_y)) + preferred_size / 2);
+    size_t n_iterations = 0;
+    bool box_was_large_enough;
+    do {
+      Fit2DGaussianWithAmplitudeInBox(
+          image, width, height, val, pos_x, pos_y, beam_major, beam_minor,
+          beam_phase_angle, floor_level, x_start, x_end, y_start, y_end);
+
+      size_t box_width = x_end - x_start;
+      size_t box_height = y_end - y_start;
+      box_was_large_enough =
+          (beam_major * 4.0 < box_width || width >= box_width) &&
+          (beam_major * 4.0 < box_height || height >= box_height);
+      if (!box_was_large_enough) {
+        preferred_size = std::max<size_t>(10, std::ceil(beam_major * 10.0));
+        if (preferred_size % 2 != 0) ++preferred_size;
+      }
+      ++n_iterations;
+    } while (!box_was_large_enough && n_iterations < 5);
+  } else {
+    Fit2DGaussianWithAmplitude(image, width, height, val, pos_x, pos_y,
+                               beam_major, beam_minor, beam_phase_angle,
+                               floor_level);
+  }
+}
+
+void GaussianFitter::Fit2DGaussianCentredInBox(
+    const float* image, size_t width, size_t height, double beam_estimate,
+    double& beam_major, double& beam_minor, double& beam_phase_angle,
+    size_t box_width, size_t box_height, bool verbose) {
+  const size_t x_start = (width - box_width) / 2;
+  const size_t y_start = (height - box_height) / 2;
+  aocommon::UVector<float> small_image(box_width * box_height);
+  for (size_t y = y_start; y != (height + box_height) / 2; ++y) {
+    std::copy_n(&image[y * width + x_start], box_width,
+                &small_image[(y - y_start) * box_width]);
+  }
+
+  SingleFit2DGaussianCentred(small_image.data(), box_width, box_height,
+                             beam_estimate, beam_major, beam_minor,
+                             beam_phase_angle, verbose);
+}
+
+void GaussianFitter::Fit2DCircularGaussianCentredInBox(
+    const float* image, size_t width, size_t height, double& beam_size,
+    size_t box_width, size_t box_height) {
+  const size_t x_start = (width - box_width) / 2;
+  const size_t y_start = (height - box_height) / 2;
+  aocommon::UVector<float> small_image(box_width * box_height);
+  for (size_t y = y_start; y != (height + box_height) / 2; ++y) {
+    std::copy_n(&image[y * width + x_start], box_width,
+                &small_image[(y - y_start) * box_width]);
+  }
+
+  SingleFit2DCircularGaussianCentred(small_image.data(), box_width, box_height,
+                                     beam_size);
+}
+
+void GaussianFitter::SingleFit2DGaussianCentred(
+    const float* image, size_t width, size_t height, double beam_estimate,
+    double& beam_major, double& beam_minor, double& beam_phase_angle,
+    bool verbose) {
+  width_ = width;
+  height_ = height;
+  image_ = image;
+  scale_factor_ = (width + height) / 2;
+
+  const gsl_multifit_fdfsolver_type* T = gsl_multifit_fdfsolver_lmsder;
+  gsl_multifit_fdfsolver* solver =
+      gsl_multifit_fdfsolver_alloc(T, width_ * height_, 3);
+
+  gsl_multifit_function_fdf fdf;
+  fdf.f = &FittingCentered;
+  fdf.df = &FittingDerivativeCentered;
+  fdf.fdf = &FittingBothCentered;
+  fdf.n = width_ * height_;
+  fdf.p = 3;
+  fdf.params = this;
+
+  // Using the FWHM formula for a Gaussian:
+  double initial_values_array[3] = {
+      beam_estimate / (scale_factor_ * double(kSigmaToBeam)),
+      beam_estimate / (scale_factor_ * double(kSigmaToBeam)), 0.0};
+  gsl_vector_view initial_values =
+      gsl_vector_view_array(initial_values_array, 3);
+  gsl_multifit_fdfsolver_set(solver, &fdf, &initial_values.vector);
+
+  int status;
+  size_t iter = 0;
+  do {
+    if (verbose) std::cout << "Iteration " << iter << ": ";
+    iter++;
+    status = gsl_multifit_fdfsolver_iterate(solver);
+
+    if (status) break;
+
+    status = gsl_multifit_test_delta(solver->dx, solver->x, 1.0e-7, 1.0e-7);
+
+  } while (status == GSL_CONTINUE && iter < 500);
+
+  double sx = gsl_vector_get(solver->x, 0), sy = gsl_vector_get(solver->x, 1),
+         beta = gsl_vector_get(solver->x, 2);
+
+  gsl_multifit_fdfsolver_free(solver);
+
+  ToAnglesAndFwhm(sx, sy, beta, beam_major, beam_minor, beam_phase_angle);
+  beam_major *= scale_factor_;
+  beam_minor *= scale_factor_;
+}
+
+void GaussianFitter::SingleFit2DCircularGaussianCentred(const float* image,
+                                                        size_t width,
+                                                        size_t height,
+                                                        double& beam_size) {
+  width_ = width;
+  height_ = height;
+  image_ = image;
+  scale_factor_ = (width + height) / 2;
+
+  const gsl_multifit_fdfsolver_type* T = gsl_multifit_fdfsolver_lmsder;
+  gsl_multifit_fdfsolver* solver =
+      gsl_multifit_fdfsolver_alloc(T, width_ * height_, 1);
+
+  gsl_multifit_function_fdf fdf;
+  fdf.f = &FittingCircularCentered;
+  fdf.df = &FittingDerivativeCircularCentered;
+  fdf.fdf = &FittingBothCircularCentered;
+  fdf.n = width_ * height_;
+  fdf.p = 1;
+  fdf.params = this;
+
+  // Using the FWHM formula for a Gaussian:
+  double initial_values_array[1] = {beam_size /
+                                    (scale_factor_ * double(kSigmaToBeam))};
+  gsl_vector_view initial_values =
+      gsl_vector_view_array(initial_values_array, 1);
+  gsl_multifit_fdfsolver_set(solver, &fdf, &initial_values.vector);
+
+  int status;
+  size_t iter = 0;
+  do {
+    iter++;
+    status = gsl_multifit_fdfsolver_iterate(solver);
+
+    if (status) break;
+
+    status = gsl_multifit_test_delta(solver->dx, solver->x, 1.0e-7, 1.0e-7);
+
+  } while (status == GSL_CONTINUE && iter < 500);
+
+  const double s = gsl_vector_get(solver->x, 0);
+  gsl_multifit_fdfsolver_free(solver);
+
+  beam_size = s * kSigmaToBeam * scale_factor_;
+}
+
+void GaussianFitter::Fit2DGaussianWithAmplitudeInBox(
+    const float* image, size_t width, size_t /*height*/, double& val,
+    double& pos_x, double& pos_y, double& beam_major, double& beam_minor,
+    double& beam_phase_angle, double* floor_level, size_t x_start, size_t x_end,
+    size_t y_start, size_t y_end) {
+  const size_t box_width = x_end - x_start;
+  const size_t box_height = y_end - y_start;
+  aocommon::UVector<float> small_image(box_width * box_height);
+  for (size_t y = y_start; y != y_end; ++y) {
+    std::copy_n(&image[y * width + x_start], box_width,
+                &small_image[(y - y_start) * box_width]);
+  }
+
+  pos_x -= x_start;
+  pos_y -= y_start;
+  Fit2DGaussianWithAmplitude(small_image.data(), box_width, box_height, val,
+                             pos_x, pos_y, beam_major, beam_minor,
+                             beam_phase_angle, floor_level);
+  pos_x += x_start;
+  pos_y += y_start;
+}
+
+/**
+ * Fits the position, size and amplitude of a Gaussian. If floor_level is not
+ * a nullptr, the floor (background level, or zero level) is fitted too.
+ */
+void GaussianFitter::Fit2DGaussianWithAmplitude(
+    const float* image, size_t width, size_t height, double& val, double& pos_x,
+    double& pos_y, double& beam_major, double& beam_minor,
+    double& beam_phase_angle, double* floor_level) {
+  width_ = width;
+  height_ = height;
+  image_ = image;
+  scale_factor_ = (width + height) / 2;
+
+  if (floor_level == nullptr) {
+    Fit2DGaussianWithAmplitude(val, pos_x, pos_y, beam_major, beam_minor,
+                               beam_phase_angle);
+  } else {
+    Fit2DGaussianWithAmplitudeWithFloor(val, pos_x, pos_y, beam_major,
+                                        beam_minor, beam_phase_angle,
+                                        *floor_level);
+  }
+}
+
+void GaussianFitter::Fit2DGaussianWithAmplitude(double& val, double& pos_x,
+                                                double& pos_y,
+                                                double& beam_major,
+                                                double& beam_minor,
+                                                double& beam_phase_angle) {
+  const gsl_multifit_fdfsolver_type* T = gsl_multifit_fdfsolver_lmsder;
+  gsl_multifit_fdfsolver* solver =
+      gsl_multifit_fdfsolver_alloc(T, width_ * height_, 6);
+
+  gsl_multifit_function_fdf fdf;
+  fdf.f = &FittingWithAmplitude;
+  fdf.df = &FittingDerivativeWithAmplitude;
+  fdf.fdf = &FittingBothWithAmplitude;
+  fdf.n = width_ * height_;
+  fdf.p = 6;
+  fdf.params = this;
+
+  // Using the FWHM formula for a Gaussian:
+  x_init_ = -(pos_x - width_ / 2) / scale_factor_;
+  y_init_ = -(pos_y - height_ / 2) / scale_factor_;
+  double initial_values_array[6] = {
+      val,
+      x_init_,
+      y_init_,
+      beam_major / (scale_factor_ * double(kSigmaToBeam)),
+      beam_major / (scale_factor_ * double(kSigmaToBeam)),
+      0.0};
+  gsl_vector_view initial_values =
+      gsl_vector_view_array(initial_values_array, 6);
+  gsl_multifit_fdfsolver_set(solver, &fdf, &initial_values.vector);
+
+  int status;
+  size_t iter = 0;
+  do {
+    iter++;
+    status = gsl_multifit_fdfsolver_iterate(solver);
+
+    if (status) break;
+
+    status = gsl_multifit_test_delta(solver->dx, solver->x, 1.0e-7, 1.0e-7);
+
+  } while (status == GSL_CONTINUE && iter < 500);
+
+  val = gsl_vector_get(solver->x, 0);
+  pos_x = -1.0 * gsl_vector_get(solver->x, 1) * scale_factor_ + width_ / 2;
+  pos_y = -1.0 * gsl_vector_get(solver->x, 2) * scale_factor_ + height_ / 2;
+  double sx = gsl_vector_get(solver->x, 3), sy = gsl_vector_get(solver->x, 4),
+         beta = gsl_vector_get(solver->x, 5);
+
+  gsl_multifit_fdfsolver_free(solver);
+
+  ToAnglesAndFwhm(sx, sy, beta, beam_major, beam_minor, beam_phase_angle);
+  beam_major *= scale_factor_;
+  beam_minor *= scale_factor_;
+}
+
+void GaussianFitter::Fit2DGaussianWithAmplitudeWithFloor(
+    double& val, double& pos_x, double& pos_y, double& beam_major,
+    double& beam_minor, double& beam_phase_angle, double& floor_level) {
+  const gsl_multifit_fdfsolver_type* T = gsl_multifit_fdfsolver_lmsder;
+  gsl_multifit_fdfsolver* solver =
+      gsl_multifit_fdfsolver_alloc(T, width_ * height_, 7);
+
+  gsl_multifit_function_fdf fdf;
+  fdf.f = &FittingWithAmplitudeAndFloor;
+  fdf.df = &FittingDerivativeWithAmplitudeAndFloor;
+  fdf.fdf = &FittingBothWithAmplitudeAndFloor;
+  fdf.n = width_ * height_;
+  fdf.p = 7;
+  fdf.params = this;
+
+  // Using the FWHM formula for a Gaussian:
+  x_init_ = -(pos_x - width_ / 2) / scale_factor_;
+  y_init_ = -(pos_y - height_ / 2) / scale_factor_;
+  double initial_values_array[7] = {
+      val,
+      x_init_,
+      y_init_,
+      beam_major / (scale_factor_ * double(kSigmaToBeam)),
+      beam_major / (scale_factor_ * double(kSigmaToBeam)),
+      0.0,
+      0.0};
+  gsl_vector_view initial_values =
+      gsl_vector_view_array(initial_values_array, 7);
+  gsl_multifit_fdfsolver_set(solver, &fdf, &initial_values.vector);
+
+  int status;
+  size_t iter = 0;
+  do {
+    iter++;
+    status = gsl_multifit_fdfsolver_iterate(solver);
+
+    if (status) break;
+
+    status = gsl_multifit_test_delta(solver->dx, solver->x, 1.0e-7, 1.0e-7);
+
+  } while (status == GSL_CONTINUE && iter < 500);
+
+  val = gsl_vector_get(solver->x, 0);
+  pos_x = -1.0 * gsl_vector_get(solver->x, 1) * scale_factor_ + width_ / 2;
+  pos_y = -1.0 * gsl_vector_get(solver->x, 2) * scale_factor_ + height_ / 2;
+  double sx = gsl_vector_get(solver->x, 3);
+  double sy = gsl_vector_get(solver->x, 4);
+  double beta = gsl_vector_get(solver->x, 5);
+  floor_level = gsl_vector_get(solver->x, 6);
+
+  gsl_multifit_fdfsolver_free(solver);
+
+  ToAnglesAndFwhm(sx, sy, beta, beam_major, beam_minor, beam_phase_angle);
+  beam_major *= scale_factor_;
+  beam_minor *= scale_factor_;
+}
+}  // namespace fitters
+}  // namespace schaapcommon
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fitters/nlplfitter.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/nlplfitter.cc
@@ -0,0 +1,450 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "nlplfitter.h"
+
+#include <cmath>
+#include <iostream>
+#include <limits>
+#include <stdexcept>
+
+#include <aocommon/uvector.h>
+
+#include <gsl/gsl_vector.h>
+#include <gsl/gsl_multifit_nlin.h>
+
+namespace schaapcommon {
+namespace fitters {
+
+class NLPLFitterData {
+ public:
+  using PointVec = aocommon::UVector<std::pair<double, double>>;
+  PointVec points;
+  size_t n_terms;
+  gsl_multifit_fdfsolver* solver;
+
+  static int Fitting(const gsl_vector* x_vector, void* data, gsl_vector* f) {
+    const NLPLFitterData& fitterData = *reinterpret_cast<NLPLFitterData*>(data);
+    const double exponent = gsl_vector_get(x_vector, 0);
+    const double factor = gsl_vector_get(x_vector, 1);
+
+    for (size_t i = 0; i != fitterData.points.size(); ++i) {
+      const double x = fitterData.points[i].first;
+      const double y = fitterData.points[i].second;
+
+      gsl_vector_set(f, i, factor * std::pow(x, exponent) - y);
+    }
+
+    return GSL_SUCCESS;
+  }
+
+  static int FittingDerivative(const gsl_vector* x_vector, void* data,
+                               gsl_matrix* j_matrix) {
+    const NLPLFitterData& fitterData = *reinterpret_cast<NLPLFitterData*>(data);
+    const double exponent = gsl_vector_get(x_vector, 0);
+    const double factor = gsl_vector_get(x_vector, 1);
+
+    for (size_t i = 0; i != fitterData.points.size(); ++i) {
+      const double x = fitterData.points[i].first;
+
+      const double x_to_the_e = std::pow(x, exponent);
+      const double dfd_exp = factor * std::log(x) * x_to_the_e;
+      const double dfd_fac = x_to_the_e;
+
+      gsl_matrix_set(j_matrix, i, 0, dfd_exp);
+      gsl_matrix_set(j_matrix, i, 1, dfd_fac);
+    }
+
+    return GSL_SUCCESS;
+  }
+
+  static int FittingBoth(const gsl_vector* x_vector, void* data, gsl_vector* f,
+                         gsl_matrix* j_matrix) {
+    Fitting(x_vector, data, f);
+    FittingDerivative(x_vector, data, j_matrix);
+    return GSL_SUCCESS;
+  }
+
+  static int FittingSecondOrder(const gsl_vector* x_vector, void* data,
+                                gsl_vector* f) {
+    const NLPLFitterData& fitterData = *reinterpret_cast<NLPLFitterData*>(data);
+    const double exponent = gsl_vector_get(x_vector, 0);
+    const double b = gsl_vector_get(x_vector, 1);
+    const double c = gsl_vector_get(x_vector, 2);
+
+    for (size_t i = 0; i != fitterData.points.size(); ++i) {
+      const double x = fitterData.points[i].first;
+      const double y = fitterData.points[i].second;
+
+      // f(x) = (bx + cx^2)^a
+      gsl_vector_set(f, i, pow(b * x + c * x * x, exponent) - y);
+    }
+
+    return GSL_SUCCESS;
+  }
+
+  static int FittingSecondOrderDerivative(const gsl_vector* x_vector,
+                                          void* data, gsl_matrix* j_matrix) {
+    const NLPLFitterData& fitterData = *reinterpret_cast<NLPLFitterData*>(data);
+    const double a = gsl_vector_get(x_vector, 0);
+    const double b = gsl_vector_get(x_vector, 1);
+    const double c = gsl_vector_get(x_vector, 2);
+
+    for (size_t i = 0; i != fitterData.points.size(); ++i) {
+      const double x = fitterData.points[i].first;
+
+      // f(x)    = (bx + cx^2)^a
+      // f(x)/da = ln(bx + cx^2) (bx + cx^2)^a
+      // f(x)/db =    ax (bx + cx^2)^(a-1)
+      // f(x)/dc =  ax^2 (bx + cx^2)^(a-1)
+      const double inner_term = b * x + c * x * x;
+      const double to_the_a = std::pow(inner_term, a);
+      const double dfd_exp = std::log(inner_term) * to_the_a;
+      const double to_the_a_minus_one = to_the_a / inner_term;
+      const double dfd_factor_b = a * x * to_the_a_minus_one;
+      const double dfd_factor_c = a * x * x * to_the_a_minus_one;
+
+      gsl_matrix_set(j_matrix, i, 0, dfd_exp);
+      gsl_matrix_set(j_matrix, i, 1, dfd_factor_b);
+      gsl_matrix_set(j_matrix, i, 2, dfd_factor_c);
+    }
+
+    return GSL_SUCCESS;
+  }
+
+  static int FittingSecondOrderBoth(const gsl_vector* x, void* data,
+                                    gsl_vector* f, gsl_matrix* j_matrix) {
+    FittingSecondOrder(x, data, f);
+    FittingSecondOrderDerivative(x, data, j_matrix);
+    return GSL_SUCCESS;
+  }
+
+  static int FittingMultiOrder(const gsl_vector* x_vector, void* data,
+                               gsl_vector* f) {
+    const NLPLFitterData& fitterData = *reinterpret_cast<NLPLFitterData*>(data);
+
+    for (size_t i = 0; i != fitterData.points.size(); ++i) {
+      const double x = fitterData.points[i].first;
+      const double y = fitterData.points[i].second;
+      const double lg = std::log10(x);
+
+      // Horner's method
+      double fity = 0.0;
+      for (size_t k = 0; k != fitterData.n_terms; ++k) {
+        const size_t j = fitterData.n_terms - k - 1;
+        const double a_j = gsl_vector_get(x_vector, j);
+        fity = a_j + fity * lg;
+      }
+      gsl_vector_set(f, i, std::pow(10.0, fity) - y);
+    }
+
+    return GSL_SUCCESS;
+  }
+
+  static int FittingMultiOrderDerivative(const gsl_vector* x_vector, void* data,
+                                         gsl_matrix* j_matrix) {
+    const NLPLFitterData& fitterData = *reinterpret_cast<NLPLFitterData*>(data);
+
+    for (size_t i = 0; i != fitterData.points.size(); ++i) {
+      const double x = fitterData.points[i].first;
+      const double lg = std::log10(x);
+
+      // Horner's method
+      double fity = 0.0;
+      for (size_t k = 0; k != fitterData.n_terms; ++k) {
+        const size_t j = fitterData.n_terms - k - 1;
+        const double a_j = gsl_vector_get(x_vector, j);
+        fity = a_j + fity * lg;
+      }
+      fity = std::pow(10.0, fity);
+      // dY/da_i = e^[ a_0...a_i-1,a_i+1...a_n] * (e^[a_i {log x}^i]) {log x}^i
+      gsl_matrix_set(j_matrix, i, 0, fity);
+
+      double lgPower = lg;
+      for (size_t j = 1; j != fitterData.n_terms; ++j) {
+        gsl_matrix_set(j_matrix, i, j, fity * lgPower);
+        lgPower *= lg;
+      }
+    }
+
+    return GSL_SUCCESS;
+  }
+
+  static int FittingMultiOrderBoth(const gsl_vector* x, void* data,
+                                   gsl_vector* f, gsl_matrix* j_matrix) {
+    FittingMultiOrder(x, data, f);
+    FittingMultiOrderDerivative(x, data, j_matrix);
+    return GSL_SUCCESS;
+  }
+};
+
+void NonLinearPowerLawFitter::Fit(NumT& exponent, NumT& factor) {
+  if (data_->points.size() >= 2) {
+    const gsl_multifit_fdfsolver_type* t = gsl_multifit_fdfsolver_lmsder;
+    data_->solver = gsl_multifit_fdfsolver_alloc(t, data_->points.size(), 2);
+
+    gsl_multifit_function_fdf fdf;
+    fdf.f = &NLPLFitterData::Fitting;
+    fdf.df = &NLPLFitterData::FittingDerivative;
+    fdf.fdf = &NLPLFitterData::FittingBoth;
+    fdf.n = data_->points.size();
+    fdf.p = 2;
+    fdf.params = data_.get();
+
+    double initial_values_array[2] = {exponent, factor};
+    gsl_vector_view initial_values =
+        gsl_vector_view_array(initial_values_array, 2);
+    gsl_multifit_fdfsolver_set(data_->solver, &fdf, &initial_values.vector);
+
+    int status;
+    size_t iter = 0;
+    do {
+      iter++;
+      status = gsl_multifit_fdfsolver_iterate(data_->solver);
+
+      if (status) break;
+
+      status = gsl_multifit_test_delta(data_->solver->dx, data_->solver->x,
+                                       1.0e-7, 1.0e-7);
+
+    } while (status == GSL_CONTINUE && iter < 500);
+
+    exponent = gsl_vector_get(data_->solver->x, 0);
+    factor = gsl_vector_get(data_->solver->x, 1);
+
+    gsl_multifit_fdfsolver_free(data_->solver);
+  } else {
+    exponent = 0.0;
+    factor = 0.0;
+    for (size_t i = 0; i != data_->points.size(); ++i) {
+      factor += data_->points[i].second;
+    }
+    factor /= NumT(data_->points.size());
+  }
+}
+
+void NonLinearPowerLawFitter::Fit(NumT& a, NumT& b, NumT& c) {
+  Fit(a, b);
+  b = pow(b, 1.0 / a);
+
+  if (data_->points.size() >= 3) {
+    const gsl_multifit_fdfsolver_type* t = gsl_multifit_fdfsolver_lmsder;
+    data_->solver = gsl_multifit_fdfsolver_alloc(t, data_->points.size(), 3);
+
+    gsl_multifit_function_fdf fdf;
+    fdf.f = &NLPLFitterData::FittingSecondOrder;
+    fdf.df = &NLPLFitterData::FittingSecondOrderDerivative;
+    fdf.fdf = &NLPLFitterData::FittingSecondOrderBoth;
+    fdf.n = data_->points.size();
+    fdf.p = 3;
+    fdf.params = data_.get();
+
+    double initial_values_array[3] = {a, b, c};
+    gsl_vector_view initial_values =
+        gsl_vector_view_array(initial_values_array, 3);
+    gsl_multifit_fdfsolver_set(data_->solver, &fdf, &initial_values.vector);
+
+    int status;
+    size_t iter = 0;
+    do {
+      iter++;
+      status = gsl_multifit_fdfsolver_iterate(data_->solver);
+
+      if (status) break;
+
+      status = gsl_multifit_test_delta(data_->solver->dx, data_->solver->x,
+                                       1.0e-7, 1.0e-7);
+
+    } while (status == GSL_CONTINUE && iter < 500);
+
+    a = gsl_vector_get(data_->solver->x, 0);
+    b = gsl_vector_get(data_->solver->x, 1);
+    c = gsl_vector_get(data_->solver->x, 2);
+
+    gsl_multifit_fdfsolver_free(data_->solver);
+  }
+}
+
+void NonLinearPowerLawFitter::FitImplementation(std::vector<NumT>& terms,
+                                                size_t n_terms) {
+  data_->n_terms = n_terms;
+  const gsl_multifit_fdfsolver_type* t = gsl_multifit_fdfsolver_lmsder;
+  data_->solver =
+      gsl_multifit_fdfsolver_alloc(t, data_->points.size(), n_terms);
+
+  gsl_multifit_function_fdf fdf;
+  fdf.f = &NLPLFitterData::FittingMultiOrder;
+  fdf.df = &NLPLFitterData::FittingMultiOrderDerivative;
+  fdf.fdf = &NLPLFitterData::FittingMultiOrderBoth;
+  fdf.n = data_->points.size();
+  fdf.p = n_terms;
+  fdf.params = data_.get();
+
+  std::vector<double> termsView(terms.begin(), terms.end());
+  gsl_vector_view initial_values =
+      gsl_vector_view_array(termsView.data(), n_terms);
+  gsl_multifit_fdfsolver_set(data_->solver, &fdf, &initial_values.vector);
+
+  int status;
+  size_t iter = 0;
+  do {
+    iter++;
+    status = gsl_multifit_fdfsolver_iterate(data_->solver);
+
+    if (status) break;
+
+    status = gsl_multifit_test_delta(data_->solver->dx, data_->solver->x,
+                                     1.0e-6, 1.0e-6);
+
+  } while (status == GSL_CONTINUE && iter < 5000);
+
+  if (status != GSL_SUCCESS) {
+    std::cout << "Warning: not converged! (niter=" << iter
+              << ", status=" << gsl_strerror(status) << ")\n";
+  }
+  for (size_t i = 0; i != n_terms; ++i) {
+    terms[i] = gsl_vector_get(data_->solver->x, i);
+  }
+
+  gsl_multifit_fdfsolver_free(data_->solver);
+}
+
+NonLinearPowerLawFitter::NonLinearPowerLawFitter()
+    : data_(new NLPLFitterData()) {}
+
+NonLinearPowerLawFitter::~NonLinearPowerLawFitter() = default;
+
+void NonLinearPowerLawFitter::AddDataPoint(NumT x, NumT y) {
+  data_->points.emplace_back(x, y);
+}
+
+void NonLinearPowerLawFitter::Fit(std::vector<NumT>& terms, size_t n_terms) {
+  terms.assign(n_terms, 0.0);
+
+  if (data_->points.size() < n_terms) n_terms = data_->points.size();
+
+  if (n_terms == 0) return;
+
+  NumT a = 1.0;
+  NumT b = 0.0;
+  Fit(a, b);
+  bool is_negative = b < 0.0;
+  if (is_negative) {
+    for (std::pair<double, double>& point : data_->points) {
+      point.second = -point.second;
+    }
+    terms[0] = -std::log10(-b);
+    a = -a;
+  } else {
+    terms[0] = std::log10(b);  // - a*log(NLPLFact);
+  }
+
+  if (b != 0.0) {
+    if (n_terms > 1) terms[1] = a;
+
+    FitImplementation(terms, n_terms);
+  }
+
+  if (is_negative) {
+    terms[0] = -std::pow(10.0, terms[0]);
+  } else {
+    terms[0] = std::pow(10.0, terms[0]);
+  }
+}
+
+void NonLinearPowerLawFitter::FitStable(std::vector<NumT>& terms,
+                                        size_t n_terms) {
+  terms.assign(n_terms, 0.0);
+  if (n_terms == 0) return;
+
+  NumT a = 1.0;
+  NumT b = 0.0;
+  Fit(a, b);
+
+  bool is_negative = b < 0.0;
+  if (is_negative) {
+    for (std::pair<double, double>& point : data_->points) {
+      point.second = -point.second;
+    }
+    terms[0] = -std::log10(-b);
+    a = -a;
+  } else {
+    terms[0] = std::log10(b);  // - a*log(NLPLFact);
+  }
+
+  if (b != 0.0) {
+    if (n_terms > 1) terms[1] = a;
+    size_t n_terms_estimated = 2;
+    while (n_terms_estimated < n_terms) {
+      ++n_terms_estimated;
+      FitImplementation(terms, n_terms_estimated);
+    }
+  }
+
+  if (is_negative) {
+    terms[0] = -std::pow(10.0, terms[0]);
+  } else {
+    terms[0] = std::pow(10.0, terms[0]);
+  }
+}
+
+void NonLinearPowerLawFitter::FastFit(NumT& exponent, NumT& factor) {
+  NumT sumxy = 0.0;
+  NumT sumx = 0.0;
+  NumT sumy = 0.0;
+  NumT sumxx = 0.0;
+  size_t n = 0;
+  bool require_non_linear = false;
+
+  for (const std::pair<double, double>& point : data_->points) {
+    const NumT x = point.first;
+    const NumT y = point.second;
+    if (y <= 0) {
+      require_non_linear = true;
+      break;
+    }
+    if (x > 0 && y > 0) {
+      const long double log_x = std::log(x);
+      const long double log_y = std::log(y);
+      sumxy += log_x * log_y;
+      sumx += log_x;
+      sumy += log_y;
+      sumxx += log_x * log_x;
+      ++n;
+    }
+  }
+  if (require_non_linear) {
+    exponent = 0.0;
+    factor = 1.0;
+    Fit(exponent, factor);
+  } else {
+    if (n == 0) {
+      exponent = std::numeric_limits<NumT>::quiet_NaN();
+      factor = std::numeric_limits<NumT>::quiet_NaN();
+    } else {
+      const NumT d = n * sumxx - sumx * sumx;
+      if (d == 0.0) {
+        exponent = 0.0;
+      } else {
+        exponent = (n * sumxy - sumx * sumy) / d;
+      }
+      factor = std::exp((sumy - exponent * sumx) / n);
+    }
+  }
+}
+
+NonLinearPowerLawFitter::NumT NonLinearPowerLawFitter::Evaluate(
+    NumT x, const std::vector<NumT>& terms, NumT reference_frequency_hz) {
+  if (terms.empty()) return 0.0;
+  NumT y = 0.0;
+  const NumT lg = std::log10(x / reference_frequency_hz);
+
+  for (size_t k = 0; k != terms.size() - 1; ++k) {
+    const size_t j = terms.size() - k - 1;
+    y = y * lg + terms[j];
+  }
+  return std::pow(10.0, y * lg) * terms[0];
+}
+
+}  // namespace fitters
+}  // namespace schaapcommon
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fitters/polynomialfitter.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/polynomialfitter.cc
@@ -0,0 +1,68 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "polynomialfitter.h"
+
+#include <stdexcept>
+
+#include <gsl/gsl_multifit.h>
+
+namespace schaapcommon {
+namespace fitters {
+
+void PolynomialFitter::Fit(std::vector<NumT>& terms, size_t nTerms) {
+  size_t n = data_points_.size();
+  terms.assign(nTerms, 0.0);
+
+  if (nTerms > n) {
+    nTerms = n;
+  }
+
+  gsl_multifit_linear_workspace* workspace =
+      gsl_multifit_linear_alloc(n, nTerms);
+
+  gsl_matrix* xData = gsl_matrix_alloc(n, nTerms);
+  gsl_matrix* cov = gsl_matrix_alloc(nTerms, nTerms);
+  gsl_vector* wData = gsl_vector_alloc(n);
+  gsl_vector* yData = gsl_vector_alloc(n);
+  gsl_vector* resultTerms = gsl_vector_alloc(nTerms);
+  double chisq;
+
+  for (size_t i = 0; i != n; ++i) {
+    NumT x = data_points_[i][0];
+    NumT y = data_points_[i][1];
+    NumT w = data_points_[i][2];
+
+    NumT f = 1.0;
+    gsl_matrix_set(xData, i, 0, f);
+    for (size_t j = 1; j != nTerms; ++j) {
+      f *= x;  // f = x^j
+      gsl_matrix_set(xData, i, j, f);
+    }
+    gsl_vector_set(yData, i, y);
+    gsl_vector_set(wData, i, w);
+  }
+
+  int result = gsl_multifit_wlinear(xData, wData, yData, resultTerms, cov,
+                                    &chisq, workspace);
+
+  for (size_t j = 0; j != nTerms; ++j) {
+    terms[j] = gsl_vector_get(resultTerms, j);
+  }
+
+  gsl_vector_free(resultTerms);
+  gsl_vector_free(yData);
+  gsl_vector_free(wData);
+
+  gsl_matrix_free(cov);
+  gsl_matrix_free(xData);
+
+  gsl_multifit_linear_free(workspace);
+
+  if (result) {
+    throw std::runtime_error("Polynomial fit failed");
+  }
+}
+
+}  // namespace fitters
+}  // namespace schaapcommon
Index: wsclean/external/schaapcommon/src/fitters/spectralfitter.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/spectralfitter.cc
@@ -0,0 +1,154 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "spectralfitter.h"
+
+#include <limits>
+
+#include "polynomialfitter.h"
+#include "nlplfitter.h"
+
+using aocommon::Image;
+
+namespace schaapcommon {
+namespace fitters {
+
+namespace {
+constexpr double kDefaultReferenceFrequency = 150.0e6;
+}
+
+void SpectralFitter::SetFrequencies(const double* frequencies,
+                                    const NumT* weights, size_t n) {
+  frequencies_.assign(frequencies, frequencies + n);
+  weights_.assign(weights, weights + n);
+  NumT weight_sum = 0.0;
+  reference_frequency_ = 0.0;
+  for (size_t i = 0; i != n; ++i) {
+    reference_frequency_ += frequencies_[i] * weights_[i];
+    weight_sum += weights_[i];
+  }
+  if (weight_sum > 0.0) {
+    reference_frequency_ /= weight_sum;
+  } else {
+    reference_frequency_ = kDefaultReferenceFrequency;
+  }
+}
+
+void SpectralFitter::Fit(std::vector<NumT>& terms, const NumT* values, size_t x,
+                         size_t y) const {
+  if (IsForced()) {
+    ForcedFit(terms, values, x, y);
+  } else {
+    switch (mode_) {
+      default:
+      case SpectralFittingMode::NoFitting:
+        break;
+
+      case SpectralFittingMode::Polynomial: {
+        PolynomialFitter fitter;
+        const double reference = ReferenceFrequency();
+        for (size_t i = 0; i != frequencies_.size(); ++i) {
+          if (weights_[i] > 0.0) {
+            fitter.AddDataPoint(frequencies_[i] / reference - 1.0, values[i],
+                                weights_[i]);
+          }
+        }
+
+        fitter.Fit(terms, n_terms_);
+      } break;
+
+      case SpectralFittingMode::LogPolynomial: {
+        NonLinearPowerLawFitter fitter;
+        const double reference = ReferenceFrequency();
+        for (size_t i = 0; i != frequencies_.size(); ++i) {
+          if (weights_[i] > 0.0) {
+            fitter.AddDataPoint(frequencies_[i] / reference, values[i]);
+          }
+        }
+
+        fitter.Fit(terms, n_terms_);
+      } break;
+    }
+  }
+}
+
+void SpectralFitter::ForcedFit(std::vector<NumT>& terms,
+                               const SpectralFitter::NumT* values, size_t x,
+                               size_t y) const {
+  terms.resize(n_terms_);
+  // We need to find alpha such that
+  // y[i] = A f(x[i], terms), with f the shape.
+  // The least-squares fit is:
+  // A = sum (y[i] w[i] f[i]) / sum (w[i] f[i]^2)
+  // However, it turns out that finding the true least-squares solution for A
+  // leads to unstable cleaning. This is because a LS constrained flux might
+  // integrate to zero. If it does, the peak finding that uses integrated
+  // values will again find the same peak (over and over...). Therefore,
+  // we now use the linear average to estimate the flux:
+  // A = sum (y[i] w[i]) / sum (w[i] f[i])
+  // This is what is calculated below.
+  terms[0] = 1.0;
+  for (size_t term = 1; term != n_terms_; ++term) {
+    const Image& term_image = forced_terms_[term - 1];
+    terms[term] = term_image[x + y * term_image.Width()];
+  }
+  float numerator = 0.0;
+  float divisor = 0.0;
+  for (size_t i = 0; i != frequencies_.size(); ++i) {
+    const float w = weights_[i];
+    const float f = NonLinearPowerLawFitter::Evaluate(frequencies_[i], terms,
+                                                      ReferenceFrequency());
+    if (w > 0.0) {
+      numerator += w * values[i];
+      divisor += w * f;
+    }
+  }
+  terms[0] = numerator / divisor;
+}
+
+void SpectralFitter::Evaluate(NumT* values,
+                              const std::vector<NumT>& terms) const {
+  switch (mode_) {
+    default:
+    case SpectralFittingMode::NoFitting:
+      break;
+
+    case SpectralFittingMode::Polynomial: {
+      const double reference = ReferenceFrequency();
+      for (size_t i = 0; i != frequencies_.size(); ++i) {
+        values[i] = PolynomialFitter::Evaluate(
+            frequencies_[i] / reference - 1.0, terms);
+      }
+    } break;
+
+    case SpectralFittingMode::LogPolynomial: {
+      const double reference = ReferenceFrequency();
+      for (size_t i = 0; i != frequencies_.size(); ++i) {
+        values[i] = NonLinearPowerLawFitter::Evaluate(frequencies_[i], terms,
+                                                      reference);
+      }
+    } break;
+  }
+}
+
+SpectralFitter::NumT SpectralFitter::Evaluate(const std::vector<NumT>& terms,
+                                              double frequency) const {
+  switch (mode_) {
+    default:
+    case SpectralFittingMode::NoFitting:
+      throw std::runtime_error(
+          "Something is inconsistent: can't evaluate terms at frequency "
+          "without fitting");
+
+    case SpectralFittingMode::Polynomial:
+      return PolynomialFitter::Evaluate(frequency / ReferenceFrequency() - 1.0,
+                                        terms);
+
+    case SpectralFittingMode::LogPolynomial:
+      return NonLinearPowerLawFitter::Evaluate(frequency, terms,
+                                               ReferenceFrequency());
+  }
+}
+
+}  // namespace fitters
+}  // namespace schaapcommon
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fitters/test/CMakeLists.txt
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/test/CMakeLists.txt
@@ -0,0 +1,7 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+include(${SCHAAPCOMMON_SOURCE_DIR}/cmake/unittest.cmake)
+
+add_unittest(fitters runtests.cc tgaussianfitter.cc tnlplfitter.cc
+             tpolynomialfitter.cc)
Index: wsclean/external/schaapcommon/src/fitters/test/runtests.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/test/runtests.cc
@@ -0,0 +1,6 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#define BOOST_TEST_MODULE schaapcommon_fitters
+
+#include <boost/test/unit_test.hpp>
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/fitters/test/tgaussianfitter.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/test/tgaussianfitter.cc
@@ -0,0 +1,118 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include <boost/test/unit_test.hpp>
+
+#include "gaussianfitter.h"
+
+#include <aocommon/image.h>
+
+#include "../../../include/schaapcommon/fft/convolution.h"
+#include "../../../include/schaapcommon/fft/restoreimage.h"
+
+namespace {
+constexpr size_t kThreadCount = 2;
+constexpr size_t kWidth = 64;
+constexpr size_t kHeight = 64;
+constexpr long double kPixelSize = 1 /*amin*/ * (M_PI / 180.0 / 60.0);
+}  // namespace
+
+BOOST_AUTO_TEST_SUITE(gaussian_fitter)
+
+BOOST_AUTO_TEST_CASE(fit) {
+  for (size_t beam_phase_angle_index = 0; beam_phase_angle_index != 10;
+       ++beam_phase_angle_index) {
+    const size_t width = 512, height = 512;
+    aocommon::Image model(width, height, 0.0);
+    aocommon::Image restored(width, height, 0.0);
+    model[((height / 2) * width) + (width / 2)] = 1.0;
+    const long double kPixelSize = 1.0L /*amin*/ * (M_PI / 180.0 / 60.0);
+    const long double beam_major = 20.0L * kPixelSize;
+    const long double beam_minor = 5.0L * kPixelSize;
+    const long double beam_phase_angle = beam_phase_angle_index * M_PI / 10.0;
+
+    schaapcommon::fft::MakeFftwfPlannerThreadSafe();
+    schaapcommon::fft::RestoreImage(
+        restored.Data(), model.Data(), width, height, beam_major, beam_minor,
+        beam_phase_angle, kPixelSize, kPixelSize, kThreadCount);
+
+    schaapcommon::fitters::GaussianFitter fitter;
+    // Check that Fit2DGaussianCentred updates these variables.
+    double fit_major = 0.0;  // Should become 20.0.
+    double fit_minor = 0.0;  // Should become 5.0.
+    double fit_phase_angle =
+        -1.0;  // Should become beam_phase_angle, which can be 0.0.
+    fitter.Fit2DGaussianCentred(restored.Data(), width, height, 5.0, fit_major,
+                                fit_minor, fit_phase_angle, 10.0, false);
+    fit_phase_angle = std::fmod((fit_phase_angle + 2.0 * M_PI), M_PI);
+
+    BOOST_CHECK_CLOSE_FRACTION(fit_major, 20.0, 1.0e-3);
+    BOOST_CHECK_CLOSE_FRACTION(fit_minor, 5.0, 1.0e-3);
+    BOOST_CHECK_CLOSE_FRACTION(fit_phase_angle, beam_phase_angle, 1.0e-3);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(fit_circular) {
+  aocommon::Image model(kWidth, kHeight, 0.0);
+  aocommon::Image restored(kWidth, kHeight, 0.0);
+
+  model[((kHeight / 2) * kWidth) + (kWidth / 2)] = 1.0;
+
+  const long double beam_major = 4.0L * kPixelSize;
+  const long double beam_minor = 4.0L * kPixelSize;
+  const long double beam_phase_angle = 0.0;
+  const long double estimated_beam_pixel = 1.0;  // this is on purpose way off
+  schaapcommon::fft::MakeFftwfPlannerThreadSafe();
+  schaapcommon::fft::RestoreImage(
+      restored.Data(), model.Data(), kWidth, kHeight, beam_major, beam_minor,
+      beam_phase_angle, kPixelSize, kPixelSize, kThreadCount);
+
+  schaapcommon::fitters::GaussianFitter fitter;
+  // Check that Fit2DGaussianCentred updates these variables.
+  double fit_major = 0.0;         // Should become 4.0.
+  double fit_minor = 0.0;         // Should become 4.0.
+  double fit_phase_angle = -1.0;  // Should become beam_phase_angle (0.0).
+  fitter.Fit2DGaussianCentred(
+      restored.Data(), restored.Width(), restored.Height(),
+      estimated_beam_pixel, fit_major, fit_minor, fit_phase_angle, 10.0, false);
+
+  BOOST_CHECK_CLOSE_FRACTION(fit_major, 4.0, 1.0e-4);
+  BOOST_CHECK_CLOSE_FRACTION(fit_minor, 4.0, 1.0e-4);
+  BOOST_CHECK_SMALL(
+      std::abs(fit_phase_angle - static_cast<double>(beam_phase_angle)),
+      1.0e-4);
+}
+
+BOOST_AUTO_TEST_CASE(fit_small_beam) {
+  aocommon::Image model(kWidth, kHeight, 0.0);
+  aocommon::Image restored(kWidth, kHeight, 0.0);
+
+  model[((kHeight / 2) * kWidth) + (kWidth / 2)] = 1.0;
+
+  const long double beam_major = 4.0L * kPixelSize;
+  const long double beam_minor = 0.5L * kPixelSize;
+  const long double beam_phase_angle = 0.0;
+  const long double estimated_beam_pixel = 1.0;  // this is on purpose way off
+
+  schaapcommon::fft::MakeFftwfPlannerThreadSafe();
+  schaapcommon::fft::RestoreImage(
+      restored.Data(), model.Data(), kWidth, kHeight, beam_major, beam_minor,
+      beam_phase_angle, kPixelSize, kPixelSize, kThreadCount);
+
+  schaapcommon::fitters::GaussianFitter fitter;
+  // Check that Fit2DGaussianCentred updates these variables.
+  double fit_major = 0.0;         // Should become 4.0.
+  double fit_minor = 0.0;         // Should become 0.5.
+  double fit_phase_angle = -1.0;  // Should become beam_phase_angle (0.0).
+  fitter.Fit2DGaussianCentred(
+      restored.Data(), restored.Width(), restored.Height(),
+      estimated_beam_pixel, fit_major, fit_minor, fit_phase_angle, 10.0, false);
+
+  BOOST_CHECK_CLOSE_FRACTION(fit_major, 4.0, 1.0e-4);
+  BOOST_CHECK_CLOSE_FRACTION(fit_minor, 0.5, 1.0e-4);
+  BOOST_CHECK_SMALL(
+      std::abs(fit_phase_angle - static_cast<double>(beam_phase_angle)),
+      1.0e-4);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: wsclean/external/schaapcommon/src/fitters/test/tnlplfitter.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/test/tnlplfitter.cc
@@ -0,0 +1,98 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "nlplfitter.h"
+
+#include <aocommon/uvector.h>
+
+#include <boost/test/unit_test.hpp>
+
+using schaapcommon::fitters::NonLinearPowerLawFitter;
+
+BOOST_AUTO_TEST_SUITE(nlplfitter)
+
+BOOST_AUTO_TEST_CASE(first_order) {
+  const double x_factor = 1.0e1;
+
+  NonLinearPowerLawFitter fitter;
+  std::vector<float> terms{1.0, -0.7};
+
+  for (size_t x = 1; x != 10; ++x) {
+    float y = NonLinearPowerLawFitter::Evaluate(x * x_factor, terms);
+    fitter.AddDataPoint(x * x_factor, y);
+  }
+
+  float e = 0.0;
+  float factor = 0.0;
+  fitter.Fit(e, factor);
+  BOOST_CHECK_SMALL(std::fabs(1.0 - factor), 1.0e-6);
+  BOOST_CHECK_SMALL(std::fabs(-0.7 - e), 1.0e-6);
+}
+
+BOOST_AUTO_TEST_CASE(second_order_zero) {
+  const float x_factor = 1.0e1;
+
+  NonLinearPowerLawFitter fitter;
+  std::vector<float> terms{1.0, -0.7};
+
+  for (size_t x = 1; x != 10; ++x) {
+    float y = NonLinearPowerLawFitter::Evaluate(x * x_factor, terms);
+    fitter.AddDataPoint(x * x_factor, y);
+  }
+  std::vector<float> fitted;
+  fitter.Fit(fitted, 3);
+  BOOST_CHECK_SMALL(std::fabs(1.0f - fitted[0]), 1.0e-6f);
+  BOOST_CHECK_SMALL(std::fabs(-0.7f - fitted[1]), 1.0e-6f);
+  BOOST_CHECK_SMALL(std::fabs(0.0f - fitted[2]), 1.0e-6f);
+}
+
+BOOST_AUTO_TEST_CASE(first_order_stability) {
+  const float x_factor = 1.0e1;
+
+  NonLinearPowerLawFitter fitter;
+  std::vector<float> terms{1.0, -0.7, -0.01};
+  for (size_t x = 1; x != 10; ++x) {
+    float y = NonLinearPowerLawFitter::Evaluate(x * x_factor, terms);
+    fitter.AddDataPoint(x * x_factor, y);
+  }
+  float e = 0.0;
+  float factor = 0.0;
+  fitter.Fit(e, factor);
+  BOOST_CHECK_SMALL(std::fabs(terms[0] - factor), 0.1f);
+  BOOST_CHECK_SMALL(std::fabs(terms[1] - e), 0.1f);
+}
+
+BOOST_AUTO_TEST_CASE(second_order_nonzero) {
+  const float x_factor = 1.0e1;
+
+  NonLinearPowerLawFitter fitter;
+  std::vector<float> terms{1.0, -0.7, -0.01};
+  for (size_t x = 1; x != 10; ++x) {
+    float y = NonLinearPowerLawFitter::Evaluate(x * x_factor, terms);
+    fitter.AddDataPoint(x * x_factor, y);
+  }
+  std::vector<float> fitted;
+  fitter.Fit(fitted, 3);
+  BOOST_CHECK_SMALL(std::fabs(terms[0] - fitted[0]), 1.0e-3f);
+  BOOST_CHECK_SMALL(std::fabs(terms[1] - fitted[1]), 1.0e-3f);
+  BOOST_CHECK_SMALL(std::fabs(terms[2] - fitted[2]), 1.0e-3f);
+}
+
+BOOST_AUTO_TEST_CASE(third_order) {
+  const float x_factor = 1.0e1;
+
+  NonLinearPowerLawFitter fitter;
+  std::vector<float> terms{1.0, -0.7, -0.01, 0.05};
+  for (size_t x = 1; x != 10; ++x) {
+    float y = NonLinearPowerLawFitter::Evaluate(x * x_factor, terms);
+    fitter.AddDataPoint(x * x_factor, y);
+  }
+  std::vector<float> fitted;
+  fitter.Fit(fitted, 4);
+  BOOST_CHECK_SMALL(std::fabs(terms[0] - fitted[0]), 1.0e-2f);
+  BOOST_CHECK_SMALL(std::fabs(terms[1] - fitted[1]), 1.0e-2f);
+  BOOST_CHECK_SMALL(std::fabs(terms[2] - fitted[2]), 1.0e-2f);
+  BOOST_CHECK_SMALL(std::fabs(terms[3] - fitted[3]), 1.0e-2f);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: wsclean/external/schaapcommon/src/fitters/test/tpolynomialfitter.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/fitters/test/tpolynomialfitter.cc
@@ -0,0 +1,54 @@
+// Copyright (C) 2022 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "polynomialfitter.h"
+
+#include <boost/test/unit_test.hpp>
+#include <boost/test/tools/floating_point_comparison.hpp>
+
+using schaapcommon::fitters::PolynomialFitter;
+
+BOOST_AUTO_TEST_SUITE(polynomial_fitter)
+
+BOOST_AUTO_TEST_CASE(fit) {
+  PolynomialFitter fitter;
+  std::vector<float> terms;
+  fitter.AddDataPoint(0.0, 0.0, 1.0);
+  fitter.AddDataPoint(1.0, 0.0, 1.0);
+  fitter.AddDataPoint(2.0, 1.0, 1.0);
+  fitter.AddDataPoint(3.0, 2.0, 1.0);
+  fitter.Fit(terms, 2);
+
+  BOOST_CHECK_CLOSE_FRACTION(terms[0], -0.3, 1.0e-3);
+  BOOST_CHECK_CLOSE_FRACTION(terms[1], 0.7, 1.0e-3);
+}
+
+BOOST_AUTO_TEST_CASE(fit_weighted) {
+  PolynomialFitter fitter;
+  std::vector<float> terms;
+  fitter.AddDataPoint(0.0, 0.0, 1.5);
+  fitter.AddDataPoint(1.0, 0.0, 1.5);
+  fitter.AddDataPoint(2.0, 1.0, 0.5);
+  fitter.AddDataPoint(3.0, 1.0, 0.5);
+  fitter.Fit(terms, 1);
+
+  BOOST_CHECK_CLOSE_FRACTION(terms[0], 0.25, 1.0e-3);
+}
+
+BOOST_AUTO_TEST_CASE(evaluate) {
+  PolynomialFitter fitter;
+  std::vector<float> terms;
+  terms.push_back(-0.3);
+  terms.push_back(0.7);
+
+  BOOST_CHECK_CLOSE_FRACTION(PolynomialFitter::Evaluate(0.0, terms), -0.3,
+                             1.0e-3);
+  BOOST_CHECK_CLOSE_FRACTION(PolynomialFitter::Evaluate(1.0, terms), 0.4,
+                             1.0e-3);
+  BOOST_CHECK_CLOSE_FRACTION(PolynomialFitter::Evaluate(2.0, terms), 1.1,
+                             1.0e-3);
+  BOOST_CHECK_CLOSE_FRACTION(PolynomialFitter::Evaluate(3.0, terms), 1.8,
+                             1.0e-3);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: wsclean/external/schaapcommon/src/h5parm/CMakeLists.txt
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/CMakeLists.txt
@@ -0,0 +1,31 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+get_filename_component(MODULE ${CMAKE_CURRENT_SOURCE_DIR} NAME)
+
+set(PUBLIC_HEADER_DIR ${SCHAAPCOMMON_SOURCE_DIR}/include/schaapcommon/${MODULE})
+
+set(PUBLIC_HEADERS
+    ${PUBLIC_HEADER_DIR}/h5parm.h ${PUBLIC_HEADER_DIR}/jonesparameters.h
+    ${PUBLIC_HEADER_DIR}/soltab.h)
+
+target_sources(
+  ${SCHAAPCOMMON_PROJECT_NAME}
+  PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/h5parm.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/jonesparameters.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/soltab.cc
+          ${CMAKE_CURRENT_SOURCE_DIR}/gridinterpolate.cc)
+
+# Simplifies including the public headers.
+target_include_directories(${SCHAAPCOMMON_PROJECT_NAME}
+                           PRIVATE "$<BUILD_INTERFACE:${PUBLIC_HEADER_DIR}>")
+
+# Install headers and add test directory when built as stand-alone.
+if(SCHAAPCOMMON_MASTER_PROJECT)
+  install(FILES ${PUBLIC_HEADERS}
+          DESTINATION "include/${CMAKE_PROJECT_NAME}/${MODULE}")
+
+  if(BUILD_TESTING)
+    add_subdirectory(test)
+  endif()
+endif()
Index: wsclean/external/schaapcommon/src/h5parm/gridinterpolate.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/gridinterpolate.cc
@@ -0,0 +1,150 @@
+// gridinterpolate.cc: Interpolate data from regular 2d grid to another
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "gridinterpolate.h"
+
+#include <iostream>
+#include <vector>
+#include <stdexcept>
+
+// using namespace std;
+
+namespace schaapcommon {
+namespace h5parm {
+void GetAxisIndices(const std::vector<double>& ax_src,
+                    const std::vector<double>& ax_tgt,
+                    std::vector<size_t>& indices, bool nearest) {
+  indices.resize(ax_tgt.size());
+  if (ax_tgt.empty()) {
+    return;
+  }
+  if (ax_src.empty()) throw std::invalid_argument("ax_src is empty");
+
+  double lowmatch, highmatch;
+
+  auto src_val = ax_src.cbegin();
+  auto tgt_val = ax_tgt.cbegin();
+  auto index_val = indices.begin();
+
+  while (tgt_val != ax_tgt.cend()) {
+    while (src_val != ax_src.cend() && *src_val < *tgt_val) {
+      src_val++;
+    }
+    if (src_val == ax_src.cbegin()) {
+      *index_val = src_val - ax_src.cbegin();
+    } else if (src_val == ax_src.cend()) {
+      *index_val = src_val - ax_src.cbegin() - 1;
+    } else {
+      if (nearest) {
+        lowmatch = *(src_val - 1);
+        highmatch = *src_val;
+
+        if (highmatch - *tgt_val < *tgt_val - lowmatch) {
+          *index_val = src_val - ax_src.cbegin();
+        } else {
+          *index_val = src_val - ax_src.cbegin() - 1;
+        }
+      } else {
+        *index_val = src_val - ax_src.cbegin() - 1;
+      }
+    }
+    tgt_val++;
+    index_val++;
+  }
+}
+
+std::vector<double> GridNearestNeighbor(const std::vector<double>& x_src,
+                                        const std::vector<double>& y_src,
+                                        const std::vector<double>& x_tgt,
+                                        const std::vector<double>& y_tgt,
+                                        const std::vector<double>& vals_src,
+                                        MemoryLayout mem_layout, bool nearest) {
+  if (mem_layout != MemoryLayout::kRowMajor && !nearest && y_src.size() > 1) {
+    // If y_src.size() == 1, no difference between row/column major lay-out
+    throw std::runtime_error(
+        "Swapping the memory lay-out not possible for bilinear interpolations");
+  }
+
+  std::vector<size_t> x_indices;
+  std::vector<size_t> y_indices;
+  GetAxisIndices(x_src, x_tgt, x_indices, nearest);
+  GetAxisIndices(y_src, y_tgt, y_indices, nearest);
+
+  const size_t nx = x_tgt.size();
+  const size_t ny = y_tgt.size();
+  const size_t ny_src = y_src.size();
+  const size_t nx_src = x_src.size();
+  std::vector<double> vals_tgt(nx * ny);
+
+  if (nearest) {
+    if (mem_layout == MemoryLayout::kRowMajor) {
+      // Input vector is indexed as row_major 2D matrix - y changing fastest
+      for (size_t i = 0; i < nx; ++i) {
+        for (size_t j = 0; j < ny; ++j) {
+          vals_tgt[i * ny + j] = vals_src[x_indices[i] * ny_src + y_indices[j]];
+        }
+      }
+    } else {
+      // Input vector is indexed as col major 2D matrix - x changing fastest
+      for (size_t i = 0; i < nx; ++i) {
+        for (size_t j = 0; j < ny; ++j) {
+          vals_tgt[i * ny + j] = vals_src[y_indices[j] * nx_src + x_indices[i]];
+        }
+      }
+    }
+  } else {
+    for (size_t i = 0; i < nx; ++i) {
+      for (size_t j = 0; j < ny; ++j) {
+        size_t y0_idx, y1_idx;
+        bool interpolate_y = true;
+        if (y_tgt[j] <= y_src.front()) {
+          y0_idx = 0;
+          y1_idx = 0;
+          interpolate_y = false;
+        } else if (y_tgt[j] >= y_src.back()) {
+          y0_idx = y_src.size() - 1;
+          y1_idx = y_src.size() - 1;
+          interpolate_y = false;
+        } else {
+          y0_idx = y_indices[j];
+          y1_idx = y_indices[j] + 1;
+        }
+
+        double f_y0, f_y1;
+        if (x_tgt[i] <= x_src.front()) {
+          f_y0 = vals_src[y0_idx];
+          f_y1 = vals_src[y1_idx];
+        } else if (x_tgt[i] >= x_src.back()) {
+          f_y0 = vals_src[(x_src.size() - 1) * ny_src + y0_idx];
+          f_y1 = vals_src[(x_src.size() - 1) * ny_src + y1_idx];
+        } else {
+          size_t x0_idx = x_indices[i];
+          double x0 = x_src[x0_idx];
+          double x1 = x_src[x0_idx + 1];
+          double x = x_tgt[i];
+          f_y0 = vals_src[x0_idx * ny_src + y0_idx] +
+                 (x - x0) / (x1 - x0) *
+                     (vals_src[(x0_idx + 1) * ny_src + y0_idx] -
+                      vals_src[x0_idx * ny_src + y0_idx]);
+          f_y1 = vals_src[x0_idx * ny_src + y1_idx] +
+                 (x - x0) / (x1 - x0) *
+                     (vals_src[(x0_idx + 1) * ny_src + y1_idx] -
+                      vals_src[x0_idx * ny_src + y1_idx]);
+        }
+        if (interpolate_y) {
+          double y0 = y_src[y0_idx];
+          double y1 = y_src[y0_idx + 1];
+          double y = y_tgt[j];
+          vals_tgt[i * ny + j] = f_y0 + (y - y0) / (y1 - y0) * (f_y1 - f_y0);
+        } else {
+          vals_tgt[i * ny + j] = f_y0;
+        }
+      }
+    }
+  }
+
+  return vals_tgt;
+}
+}  // namespace h5parm
+}  // namespace schaapcommon
Index: wsclean/external/schaapcommon/src/h5parm/gridinterpolate.h
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/gridinterpolate.h
@@ -0,0 +1,62 @@
+// gridinterpolate.h: Interpolate data from regular 2d grid to another
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+/// @file
+/// @brief Interpolate data from regular 2d grid to another
+/// @author Tammo Jan Dijkema
+
+#ifndef SCHAAPCOMMON_H5PARM_GRIDINTERPOLATE_H_
+#define SCHAAPCOMMON_H5PARM_GRIDINTERPOLATE_H_
+
+#include <vector>
+#include <stdexcept>
+
+namespace schaapcommon {
+namespace h5parm {
+
+enum class MemoryLayout { kRowMajor, kColumnMajor };
+
+/**
+ * Get the nearest-neighbor indices
+ * \param ax_src[in] Vector with points where the data is defined.
+ *                   Should be increasing.
+ * \param ax_tgt[in] Vector with the points at which the values are
+ *                   needed.  Should be increasing.
+ * \param[out] indices Vector (same length as ax_tgt) with for each number
+ *                     in ax_src, the index of the nearest point in ax_src.
+ * \param[in] nearest Get the nearest point. If false, gets the largest
+ *                    point that is smaller.
+ */
+void GetAxisIndices(const std::vector<double>& ax_src,
+                    const std::vector<double>& ax_tgt,
+                    std::vector<size_t>& indices, bool nearest = true);
+
+/**
+ * Regrid 2d-gridded data onto another 2d grid. In the return vector,
+ * y changes fastest, so that the returned vector can be interpreted as
+ * a row-major 2D matrix.
+ *
+ * \param[in] x_src x-axis on which the data is defined
+ * \param[in] y_src y-axis on which the data is defined
+ * \param[in] x_tgt x-axis on which the data will be evaluated
+ * \param[in] y_tgt y-axis on which the data will be evaluated
+ * \param[in] vals_src original data as a flattened 2D array. The ordering
+ * \param[in] is_row_major interpret the input values as a row major 2D array.
+ * If false, the vector of input values is interpreted in column major order
+ * \param[in] nearest perform nearest interpolation (true), or bilinear
+ * interpolation (false). Defaults to nearest = true
+ * \return regridded data, y-axis varies fastest
+ */
+std::vector<double> GridNearestNeighbor(const std::vector<double>& x_src,
+                                        const std::vector<double>& y_src,
+                                        const std::vector<double>& x_tgt,
+                                        const std::vector<double>& y_tgt,
+                                        const std::vector<double>& vals_src,
+                                        MemoryLayout mem_layout,
+                                        bool nearest = true);
+
+}  // namespace h5parm
+}  // namespace schaapcommon
+
+#endif
Index: wsclean/external/schaapcommon/src/h5parm/h5parm.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/h5parm.cc
@@ -0,0 +1,251 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "h5parm.h"
+
+#include <array>
+#include <cstring>
+#include <complex>
+#include <sstream>
+#include <iomanip>
+#include <sys/stat.h>
+#include <limits>
+#include <cstddef>
+
+#include <hdf5.h>
+#include <iostream>
+
+#ifndef offsetof
+#error offsetof not supported by your compiler.
+#endif
+
+namespace schaapcommon {
+namespace h5parm {
+H5Parm::H5Parm(const std::string& filename, bool force_new,
+               bool force_new_sol_set, const std::string& sol_set_name)
+    : H5::H5File(filename, force_new ? H5F_ACC_TRUNC : H5F_ACC_RDONLY) {
+  if (force_new_sol_set || getNumObjs() == 0) {  // Create a new solSet
+    if (sol_set_name == "") {
+      // Get the name of first non-existing solset
+      std::stringstream new_sol_set_name;
+      H5::Group try_group;
+      for (unsigned int sol_set_idx = 0; sol_set_idx < 100; ++sol_set_idx) {
+        try {
+          H5::Exception::dontPrint();
+          new_sol_set_name << "sol" << std::setfill('0') << std::setw(3)
+                           << sol_set_idx;
+          try_group = openGroup(new_sol_set_name.str());
+          new_sol_set_name.str("");
+        } catch (H5::FileIException& not_found_error) {
+          // sol_set_name does not exist yet
+          break;
+        }
+        try_group.close();
+      }
+      sol_set_ = createGroup("/" + new_sol_set_name.str(), H5P_DEFAULT);
+    } else {
+      // Create solset with the given name
+      sol_set_ = createGroup("/" + sol_set_name, H5P_DEFAULT);
+    }
+    AddVersionStamp(sol_set_);
+  } else {
+    std::string sol_set_name_to_open = sol_set_name;
+    if (sol_set_name_to_open == "") {
+      if (this->getNumObjs() == 1) {
+        sol_set_name_to_open = this->getObjnameByIdx(0);
+      } else {
+        throw std::runtime_error("H5Parm " + filename +
+                                 " contains more than one SolSet, " +
+                                 "please specify which one to use.");
+      }
+    }
+
+    sol_set_ = openGroup(sol_set_name_to_open);
+
+    std::vector<std::string> sol_tab_names;
+    for (unsigned int i = 0; i < sol_set_.getNumObjs(); ++i) {
+      if (sol_set_.getObjTypeByIdx(i) == H5G_GROUP) {
+        sol_tab_names.push_back(sol_set_.getObjnameByIdx(i));
+      }
+    }
+
+    for (const std::string& sol_tab_name : sol_tab_names) {
+      H5::Group group = sol_set_.openGroup(sol_tab_name);
+      sol_tabs_.insert(std::map<std::string, SolTab>::value_type(
+          sol_tab_name, SolTab(group)));
+    }
+  }
+}
+
+H5Parm::H5Parm() = default;
+
+H5Parm::~H5Parm() {
+  // Throw compile time assertion if source_t or antenna_t don't have
+  // standard layout
+  static_assert(std::is_standard_layout<source_t>::value,
+                "source_t doesn't have standard layout");
+  static_assert(std::is_standard_layout<antenna_t>::value,
+                "antenna_t doesn't have standard layout");
+  // Throw an error if the antenna or source table is not present
+  // sol_set_.openDataSet("antenna");
+  // sol_set_.openDataSet("source");
+  sol_set_.close();
+}
+
+std::string H5Parm::GetSolSetName() const {
+  char buffer[100];
+  hsize_t namelen = H5Iget_name(sol_set_.getId(), buffer, 100);
+  buffer[namelen + 1] = 0;
+  // Strip leading '/'
+  return buffer + 1;
+}
+
+void H5Parm::AddSources(const std::vector<std::string>& names,
+                        const std::vector<std::pair<double, double>>& dirs) {
+  hsize_t dims[1];
+
+  // Create data type
+  dims[0] = 2;  // For ra, dec in directions
+  H5::CompType source_type(sizeof(source_t));
+  source_type.insertMember("name", offsetof(source_t, name),
+                           H5::StrType(H5::PredType::C_S1, 128));
+  source_type.insertMember("dir", offsetof(source_t, dir),
+                           H5::ArrayType(H5::PredType::NATIVE_FLOAT, 1, dims));
+
+  // Create dataset
+  dims[0] = names.size();
+  H5::DataSpace dataspace(1, dims, nullptr);
+  H5::DataSet dataset =
+      sol_set_.createDataSet("source", source_type, dataspace);
+
+  // Prepare data
+  std::vector<source_t> sources(names.size());
+  for (unsigned int src = 0; src < sources.size(); ++src) {
+    std::strncpy(sources[src].name, names[src].c_str(), 127);
+    sources[src].name[127] = 0;
+    sources[src].dir[0] = dirs[src].first;
+    sources[src].dir[1] = dirs[src].second;
+  }
+
+  // Write data
+  dataset.write(&(sources[0]), source_type);
+}
+
+void H5Parm::AddAntennas(const std::vector<std::string>& names,
+                         const std::vector<std::array<double, 3>>& positions) {
+  hsize_t dims[1];
+
+  // Create data type
+  dims[0] = 3;  // For x,y,z in positions
+  H5::CompType antenna_type(sizeof(antenna_t));
+  antenna_type.insertMember("name", offsetof(antenna_t, name),
+                            H5::StrType(H5::PredType::C_S1, 16));
+  antenna_type.insertMember("position", offsetof(antenna_t, position),
+                            H5::ArrayType(H5::PredType::NATIVE_FLOAT, 1, dims));
+
+  // Create dataset
+  dims[0] = names.size();
+  H5::DataSpace dataspace(1, dims, nullptr);
+  H5::DataSet dataset =
+      sol_set_.createDataSet("antenna", antenna_type, dataspace);
+
+  // Prepare data
+  std::vector<antenna_t> ants(names.size());
+  for (unsigned int ant = 0; ant < ants.size(); ++ant) {
+    std::strncpy(ants[ant].name, names[ant].c_str(), 15);
+    ants[ant].name[15] = 0;
+    const std::array<double, 3>& pos = positions[ant];
+    ants[ant].position[0] = pos[0];
+    ants[ant].position[1] = pos[1];
+    ants[ant].position[2] = pos[2];
+  }
+
+  dataset.write(&(ants[0]), antenna_type);
+}
+
+SolTab& H5Parm::GetSolTab(const std::string& name) {
+  auto item = sol_tabs_.find(name);
+  if (item == sol_tabs_.end()) {
+    throw std::runtime_error("SolTab " + name + " does not exist in solset " +
+                             GetSolSetName());
+  }
+  return item->second;
+}
+
+bool H5Parm::HasSolTab(const std::string& sol_tab_name) const {
+  return sol_tabs_.find(sol_tab_name) != sol_tabs_.end();
+}
+
+SolTab& H5Parm::CreateSolTab(const std::string& name, const std::string& type,
+                             const std::vector<AxisInfo>& axes) {
+  H5::Group newgroup = sol_set_.createGroup(name);
+  std::map<std::string, SolTab>::iterator new_item =
+      sol_tabs_.insert(std::make_pair(name, SolTab(newgroup, type, axes)))
+          .first;
+  return new_item->second;
+}
+
+size_t H5Parm::GetNumSources() const {
+  std::vector<source_t> sources = ReadSourceTable(sol_set_);
+  return sources.size();
+}
+
+std::vector<H5Parm::source_t> H5Parm::GetSources() const {
+  std::vector<source_t> sources = ReadSourceTable(sol_set_);
+  return sources;
+}
+
+std::string H5Parm::GetNearestSource(double ra, double dec) const {
+  std::vector<source_t> sources = ReadSourceTable(sol_set_);
+
+  std::string dirname;
+  double min_dist = std::numeric_limits<double>::max();
+  for (const auto& val : sources) {
+    const double current_dist = (val.dir[0] - ra) * (val.dir[0] - ra) +
+                                (val.dir[1] - dec) * (val.dir[1] - dec);
+    if (current_dist < min_dist) {
+      dirname = val.name;
+      min_dist = current_dist;
+    }
+  }
+  return dirname;
+}
+
+bool H5Parm::IsThreadSafe() {
+  hbool_t is_thread_safe = false;
+  H5is_library_threadsafe(&is_thread_safe);
+  return is_thread_safe;
+}
+
+std::vector<H5Parm::source_t> H5Parm::ReadSourceTable(
+    const H5::Group& sol_set) const {
+  H5::DataSet dataset;
+  H5::DataSpace dataspace;
+  try {
+    dataset = sol_set.openDataSet("source");
+    dataspace = dataset.getSpace();
+  } catch (H5::GroupIException& e) {
+    throw std::runtime_error("H5 file contains no dataset 'source'");
+  }
+
+  hsize_t dims[1];
+  dataspace.getSimpleExtentDims(dims);
+  std::vector<source_t> sources(dims[0]);
+
+  // Create compound data type
+  // Inferring this from the dataset with getDataType()
+  // leads to unexpected errors.
+  hsize_t npdims[2];
+  npdims[0] = 2;  // Should store ra, dec
+  H5::CompType source_type(sizeof(source_t));
+  source_type.insertMember("name", offsetof(source_t, name),
+                           H5::StrType(H5::PredType::C_S1, 128));
+  source_type.insertMember(
+      "dir", offsetof(source_t, dir),
+      H5::ArrayType(H5::PredType::NATIVE_FLOAT, 1, npdims));
+  dataset.read(sources.data(), source_type);
+  return sources;
+}
+
+}  // namespace h5parm
+}  // namespace schaapcommon
Index: wsclean/external/schaapcommon/src/h5parm/jonesparameters.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/jonesparameters.cc
@@ -0,0 +1,421 @@
+// Copyright (C) 2021 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "jonesparameters.h"
+
+#include <casacore/casa/BasicSL/Complex.h>
+#include <casacore/casa/BasicSL/Constants.h>
+
+#include <cassert>
+
+#include <aocommon/matrix2x2.h>
+
+#include <boost/algorithm/string.hpp>
+
+namespace schaapcommon {
+namespace h5parm {
+JonesParameters::JonesParameters(
+    const std::vector<double>& freqs, const std::vector<double>& times,
+    const std::vector<std::string>& antenna_names, CorrectType correct_type,
+    InterpolationType interpolation_type, hsize_t direction,
+    std::vector<std::vector<std::vector<double>>>&& parm_values, bool invert,
+    float sigma_mmse)
+    : parm_values_(parm_values) {
+  const unsigned int num_parms = GetNParms(correct_type);
+  parms_.resize(num_parms, antenna_names.size(), freqs.size() * times.size());
+  for (size_t ant = 0; ant < antenna_names.size(); ++ant) {
+    MakeComplex(ant, freqs, correct_type, invert);
+  }
+  if (invert) {
+    Invert(parms_, sigma_mmse, correct_type);
+  }
+}
+
+JonesParameters::JonesParameters(
+    const std::vector<double>& freqs, const std::vector<double>& times,
+    const std::vector<std::string>& antenna_names, CorrectType correct_type,
+    InterpolationType interpolation_type, hsize_t direction,
+    schaapcommon::h5parm::SolTab* sol_tab,
+    schaapcommon::h5parm::SolTab* sol_tab2, bool invert, float sigma_mmse,
+    unsigned int parm_size, MissingAntennaBehavior missing_antenna_behavior) {
+  const unsigned int num_parms = GetNParms(correct_type);
+
+  parms_.resize(num_parms, antenna_names.size(), freqs.size() * times.size());
+  if (parm_size == 0U) {
+    parm_size = GetNParmValues(correct_type);
+  }
+  parm_values_.resize(parm_size);
+  for (auto& parm_values : parm_values_) {
+    parm_values.resize(antenna_names.size());
+  }
+  for (size_t ant = 0; ant < antenna_names.size(); ++ant) {
+    try {
+      FillParmValues(sol_tab, sol_tab2, freqs, times, antenna_names, ant,
+                     correct_type, interpolation_type, direction);
+      MakeComplex(ant, freqs, correct_type, invert);
+    } catch (const std::exception& e) {
+      if (std::string(e.what()).rfind("SolTab has no element", 0) != 0) {
+        throw;
+      }
+      if (missing_antenna_behavior == MissingAntennaBehavior::kError) {
+        throw;
+      } else if (missing_antenna_behavior == MissingAntennaBehavior::kFlag) {
+        // Insert flagged solution
+        const size_t tfsize = parms_.shape()[2];
+        for (size_t parm = 0; parm < num_parms; ++parm) {
+          for (size_t tf = 0; tf < tfsize; ++tf) {
+            parms_(0, ant, tf) = std::numeric_limits<float>::quiet_NaN();
+          }
+        }
+      } else if (missing_antenna_behavior == MissingAntennaBehavior::kUnit) {
+        // Insert unit solution
+        const size_t tfsize = parms_.shape()[2];
+        if (num_parms == 2) {
+          for (size_t tf = 0; tf < tfsize; ++tf) {
+            parms_(0, ant, tf) = 1.;
+            parms_(1, ant, tf) = 1.;
+          }
+        } else {
+          for (size_t tf = 0; tf < tfsize; ++tf) {
+            parms_(0, ant, tf) = 1.;
+            parms_(1, ant, tf) = 0.;
+            parms_(2, ant, tf) = 0.;
+            parms_(3, ant, tf) = 1.;
+          }
+        }
+      }
+    }
+  }
+  if (invert) {
+    Invert(parms_, sigma_mmse, correct_type);
+  }
+}
+
+void JonesParameters::MakeComplex(size_t ant, const std::vector<double>& freqs,
+                                  CorrectType correct_type, bool invert) {
+  for (unsigned int tf = 0; tf < parms_.shape()[2]; ++tf) {
+    const double freq = freqs[tf % freqs.size()];
+
+    if (correct_type == GAIN) {
+      parms_(0, ant, tf) =
+          casacore::polar(parm_values_[0][ant][tf], parm_values_[1][ant][tf]);
+      parms_(1, ant, tf) =
+          casacore::polar(parm_values_[2][ant][tf], parm_values_[3][ant][tf]);
+    } else if (correct_type == FULLJONES) {
+      parms_(0, ant, tf) =
+          casacore::polar(parm_values_[0][ant][tf], parm_values_[1][ant][tf]);
+      parms_(1, ant, tf) =
+          casacore::polar(parm_values_[2][ant][tf], parm_values_[3][ant][tf]);
+      parms_(2, ant, tf) =
+          casacore::polar(parm_values_[4][ant][tf], parm_values_[5][ant][tf]);
+      parms_(3, ant, tf) =
+          casacore::polar(parm_values_[6][ant][tf], parm_values_[7][ant][tf]);
+    } else if (correct_type == SCALARGAIN) {
+      parms_(0, ant, tf) =
+          casacore::polar(parm_values_[0][ant][tf], parm_values_[1][ant][tf]);
+      parms_(1, ant, tf) = parms_(0, ant, tf);
+    } else if (correct_type == TEC) {
+      parms_(0, ant, tf) =
+          casacore::polar(1., parm_values_[0][ant][tf] * -8.44797245e9 / freq);
+      if (parm_values_.size() == 1) {  // No TEC:0, only TEC:
+        parms_(1, ant, tf) = casacore::polar(
+            1., parm_values_[0][ant][tf] * -8.44797245e9 / freq);
+      } else {  // TEC:0 and TEC:1
+        parms_(1, ant, tf) = casacore::polar(
+            1., parm_values_[1][ant][tf] * -8.44797245e9 / freq);
+      }
+    } else if (correct_type == CLOCK) {
+      parms_(0, ant, tf) = casacore::polar(
+          1., parm_values_[0][ant][tf] * freq * casacore::C::_2pi);
+      if (parm_values_.size() == 1) {  // No Clock:0, only Clock:
+        parms_(1, ant, tf) = casacore::polar(
+            1., parm_values_[0][ant][tf] * freq * casacore::C::_2pi);
+      } else {  // Clock:0 and Clock:1
+        parms_(1, ant, tf) = casacore::polar(
+            1., parm_values_[1][ant][tf] * freq * casacore::C::_2pi);
+      }
+    } else if (correct_type == ROTATIONANGLE) {
+      double phi = parm_values_[0][ant][tf];
+      if (invert) {
+        phi = -phi;
+      }
+      const float sinv = std::sin(phi);
+      const float cosv = std::cos(phi);
+      parms_(0, ant, tf) = cosv;
+      parms_(1, ant, tf) = -sinv;
+      parms_(2, ant, tf) = sinv;
+      parms_(3, ant, tf) = cosv;
+    } else if (correct_type == ROTATIONMEASURE) {
+      const double lambda2 = (casacore::C::c / freq) * (casacore::C::c / freq);
+      double chi = parm_values_[0][ant][tf] * lambda2;
+      if (invert) {
+        chi = -chi;
+      }
+      const float sinv = std::sin(chi);
+      const float cosv = std::cos(chi);
+      parms_(0, ant, tf) = cosv;
+      parms_(1, ant, tf) = -sinv;
+      parms_(2, ant, tf) = sinv;
+      parms_(3, ant, tf) = cosv;
+    } else if (correct_type == PHASE || correct_type == SCALARPHASE) {
+      parms_(0, ant, tf) = casacore::polar(1., parm_values_[0][ant][tf]);
+      if (correct_type == SCALARPHASE) {  // Same value for x and y
+        parms_(1, ant, tf) = casacore::polar(1., parm_values_[0][ant][tf]);
+      } else {  // Different value for x and y
+        parms_(1, ant, tf) = casacore::polar(1., parm_values_[1][ant][tf]);
+      }
+    } else if (correct_type == AMPLITUDE || correct_type == SCALARAMPLITUDE) {
+      parms_(0, ant, tf) = parm_values_[0][ant][tf];
+      if (correct_type == SCALARAMPLITUDE) {  // Same value for x and y
+        parms_(1, ant, tf) = parm_values_[0][ant][tf];
+      } else {  // Different value for x and y
+        parms_(1, ant, tf) = parm_values_[1][ant][tf];
+      }
+    } else if (correct_type == GAIN_RE_IM) {
+      parms_(0, ant, tf) = std::complex<float>(parm_values_[0][ant][tf],
+                                               parm_values_[1][ant][tf]);
+      parms_(1, ant, tf) = std::complex<float>(parm_values_[2][ant][tf],
+                                               parm_values_[3][ant][tf]);
+    } else if (correct_type == FULLJONES_RE_IM) {
+      parms_(0, ant, tf) = std::complex<float>(parm_values_[0][ant][tf],
+                                               parm_values_[1][ant][tf]);
+      parms_(1, ant, tf) = std::complex<float>(parm_values_[2][ant][tf],
+                                               parm_values_[3][ant][tf]);
+      parms_(2, ant, tf) = std::complex<float>(parm_values_[4][ant][tf],
+                                               parm_values_[5][ant][tf]);
+      parms_(3, ant, tf) = std::complex<float>(parm_values_[6][ant][tf],
+                                               parm_values_[7][ant][tf]);
+    }
+  }
+}
+
+unsigned int JonesParameters::GetNParms(CorrectType correct_type) {
+  switch (correct_type) {
+    case FULLJONES:
+    case ROTATIONANGLE:
+    case ROTATIONMEASURE:
+    case FULLJONES_RE_IM:
+      return 4;
+    default:
+      return 2;
+  }
+}
+
+unsigned int JonesParameters::GetNParmValues(CorrectType correct_type) {
+  switch (correct_type) {
+    case FULLJONES:
+    case FULLJONES_RE_IM:
+      return 8;
+    case GAIN:
+    case GAIN_RE_IM:
+      return 4;
+    case PHASE:
+    case AMPLITUDE:
+    case SCALARGAIN:
+      return 2;
+    case ROTATIONANGLE:
+    case SCALARPHASE:
+    case ROTATIONMEASURE:
+    case SCALARAMPLITUDE:
+      return 1;
+    case TEC:
+    case CLOCK:
+      throw std::runtime_error(
+          "Correction type is variable. Use parameter parm_size instead.");
+  }
+  throw std::runtime_error("Unknown correction type");
+}
+
+void JonesParameters::FillParmValues(
+    schaapcommon::h5parm::SolTab* sol_tab,
+    schaapcommon::h5parm::SolTab* sol_tab2, const std::vector<double>& freqs,
+    const std::vector<double>& times,
+    const std::vector<std::string>& antenna_names, size_t ant,
+    CorrectType correct_type, InterpolationType interpolation_type,
+    hsize_t direction) {
+  auto get_flagged_values = [times, freqs, direction, interpolation_type](
+                                SolTab* sol_tab,
+                                const std::string& antenna_name,
+                                unsigned int pol) -> std::vector<double> {
+    std::vector<double> parmvalues = sol_tab->GetValuesOrWeights(
+        "val", antenna_name, times, freqs, pol, direction,
+        interpolation_type == InterpolationType::NEAREST);
+    std::vector<double> weights = sol_tab->GetValuesOrWeights(
+        "weight", antenna_name, times, freqs, pol, direction,
+        interpolation_type == InterpolationType::NEAREST);
+    ApplyFlags(parmvalues, weights);
+    return parmvalues;
+  };
+
+  const std::string& ant_name = antenna_names[ant];
+  if (correct_type == JonesParameters::CorrectType::FULLJONES ||
+      correct_type == JonesParameters::CorrectType::GAIN ||
+      correct_type == JonesParameters::CorrectType::SCALARGAIN) {
+    for (size_t pol = 0; pol < parm_values_.size() / 2; ++pol) {
+      // Place amplitude in even and phase in odd elements
+      parm_values_[pol * 2][ant] = get_flagged_values(sol_tab, ant_name, pol);
+      if (sol_tab2 == nullptr) {
+        throw std::runtime_error(
+            "soltab2 cannot be a nullpointer for correct_type=FULLJONES and "
+            "correct_type=GAIN");
+      }
+      parm_values_[pol * 2 + 1][ant] =
+          get_flagged_values(sol_tab2, ant_name, pol);
+    }
+  } else {
+    for (size_t pol = 0; pol < parm_values_.size(); ++pol) {
+      parm_values_[pol][ant] = get_flagged_values(sol_tab, ant_name, pol);
+    }
+  }
+}
+
+void JonesParameters::ApplyFlags(std::vector<double>& values,
+                                 const std::vector<double>& weights) {
+  assert(values.size() == weights.size());
+  auto weight_it = weights.cbegin();
+
+  for (double& value : values) {
+    if (*weight_it == 0.) {
+      value = std::numeric_limits<double>::quiet_NaN();
+    }
+    ++weight_it;
+  }
+}
+
+void JonesParameters::Invert(casacore::Cube<casacore::Complex>& parms,
+                             float sigma_mmse, CorrectType correct_type) {
+  for (unsigned int tf = 0; tf < parms.shape()[2]; ++tf) {
+    for (unsigned int ant = 0; ant < parms.shape()[1]; ++ant) {
+      if (parms.shape()[0] == 2) {
+        parms(0, ant, tf) = 1.f / parms(0, ant, tf);
+        parms(1, ant, tf) = 1.f / parms(1, ant, tf);
+      } else if (correct_type == FULLJONES || correct_type == FULLJONES_RE_IM) {
+        aocommon::MC2x2F v(&parms(0, ant, tf));
+
+        // Add the variance of the nuisance term to the elements on the
+        // diagonal.
+        const float variance = sigma_mmse * sigma_mmse;
+        v[0] += variance;
+        v[3] += variance;
+        v.Invert();
+        v.AssignTo(&parms(0, ant, tf));
+      } else if (correct_type == ROTATIONMEASURE ||
+                 correct_type == ROTATIONANGLE) {
+        // rotationmeasure and commonrotationangle have been inverted already in
+        // MakeComplex
+      } else {
+        throw std::runtime_error("Invalid correction type");
+      }
+    }
+  }
+}
+
+std::string JonesParameters::CorrectTypeToString(
+    JonesParameters::CorrectType ct) {
+  switch (ct) {
+    case CorrectType::GAIN:
+      return "gain";
+    case CorrectType::GAIN_RE_IM:
+      return "gain_re_im";
+    case CorrectType::FULLJONES:
+      return "fulljones";
+    case CorrectType::FULLJONES_RE_IM:
+      return "fulljones_re_im";
+    case CorrectType::TEC:
+      return "tec";
+    case CorrectType::CLOCK:
+      return "clock";
+    case CorrectType::SCALARGAIN:
+      return "scalargain";
+    case CorrectType::SCALARPHASE:
+      return "scalarphase";
+    case CorrectType::SCALARAMPLITUDE:
+      return "scalaramplitude";
+    case CorrectType::ROTATIONANGLE:
+      return "rotationangle";
+    case CorrectType::ROTATIONMEASURE:
+      return "rotationmeasure";
+    case CorrectType::PHASE:
+      return "phase";
+    case CorrectType::AMPLITUDE:
+      return "amplitude";
+  }
+  throw std::runtime_error("Unknown correction type: " + std::to_string(ct));
+}
+
+JonesParameters::CorrectType JonesParameters::StringToCorrectType(
+    const std::string& ctStr) {
+  if (ctStr == "gain") {
+    return CorrectType::GAIN;
+  } else if (ctStr == "fulljones") {
+    return CorrectType::FULLJONES;
+  } else if (ctStr == "tec") {
+    return CorrectType::TEC;
+  } else if (ctStr == "clock") {
+    return CorrectType::CLOCK;
+  } else if (ctStr == "scalargain" || ctStr == "commonscalargain") {
+    return CorrectType::SCALARGAIN;
+  } else if (ctStr == "scalarphase" || ctStr == "commonscalarphase") {
+    return CorrectType::SCALARPHASE;
+  } else if (ctStr == "scalaramplitude" || ctStr == "commonscalaramplitude") {
+    return CorrectType::SCALARAMPLITUDE;
+  } else if (ctStr == "phase") {
+    return CorrectType::PHASE;
+  } else if (ctStr == "amplitude") {
+    return CorrectType::AMPLITUDE;
+  } else if (ctStr == "rotationangle" || ctStr == "commonrotationangle" ||
+             ctStr == "rotation") {
+    return CorrectType::ROTATIONANGLE;
+  } else if (ctStr == "rotationmeasure") {
+    return CorrectType::ROTATIONMEASURE;
+  } else {
+    // TODO:
+    // - FULLJONES_RE_IM
+    // - GAIN_RE_IM
+    // are not listed, ask TJ
+    throw std::runtime_error("Unknown correction type: " + ctStr);
+  }
+}
+
+JonesParameters::MissingAntennaBehavior
+JonesParameters::StringToMissingAntennaBehavior(
+    const std::string& behavior_str) {
+  if (behavior_str == "error") {
+    return JonesParameters::MissingAntennaBehavior::kError;
+  } else if (behavior_str == "flag") {
+    return JonesParameters::MissingAntennaBehavior::kFlag;
+  } else if (behavior_str == "unit") {
+    return JonesParameters::MissingAntennaBehavior::kUnit;
+  } else {
+    throw std::runtime_error(
+        "missingantennabehavior should be one of 'error', 'flag' or "
+        "'unit', not '" +
+        behavior_str + "'");
+  }
+}
+
+std::string JonesParameters::MissingAntennaBehaviorToString(
+    JonesParameters::MissingAntennaBehavior behavior) {
+  if (behavior == JonesParameters::MissingAntennaBehavior::kError) {
+    return "error";
+  } else if (behavior == JonesParameters::MissingAntennaBehavior::kFlag) {
+    return "flag";
+  } else if (behavior == JonesParameters::MissingAntennaBehavior::kUnit) {
+    return "unit";
+  }
+  throw std::logic_error("Unexpected missingantennabehavior");
+}
+
+std::vector<std::string> JonesParameters::ParseList(
+    const std::string& list_str) {
+  std::vector<std::string> list;
+  boost::split(list, list_str, [](char c) { return c == ','; });
+  if (list.size() > 2) {
+    throw std::runtime_error(
+        "List of soltab names should contain at most two entries.");
+  }
+  return list;
+}
+
+}  // namespace h5parm
+}  // namespace schaapcommon
Index: wsclean/external/schaapcommon/src/h5parm/soltab.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/soltab.cc
@@ -0,0 +1,683 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include "soltab.h"
+#include "gridinterpolate.h"
+
+#include <algorithm>
+#include <cassert>
+#include <cstdlib>
+#include <cmath>
+#include <cstring>
+#include <iostream>
+#include <ctime>
+#include <iomanip>
+
+#include <hdf5.h>
+
+// using namespace std;
+namespace schaapcommon {
+namespace h5parm {
+
+namespace {
+std::vector<std::string> Tokenize(const std::string& str,
+                                  const std::string& delims) {
+  std::vector<std::string> tokens;
+  std::string::size_type pos = 0;
+  std::string::size_type pos0;
+
+  while ((pos0 = str.find_first_not_of(delims, pos)) != std::string::npos) {
+    pos = str.find_first_of(delims, pos0 + 1);
+    if (pos - pos0 > 0) {  // If pos == std::string::npos then substr() clamps.
+      tokens.push_back(str.substr(pos0, pos - pos0));
+    }
+  }
+
+  return tokens;
+}
+}  // namespace
+
+SolTab::SolTab(H5::Group group, const std::string& type,
+               const std::vector<AxisInfo>& axes)
+    : H5::Group(group), type_(type), axes_(axes) {
+  H5::Attribute attr = createAttribute(
+      "TITLE", H5::StrType(H5::PredType::C_S1, type_.size()), H5::DataSpace());
+  attr.write(H5::StrType(H5::PredType::C_S1, type_.size()), type_);
+  AddVersionStamp(*this);
+}
+
+SolTab::SolTab(H5::Group& group) : H5::Group(group) {
+  // Read the type from the "TITLE" attribute
+  H5::Attribute typeattr = openAttribute("TITLE");
+  hsize_t typenamelen = typeattr.getDataType().getSize();
+  char typecstr[typenamelen + 1];
+  typecstr[typenamelen] = '\0';
+  typeattr.read(typeattr.getDataType(), &typecstr);
+  type_ = typecstr;
+
+  ReadAxes();
+}
+
+SolTab::~SolTab() = default;
+
+void SolTab::AddVersionStamp(H5::Group& node) {
+  // Write an attribute with the h5parm version
+  H5::Attribute attr = node.createAttribute(
+      "h5parm_version", H5::StrType(H5::PredType::C_S1, 3), H5::DataSpace());
+  attr.write(H5::StrType(H5::PredType::C_S1, 3), "1.0");
+}
+
+AxisInfo SolTab::GetAxis(unsigned int i) const { return axes_[i]; }
+
+AxisInfo SolTab::GetAxis(const std::string& axis_name) const {
+  for (const AxisInfo& axis_info : axes_) {
+    if (axis_info.name == axis_name) {
+      return axis_info;
+    }
+  }
+  throw std::runtime_error("Axis " + axis_name + " does not exist in " +
+                           GetName());
+}
+
+bool SolTab::HasAxis(const std::string& axis_name) const {
+  for (const auto& axis : axes_) {
+    if (axis.name == axis_name) return true;
+  }
+  return false;
+}
+
+size_t SolTab::GetAxisIndex(const std::string& axis_name) const {
+  for (size_t i = 0; i < axes_.size(); ++i) {
+    if (axes_[i].name == axis_name) return i;
+  }
+  throw std::runtime_error("Axis " + axis_name + " does not exist in " +
+                           GetName());
+}
+
+void SolTab::SetValues(const std::vector<double>& vals,
+                       const std::vector<double>& weights,
+                       const std::string& history) {
+  // Convert axes to comma separated string, fill dims
+  size_t expectedsize = 1;
+  std::string axesstr = axes_.front().name;
+  std::vector<hsize_t> dims(axes_.size());
+  for (unsigned int i = 0; i < axes_.size(); ++i) {
+    dims[i] = axes_[i].size;
+    expectedsize *= dims[i];
+    if (i > 0) {
+      axesstr += "," + axes_[i].name;
+    }
+  }
+
+  if (expectedsize != vals.size()) {
+    throw std::runtime_error(
+        "Values for H5Parm do not have the expected size: they have size " +
+        std::to_string(vals.size()) + ", expected is " +
+        std::to_string(expectedsize));
+  }
+
+  H5::DataSpace dataspace(dims.size(), dims.data(), nullptr);
+  H5::DataSet dataset =
+      createDataSet("val", H5::PredType::IEEE_F64LE, dataspace);
+
+  dataset.write(vals.data(), H5::PredType::IEEE_F64LE);
+
+  H5::Attribute attr = dataset.createAttribute(
+      "AXES", H5::StrType(H5::PredType::C_S1, axesstr.size()), H5::DataSpace());
+  attr.write(H5::StrType(H5::PredType::C_S1, axesstr.size()), axesstr);
+
+  // Write history if given
+  if (history.size() > 0) {
+    time_t rawtime;
+    struct tm* timeinfo;
+    char timebuffer[80];
+
+    time(&rawtime);
+    timeinfo = localtime(&rawtime);
+
+    strftime(timebuffer, sizeof(timebuffer), "%d-%m-%Y %H:%M:%S", timeinfo);
+
+    std::string historyline = std::string(timebuffer) + ": " + history;
+
+    H5::StrType historytype =
+        H5::StrType(H5::PredType::C_S1, historyline.size());
+    H5::Attribute attr =
+        dataset.createAttribute("HISTORY000", historytype, H5::DataSpace());
+    attr.write(historytype, historyline);
+  }
+
+  // Add weights
+  // Do not use half float data type because typical weights range can be 1.e-14
+  /*
+  hid_t halffloat = H5Tcopy(H5T_IEEE_F32BE);
+  H5Tset_fields(halffloat, 15, 10, 5, 0, 10);
+  H5Tset_size(halffloat, 2);
+  H5Tset_ebias(halffloat, 15);
+  H5Tlock(halffloat);
+  */
+  H5::DataSet weightset =
+      createDataSet("weight", H5::PredType::IEEE_F32LE, dataspace);
+
+  // If weights are empty, write ones everywhere
+  std::vector<double> fullweights;
+  if (weights.empty()) {
+    fullweights.resize(vals.size(), 1.0);
+  } else {
+    if (weights.size() != vals.size()) {
+      throw std::runtime_error(
+          "Values for H5Parm weights do not have the expected size: they have "
+          "size " +
+          std::to_string(weights.size()) + ", expected is " +
+          std::to_string(vals.size()));
+    }
+    // Copy weights so that they can be changed (to add flags)
+    fullweights = weights;
+  }
+
+  // Set weight of NaN values to 0.
+  for (size_t i = 0; i < vals.size(); ++i) {
+    if (std::isnan(vals[i])) {
+      fullweights[i] = 0.;
+    }
+  }
+
+  weightset.write(fullweights.data(), H5::PredType::IEEE_F64LE);
+
+  attr = weightset.createAttribute(
+      "AXES", H5::StrType(H5::PredType::C_S1, axesstr.size()), H5::DataSpace());
+  attr.write(H5::StrType(H5::PredType::C_S1, axesstr.size()), axesstr);
+}
+
+void SolTab::SetComplexValues(const std::vector<std::complex<double>>& vals,
+                              const std::vector<double>& weights,
+                              bool to_amplitudes, const std::string& history) {
+  // Convert values to real numbers by taking amplitude or argument
+  std::vector<double> realvals(vals.size());
+
+  if (to_amplitudes) {
+    std::transform(vals.begin(), vals.end(), realvals.begin(), TakeAbs);
+  } else {  // Phase only
+    std::transform(vals.begin(), vals.end(), realvals.begin(), TakeArg);
+  }
+
+  SetValues(realvals, weights, history);
+}
+
+void SolTab::ReadAxes() {
+  H5::DataSet val;
+  try {
+    val = openDataSet("val");
+  } catch (H5::GroupIException& e) {
+    throw std::runtime_error("SolTab " + GetName() + " has no values");
+  }
+
+  H5::Attribute axesattr;
+  try {
+    axesattr = val.openAttribute("AXES");
+  } catch (H5::AttributeIException& e) {
+    throw std::runtime_error("Values of SolTab " + GetName() +
+                             " has no AXES attribute");
+  }
+
+  hsize_t axesstrlen = axesattr.getDataType().getSize();
+  char axescstr[axesstrlen + 1];
+  axescstr[axesstrlen] = '\0';
+  axesattr.read(axesattr.getDataType(), &axescstr);
+  std::vector<std::string> axesnames = Tokenize(axescstr, ",");
+
+  unsigned int ndims = axesnames.size();
+
+  // Get number of dimensions and size of all dimensions
+  H5::DataSpace ds = val.getSpace();
+  if (ds.getSimpleExtentNdims() != int(ndims)) {
+    throw std::runtime_error(
+        "H5Parm is inconsistent: number of axes in data (" +
+        std::to_string(ds.getSimpleExtentNdims()) +
+        ") does not match number of axes in metadata (" +
+        std::to_string(int(ndims)) + ")");
+  }
+  hsize_t dims_out[ndims];
+  ds.getSimpleExtentDims(dims_out);
+
+  for (unsigned int i = 0; i < axesnames.size(); ++i) {
+    AxisInfo a{axesnames[i], static_cast<unsigned int>(dims_out[i])};
+    axes_.push_back(a);
+  }
+
+  if (HasAxis("time")) {
+    const std::vector<double> time_axis = GetRealAxis("time");
+    if (!std::is_sorted(time_axis.begin(), time_axis.end())) {
+      throw std::runtime_error("Time axis in H5 file should be ordered.");
+    }
+  }
+}
+
+std::string SolTab::GetName() const {
+  size_t len = H5Iget_name(getId(), nullptr, 0);
+  char buffer[len];
+  H5Iget_name(getId(), buffer, len + 1);
+  // Strip leading /
+  return buffer + 1;
+}
+
+std::vector<double> SolTab::GetValuesOrWeights(const std::string& val_or_weight,
+                                               const std::string& ant_name,
+                                               const std::vector<double>& times,
+                                               const std::vector<double>& freqs,
+                                               unsigned int pol,
+                                               unsigned int dir, bool nearest) {
+  std::vector<double> res(times.size() * freqs.size());
+
+  unsigned int start_time_slot = 0;
+  unsigned int num_time_h5 = 1;
+
+  assert(!times.empty());
+  assert(!freqs.empty());
+  unsigned int freq_start = 0;
+  unsigned int num_freq_h5 = 1;
+
+  std::vector<double> freq_axis_h5(1, 0.);
+  std::vector<double> time_axis_h5(1, 0.);
+  if (HasAxis("time")) {
+    time_axis_h5 = GetRealAxis("time");
+    if (times.size() > 1) {
+      num_time_h5 = time_axis_h5.size();
+    } else {
+      // When only one time is requested, find the nearest H5 time indices
+      // and only read H5 data for those indices.
+
+      // ReadAxes() already checked that the "time" axis is sorted.
+      const auto lower = std::lower_bound(time_axis_h5.begin(),
+                                          time_axis_h5.end(), times.front());
+      if (lower == time_axis_h5.begin()) {
+        // start_time_slot remains 0
+        time_axis_h5.resize(1);  // Keep the first item only.
+      } else if (lower == time_axis_h5.end()) {
+        start_time_slot = time_axis_h5.size() - 1;
+        time_axis_h5 = {time_axis_h5.back()};
+      } else {
+        // The time lies between *(lower-1) and *lower.
+        start_time_slot = std::distance(time_axis_h5.begin(), lower) - 1;
+        if (nearest) {
+          // Only use the nearest entry.
+          if (times.front() - *(lower - 1) > *lower - times.front()) {
+            ++start_time_slot;
+          }
+          time_axis_h5 = {time_axis_h5[start_time_slot]};
+        } else {
+          // Only load the two entries around the entry.
+          num_time_h5 = 2;
+          time_axis_h5 = {*(lower - 1), *lower};
+        }
+      }
+    }
+  }
+  if (HasAxis("freq")) {
+    std::vector<double> full_freq_axis_h5 = GetRealAxis("freq");
+    freq_start = GetFreqIndex(freqs.front());
+    num_freq_h5 = GetFreqIndex(freqs.back()) - freq_start + 1;
+    freq_axis_h5 = std::vector<double>(
+        full_freq_axis_h5.begin() + freq_start,
+        full_freq_axis_h5.begin() + freq_start + num_freq_h5);
+  }
+  if (HasAxis("pol")) {
+    unsigned int num_pol_h5 = GetAxis("pol").size;
+    if (pol > num_pol_h5 - 1) {
+      throw std::runtime_error("Polarization " + std::to_string(pol) +
+                               " requested from H5Parm, but only " +
+                               std::to_string(num_pol_h5) +
+                               " polarizations are in there.");
+    }
+  }
+  const std::vector<double> h5values =
+      GetValuesOrWeights(val_or_weight, ant_name, start_time_slot, num_time_h5,
+                         1, freq_start, num_freq_h5, 1, pol, dir);
+
+  MemoryLayout mem_layout = MemoryLayout::kRowMajor;
+  // If the frequency index is lower than the time index, time will be the
+  // fastest changing index. The ordering needs to be swapped, to ensure that
+  // the frequency will be the fastest changing index
+  if (HasAxis("freq") && HasAxis("time") &&
+      GetAxisIndex("freq") < GetAxisIndex("time")) {
+    mem_layout = MemoryLayout::kColumnMajor;
+  }
+  return GridNearestNeighbor(time_axis_h5, freq_axis_h5, times, freqs, h5values,
+                             mem_layout, nearest);
+}
+
+std::vector<double> SolTab::GetValuesOrWeights(
+    const std::string& val_or_weight, const std::string& ant_name,
+    unsigned int starttimeslot, unsigned int ntime, unsigned int timestep,
+    unsigned int startfreq, unsigned int nfreq, unsigned int freqstep,
+    unsigned int pol, unsigned int dir) {
+  std::vector<double> res(ntime * nfreq);
+  H5::DataSet val = openDataSet(val_or_weight);
+
+  // Set offsets and strides
+  hsize_t memdims[axes_.size()];
+  hsize_t offset[axes_.size()];
+  hsize_t count[axes_.size()];
+  hsize_t stride[axes_.size()];
+
+  for (unsigned int i = 0; i < axes_.size(); ++i) {
+    stride[i] = 1;
+    count[i] = 1;
+    memdims[i] = 1;
+    if (axes_[i].name == "time") {
+      offset[i] = starttimeslot;
+      stride[i] = timestep;
+      count[i] = ntime;
+      memdims[i] = ntime;
+    } else if (axes_[i].name == "freq") {
+      offset[i] = startfreq;
+      stride[i] = freqstep;
+      count[i] = nfreq;
+      memdims[i] = nfreq;
+    } else if (axes_[i].name == "ant") {
+      offset[i] = GetAntIndex(ant_name);
+    } else if (axes_[i].name == "dir") {
+      offset[i] = dir;
+    } else if (axes_[i].name == "pol") {
+      offset[i] = pol;
+    } else {
+      if (axes_[i].size != 1) {
+        throw std::runtime_error("Axis \"" + axes_[i].name +
+                                 "\" in H5Parm is not understood");
+      }
+      offset[i] = 0;
+    }
+  }
+
+  H5::DataSpace dataspace = val.getSpace();
+
+  dataspace.selectHyperslab(H5S_SELECT_SET, count, offset, stride);
+
+  // Setup memory dataspace
+  H5::DataSpace memspace(axes_.size(), memdims);
+  try {
+    val.read(res.data(), H5::PredType::NATIVE_DOUBLE, memspace, dataspace);
+  } catch (H5::DataSetIException& e) {
+    e.printErrorStack();
+    throw std::runtime_error("Could not read data");
+  }
+  return res;
+}
+
+void SolTab::SetAntennas(const std::vector<std::string>& sol_antennas) {
+  // TODO: check that antenna is present in antenna table in solset
+  hsize_t dims[1];
+  dims[0] = sol_antennas.size();
+
+  size_t str_max_length = 1;
+  for (const std::string& name : sol_antennas) {
+    str_max_length = std::max(str_max_length, name.length());
+  }
+
+  // Create dataset
+  H5::DataSpace dataspace(1, dims, nullptr);
+  H5::DataSet dataset = createDataSet(
+      "ant", H5::StrType(H5::PredType::C_S1, str_max_length), dataspace);
+
+  // Prepare data
+  char ant_array[sol_antennas.size()][str_max_length];
+  for (unsigned int i = 0; i < sol_antennas.size(); ++i) {
+    strncpy(ant_array[i], sol_antennas[i].c_str(), str_max_length);
+  }
+
+  dataset.write(ant_array, H5::StrType(H5::PredType::C_S1, str_max_length));
+}
+
+void SolTab::SetAxisMeta(const std::string& meta_name, size_t num_char,
+                         const std::vector<std::string>& meta_vals) {
+  hsize_t dims[1];  // Only a name
+  dims[0] = meta_vals.size();
+
+  // Create dataset
+  H5::DataSpace dataspace(1, dims, nullptr);
+  H5::DataSet dataset = createDataSet(
+      meta_name, H5::StrType(H5::PredType::C_S1, num_char), dataspace);
+
+  if (meta_vals.size() > 0) {
+    // Prepare data
+    char src_array[meta_vals.size()][num_char];
+    for (unsigned int i = 0; i < meta_vals.size(); ++i) {
+      strncpy(src_array[i], meta_vals[i].c_str(), num_char);
+    }
+
+    dataset.write(src_array, H5::StrType(H5::PredType::C_S1, num_char));
+  }
+}
+
+void SolTab::SetSources(const std::vector<std::string>& sol_sources) {
+  SetAxisMeta("dir", 128, sol_sources);
+}
+
+void SolTab::SetPolarizations(const std::vector<std::string>& polarizations) {
+  SetAxisMeta("pol", 2, polarizations);
+}
+
+void SolTab::SetFreqs(const std::vector<double>& freqs) {
+  SetAxisMeta("freq", freqs);
+}
+
+void SolTab::SetTimes(const std::vector<double>& times) {
+  SetAxisMeta("time", times);
+}
+
+void SolTab::SetAxisMeta(const std::string& meta_name,
+                         const std::vector<double>& meta_vals) {
+  hsize_t dims[1];
+  dims[0] = meta_vals.size();
+
+  // Create dataset
+  H5::DataSpace dataspace(1, dims, nullptr);
+  H5::DataSet dataset =
+      createDataSet(meta_name, H5::PredType::IEEE_F64LE, dataspace);
+
+  if (meta_vals.size() > 0) {
+    dataset.write(meta_vals.data(), H5::PredType::IEEE_F64LE);
+  }
+}
+
+hsize_t SolTab::GetAntIndex(const std::string& ant_name) {
+  return GetNamedIndex(ant_map_, "ant", ant_name);
+}
+
+void SolTab::FillCache(std::map<std::string, hsize_t>& cache,
+                       const std::string& table_name) {
+  H5::DataSet dataset;
+  H5::DataSpace dataspace;
+  try {
+    dataset = openDataSet(table_name);
+    dataspace = dataset.getSpace();
+  } catch (H5::GroupIException& e) {
+    throw std::runtime_error("SolTab has no table " + table_name);
+  }
+  if (dataspace.getSimpleExtentNdims() != 1) {
+    throw std::runtime_error("Invalid H5Parm: table \"" + table_name +
+                             "\" should be onedimensional");
+  }
+  hsize_t dims[1];
+  dataspace.getSimpleExtentDims(dims);
+
+  // TODO: check that DataType is String
+  hsize_t str_len = dataset.getDataType().getSize();
+
+  char el_names[str_len * dims[0]];
+  dataset.read(el_names, H5::StrType(H5::PredType::C_S1, str_len));
+
+  for (hsize_t el_num = 0; el_num < dims[0]; ++el_num) {
+    char el_name_cstr[str_len + 1];
+    std::copy(el_names + el_num * str_len, el_names + (el_num + 1) * str_len,
+              el_name_cstr);
+    el_name_cstr[str_len] = '\0';
+    cache[el_name_cstr] = el_num;
+  }
+}
+
+hsize_t SolTab::GetNamedIndex(std::map<std::string, hsize_t>& cache,
+                              const std::string& table_name,
+                              const std::string& element_name) {
+  // Initialize ant_map_ or dir_map_ on first use
+  if (cache.empty()) {
+    FillCache(cache, table_name);
+  }
+  auto it = cache.find(element_name);
+  if (it == cache.end()) {
+    throw std::runtime_error("SolTab has no element " + element_name + " in " +
+                             table_name);
+  }
+  return it->second;
+}
+
+hsize_t SolTab::GetFreqIndex(double freq) const {
+  if (GetAxis("freq").size == 1) {
+    return 0;
+  }
+  std::vector<double> freqs = GetRealAxis("freq");
+  double freq_interval = GetFreqInterval(0);
+
+  // A full cell width before the first frequency
+  if (freq < freqs.front() - freq_interval) {
+    throw std::runtime_error("Frequency " + std::to_string(freq) +
+                             " not found in " + GetName());
+  }
+  if (freq < freqs.front()) {
+    return 0;
+  }
+  // No assumptions on regular spacing here
+  for (size_t i = 0; i < freqs.size() - 1; ++i) {
+    if (freq < freqs[i + 1]) {
+      // Nearest neighbor: i or i+1
+      if (freq - freqs[i] < freqs[i + 1] - freq) {
+        return i;
+      } else {
+        return i + 1;
+      }
+    }
+  }
+
+  // A full cell width after the last frequency
+  freq_interval = GetFreqInterval(freqs.size() - 2);
+  if (freq < freqs.back() + freq_interval) {
+    return freqs.size() - 1;
+  }
+
+  throw std::runtime_error("Frequency " + std::to_string(freq) +
+                           " not found in " + GetName());
+  return 0;
+}
+
+std::vector<double> SolTab::GetRealAxis(const std::string& axisname) const {
+  H5::DataSet dataset;
+  H5::DataSpace dataspace;
+  try {
+    dataset = openDataSet(axisname);
+    dataspace = dataset.getSpace();
+  } catch (H5::GroupIException& e) {
+    throw std::runtime_error("SolTab " + GetName() + " has no axis '" +
+                             axisname + "'");
+  }
+  if (dataspace.getSimpleExtentNdims() != 1) {
+    throw std::runtime_error(
+        "Error in H5Parm: dataspace.getSimpleExtentNdims() = " +
+        std::to_string(dataspace.getSimpleExtentNdims()) + " for axis " +
+        axisname + ", this should be a one-dimensional array");
+  }
+
+  hsize_t dims[1];
+  dataspace.getSimpleExtentDims(dims);
+
+  std::vector<double> data(dims[0]);
+  dataset.read(data.data(), H5::PredType::NATIVE_DOUBLE);
+
+  return data;
+}
+
+std::vector<std::string> SolTab::GetStringAxis(const std::string& axis_name) {
+  std::map<std::string, hsize_t> cachemap;
+
+  if (axis_name == "dir") {
+    if (dir_map_.empty()) {
+      FillCache(dir_map_, "dir");
+    }
+    cachemap = dir_map_;
+  } else if (axis_name == "ant") {
+    if (ant_map_.empty()) {
+      FillCache(ant_map_, "ant");
+    }
+    cachemap = ant_map_;
+  } else {
+    throw std::runtime_error(
+        "Only string axes 'ant' and 'dir' supported for now.");
+  }
+
+  // Get the keys of the cache map and put them in a std::vector
+  std::vector<std::string> res;
+  for (const auto& key : cachemap) {
+    res.push_back(key.first);
+  }
+  return res;
+}
+
+hsize_t SolTab::GetTimeIndex(double time) const {
+  if (GetAxis("time").size == 1) {
+    return 0;
+  }
+  std::vector<double> times = GetRealAxis("time");
+
+  double timeInterval = GetTimeInterval();
+
+  for (size_t i = 0; i < times.size(); ++i) {
+    if (std::abs(times[i] - time) <
+        timeInterval * 0.501) {  // 0.5 with some tolerance
+      return i;
+    }
+  }
+  throw std::runtime_error("Time " + std::to_string(time) + " not found in " +
+                           GetName());
+  return 0;
+}
+
+hsize_t SolTab::GetDirIndex(const std::string& direction_name) {
+  return GetNamedIndex(dir_map_, "dir", direction_name);
+}
+
+double SolTab::GetInterval(const std::string& axis_name, size_t start) const {
+  H5::DataSet dataset;
+  H5::DataSpace dataspace;
+  try {
+    dataset = openDataSet(axis_name);
+    dataspace = dataset.getSpace();
+  } catch (H5::GroupIException& e) {
+    throw std::runtime_error("SolTab " + GetName() + " has no axis table for " +
+                             axis_name);
+  }
+  if (dataspace.getSimpleExtentNdims() != 1) {
+    throw std::runtime_error("Invalid H5Parm: table \"" + axis_name +
+                             "\" should be onedimensional");
+  }
+
+  hsize_t dims[1];
+  dataspace.getSimpleExtentDims(dims);
+  if (dims[0] <= start + 1) {
+    throw std::runtime_error("For reading the " + axis_name +
+                             " interval, more than one value is required.");
+  }
+
+  hsize_t count[1], offset[1], memoffset[1];
+  count[0] = 2;
+  offset[0] = start;
+  memoffset[0] = 0;
+  dataspace.selectHyperslab(H5S_SELECT_SET, count, offset);
+
+  H5::DataSpace memspace(1, count);
+  memspace.selectHyperslab(H5S_SELECT_SET, count, memoffset);
+
+  // Get only two values
+  double values[2];
+  dataset.read(&values, H5::PredType::NATIVE_DOUBLE, memspace, dataspace);
+  return values[1] - values[0];
+}
+}  // namespace h5parm
+}  // namespace schaapcommon
Index: wsclean/external/schaapcommon/src/h5parm/test/CMakeLists.txt
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/test/CMakeLists.txt
@@ -0,0 +1,7 @@
+# Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+# SPDX-License-Identifier: GPL-3.0-or-later
+
+include(${SCHAAPCOMMON_SOURCE_DIR}/cmake/unittest.cmake)
+
+add_unittest(h5parm runtests.cc th5parm.cc tgridinterpolate.cc
+             tjonesparameters.cc)
Index: wsclean/external/schaapcommon/src/h5parm/test/runtests.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/test/runtests.cc
@@ -0,0 +1,6 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#define BOOST_TEST_MODULE schaapcommon_h5parm
+
+#include <boost/test/unit_test.hpp>
\ No newline at end of file
Index: wsclean/external/schaapcommon/src/h5parm/test/tgridinterpolate.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/test/tgridinterpolate.cc
@@ -0,0 +1,115 @@
+// tgridinterpolate.cc: test program for gridinterpolate
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+//
+// @author Tammo Jan Dijkema
+
+#include <boost/test/unit_test.hpp>
+
+#include "../gridinterpolate.h"
+
+using std::vector;
+
+BOOST_AUTO_TEST_SUITE(gridinterpolate)
+
+BOOST_AUTO_TEST_CASE(test_nearest_neighbor) {
+  vector<double> ax_src = {1, 3};
+  vector<double> ax_tgt = {0.5, 1.5, 2.5, 3.5};
+
+  vector<size_t> indices;
+  schaapcommon::h5parm::GetAxisIndices(ax_src, ax_tgt, indices);
+  BOOST_CHECK_EQUAL(indices.size(), ax_tgt.size());
+  BOOST_CHECK_EQUAL(indices[0], 0u);
+  BOOST_CHECK_EQUAL(indices[1], 0u);
+  BOOST_CHECK_EQUAL(indices[2], 1u);
+  BOOST_CHECK_EQUAL(indices[3], 1u);
+
+  const vector<double> x_src = {2, 4, 8, 10};
+  const vector<double> y_src = {3, 6, 12};
+  const vector<double> x_tgt = {1, 3.5, 9.5, 10};
+  const vector<double> y_tgt = {4, 10};
+  vector<double> vals_src(x_src.size() * y_src.size());
+  for (size_t i = 0; i < vals_src.size(); ++i) {
+    vals_src[i] = i;
+  }
+
+  schaapcommon::h5parm::GetAxisIndices(x_src, x_tgt, indices);
+  BOOST_CHECK_EQUAL(indices.size(), x_tgt.size());
+  BOOST_CHECK_EQUAL(indices[0], 0u);
+  BOOST_CHECK_EQUAL(indices[1], 1u);
+  BOOST_CHECK_EQUAL(indices[2], 3u);
+  BOOST_CHECK_EQUAL(indices[3], 3u);
+
+  // Row major indexing of vals_src
+  const std::vector<size_t> rm_index = {0, 2, 3, 5, 9, 11, 9, 11};
+
+  // Convert to column major indexes in vals_src
+  std::vector<size_t> cm_index;
+  for (const auto& idx : rm_index) {
+    const size_t i = idx / y_src.size();
+    const size_t j = idx % y_src.size();
+    cm_index.push_back(j * x_src.size() + i);
+  }
+
+  // y changing fastest in vals_src (row major order)
+  const std::vector<double> vals_tgt_row =
+      schaapcommon::h5parm::GridNearestNeighbor(
+          x_src, y_src, x_tgt, y_tgt, vals_src,
+          schaapcommon::h5parm::MemoryLayout::kRowMajor);
+  BOOST_REQUIRE_EQUAL(vals_tgt_row.size(), x_tgt.size() * y_tgt.size());
+
+  // x changing fastest in vals_src (col major order)
+  const std::vector<double> vals_tgt_col =
+      schaapcommon::h5parm::GridNearestNeighbor(
+          x_src, y_src, x_tgt, y_tgt, vals_src,
+          schaapcommon::h5parm::MemoryLayout::kColumnMajor);
+  BOOST_REQUIRE_EQUAL(vals_tgt_col.size(), x_tgt.size() * y_tgt.size());
+
+  for (size_t i = 0; i < vals_tgt_row.size(); ++i) {
+    BOOST_CHECK_EQUAL(vals_tgt_row[i], vals_src[rm_index[i]]);
+    BOOST_CHECK_EQUAL(vals_tgt_col[i], vals_src[cm_index[i]]);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(test_bilinear) {
+  const vector<double> x_src = {2, 4, 8, 10};
+  const vector<double> y_src = {3, 6, 12};
+  const vector<double> x_tgt = {2, 2.5, 3.5, 9.5, 10};
+  const vector<double> y_tgt = {3, 4, 10, 12};
+
+  vector<double> vals_src(x_src.size() * y_src.size());
+
+  for (size_t i = 0; i < x_src.size(); ++i) {
+    for (size_t j = 0; j < y_src.size(); ++j) {
+      size_t idx = i * y_src.size() + j;
+      // linear polynomial f(x, y) = 3*x + x*y - 2 * y + 5
+      vals_src[idx] = 3 * x_src[i] + x_src[i] * y_src[j] - 2 * y_src[j] + 5;
+    }
+  }
+
+  // Col major lay-out in combination with linear interpolation not implemented
+  BOOST_CHECK_THROW(
+      schaapcommon::h5parm::GridNearestNeighbor(
+          x_src, y_src, x_tgt, y_tgt, vals_src,
+          schaapcommon::h5parm::MemoryLayout::kColumnMajor, false),
+      std::runtime_error);
+
+  // set nearest = false to use bilinear interpolation
+  const vector<double> vals_tgt = schaapcommon::h5parm::GridNearestNeighbor(
+      x_src, y_src, x_tgt, y_tgt, vals_src,
+      schaapcommon::h5parm::MemoryLayout::kRowMajor, false);
+  BOOST_REQUIRE_EQUAL(vals_tgt.size(), x_tgt.size() * y_tgt.size());
+
+  for (size_t i = 0; i < x_tgt.size(); ++i) {
+    for (size_t j = 0; j < y_tgt.size(); ++j) {
+      size_t idx = i * y_tgt.size() + j;
+      // linear polynomial f(x, y) = 3*x + x*y - 2 * y + 5 should be reproduced
+      // in bilinear interpolation
+      const double ref_val =
+          3 * x_tgt[i] + x_tgt[i] * y_tgt[j] - 2 * y_tgt[j] + 5;
+      BOOST_CHECK_CLOSE(vals_tgt[idx], ref_val, 1e-8);
+    }
+  }
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: wsclean/external/schaapcommon/src/h5parm/test/th5parm.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/test/th5parm.cc
@@ -0,0 +1,362 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include <boost/test/unit_test.hpp>
+
+#include <array>
+#include <sstream>
+#include <vector>
+
+#include "h5parm.h"
+
+using schaapcommon::h5parm::AxisInfo;
+using schaapcommon::h5parm::H5Parm;
+using schaapcommon::h5parm::SolTab;
+
+using std::string;
+using std::vector;
+
+BOOST_AUTO_TEST_SUITE(h5parm)
+
+namespace {
+
+const size_t kNumAntennas = 3;
+const size_t kNumFrequencies = 4;
+const size_t kNumTimes = 7;
+
+void CheckAxes(SolTab& soltab, size_t ntimes) {
+  BOOST_CHECK_EQUAL(soltab.NumAxes(), size_t{3});
+  BOOST_CHECK(soltab.HasAxis("ant"));
+  BOOST_CHECK(soltab.HasAxis("time"));
+  BOOST_CHECK(soltab.HasAxis("bla"));
+  BOOST_CHECK_EQUAL(soltab.GetAxis(0).name, "ant");
+  BOOST_CHECK_EQUAL(soltab.GetAxis(1).name, "time");
+  BOOST_CHECK_EQUAL(soltab.GetAxis(2).name, "bla");
+  BOOST_CHECK_EQUAL(soltab.GetAxis(0).size, size_t{3});
+  BOOST_CHECK_EQUAL(soltab.GetAxis(1).size, ntimes);
+  BOOST_CHECK_EQUAL(soltab.GetAxis(2).size, size_t{1});
+}
+
+void InitializeH5(H5Parm& h5parm) {
+  // Add some metadata
+  vector<string> antNames;
+  vector<std::array<double, 3>> antPositions;
+  for (unsigned int i = 0; i < 5; ++i) {
+    std::stringstream antNameStr;
+    antNameStr << "Antenna" << i;
+    antNames.push_back(antNameStr.str());
+    antPositions.emplace_back();
+  }
+  h5parm.AddAntennas(antNames, antPositions);
+  h5parm.AddSources({"aaa", "bbb", "ccc", "ddd"},
+                    {std::make_pair(0.0, 0.0), std::make_pair(0.0, 1.0),
+                     std::make_pair(1.0, 1.0), std::make_pair(1.0, 0.0)});
+
+  vector<AxisInfo> axes;
+  axes.push_back(AxisInfo{"ant", 3});
+  axes.push_back(AxisInfo{"time", kNumTimes});
+  axes.push_back(AxisInfo{"bla", 1});
+  h5parm.CreateSolTab("mysol", "mytype", axes);
+
+  vector<AxisInfo> axes_freq;
+  axes_freq.push_back(AxisInfo{"ant", kNumAntennas});
+  axes_freq.push_back(AxisInfo{"freq", kNumFrequencies});
+  h5parm.CreateSolTab("mysolwithfreq", "mytype", axes_freq);
+
+  vector<AxisInfo> axes_time_first;
+  axes_time_first.push_back(AxisInfo{"ant", kNumAntennas});
+  axes_time_first.push_back(AxisInfo{"time", kNumTimes});
+  axes_time_first.push_back(AxisInfo{"freq", kNumFrequencies});
+  h5parm.CreateSolTab("timefreq", "mytype", axes_time_first);
+
+  vector<AxisInfo> axes_freq_first;
+  axes_freq_first.push_back(AxisInfo{"ant", kNumAntennas});
+  axes_freq_first.push_back(AxisInfo{"freq", kNumFrequencies});
+  axes_freq_first.push_back(AxisInfo{"time", kNumTimes});
+  h5parm.CreateSolTab("freqtime", "mytype", axes_freq_first);
+}
+
+void SetSolTabMeta(SolTab& soltab, bool set_freq_meta, bool set_time_meta) {
+  // Add metadata for stations
+  const std::vector<string> someAntNames = {"Antenna1", "Antenna12",
+                                            "Antenna123"};
+  soltab.SetAntennas(someAntNames);
+
+  if (set_freq_meta) {
+    // Add metadata for freqs;
+    const std::vector<double> freqs{130e6, 131e6, 135e6, 137e6};
+    soltab.SetFreqs(freqs);
+  }
+
+  if (set_time_meta) {
+    // Add metadata for times
+    std::vector<double> times;
+    for (size_t time = 0; time < kNumTimes; ++time) {
+      times.push_back(57878.5 + 2.0 * time);
+    }
+    soltab.SetTimes(times);
+  }
+}
+
+void FillData(H5Parm& h5parm) {
+  SolTab soltab = h5parm.GetSolTab("mysol");
+
+  // Add some data
+  vector<double> vals(kNumAntennas * kNumTimes);
+  vector<double> weights(kNumAntennas * kNumTimes);
+  for (size_t ant = 0; ant < kNumAntennas; ++ant) {
+    for (size_t time = 0; time < kNumTimes; ++time) {
+      vals[ant * kNumTimes + time] = 10 * ant + time;
+      weights[ant * kNumTimes + time] = 0.4;
+    }
+  }
+
+  soltab.SetValues(vals, weights, "CREATE with SchaapCommon-test");
+
+  SetSolTabMeta(soltab, false, true);
+}
+
+void FillDataWithFreqAxis(H5Parm& h5parm) {
+  SolTab soltab = h5parm.GetSolTab("mysolwithfreq");
+
+  // Add some data
+  const std::vector<double> vals(kNumAntennas * kNumFrequencies, 1.0);
+  const std::vector<double> weights(kNumAntennas * kNumFrequencies, 1.0);
+
+  soltab.SetValues(vals, weights, "CREATE with SchaapCommon-test");
+  SetSolTabMeta(soltab, true, false);
+}
+
+void FillDataTimeFirst(H5Parm& h5parm) {
+  SolTab soltab = h5parm.GetSolTab("timefreq");
+
+  // Add some data
+  vector<double> vals(kNumAntennas * kNumTimes * kNumFrequencies);
+  vector<double> weights(kNumAntennas * kNumTimes * kNumFrequencies, 0);
+  for (size_t ant = 0; ant < kNumAntennas; ++ant) {
+    for (size_t time = 0; time < kNumTimes; ++time) {
+      for (size_t freq = 0; freq < kNumFrequencies; ++freq) {
+        vals[ant * kNumTimes * kNumFrequencies + time * kNumFrequencies +
+             freq] = ant * time * freq;
+      }
+    }
+  }
+
+  // Add some data
+  soltab.SetValues(vals, weights, "CREATE with SchaapCommon-test");
+  SetSolTabMeta(soltab, true, true);
+}
+
+void FillDataFreqFirst(H5Parm& h5parm) {
+  SolTab soltab = h5parm.GetSolTab("freqtime");
+
+  // Add some data
+  vector<double> vals(kNumAntennas * kNumTimes * kNumFrequencies);
+  vector<double> weights(kNumAntennas * kNumTimes * kNumFrequencies, 0);
+  for (size_t ant = 0; ant < kNumAntennas; ++ant) {
+    for (size_t freq = 0; freq < kNumFrequencies; ++freq) {
+      for (size_t time = 0; time < kNumTimes; ++time) {
+        vals[ant * kNumTimes * kNumFrequencies + freq * kNumTimes + time] =
+            ant * time * freq;
+      }
+    }
+  }
+
+  // Add some data
+  soltab.SetValues(vals, weights, "CREATE with SchaapCommon-test");
+  SetSolTabMeta(soltab, true, true);
+}
+
+struct H5Fixture {
+  H5Fixture() {
+    H5Parm h5parm("tH5Parm_tmp.h5", true);
+    InitializeH5(h5parm);
+    FillData(h5parm);
+    FillDataWithFreqAxis(h5parm);
+    FillDataTimeFirst(h5parm);
+    FillDataFreqFirst(h5parm);
+  }
+
+  ~H5Fixture() { remove("tH5Parm_tmp.h5"); }
+};
+}  // namespace
+
+BOOST_AUTO_TEST_CASE(create) {
+  // Create a new H5Parm
+  H5Parm h5parm("tH5Parm_tmp.h5", true);
+
+  // Check that something is created
+  BOOST_CHECK_EQUAL(((H5::H5File&)(h5parm)).getNumObjs(), 1u);
+
+  // Check the name of the new solset "sol000"
+  BOOST_CHECK_EQUAL(h5parm.GetSolSetName(), "sol000");
+
+  InitializeH5(h5parm);
+
+  // Check that the soltab exists
+  BOOST_CHECK_EQUAL(h5parm.NumSolTabs(), 4);
+  BOOST_CHECK(h5parm.HasSolTab("mysol"));
+
+  // Check the axes
+  SolTab soltab = h5parm.GetSolTab("mysol");
+  BOOST_CHECK_EQUAL(soltab.GetType(), "mytype");
+  CheckAxes(soltab, kNumTimes);
+}
+
+BOOST_FIXTURE_TEST_CASE(new_soltab, H5Fixture) {
+  H5Parm h5parm("tH5Parm_tmp.h5", true, true, "harry");
+  BOOST_CHECK_EQUAL(h5parm.GetSolSetName(), "harry");
+  BOOST_CHECK_EQUAL(h5parm.NumSolTabs(), 0u);
+}
+
+BOOST_FIXTURE_TEST_CASE(existing_soltab, H5Fixture) {
+  H5Parm h5parm("tH5Parm_tmp.h5", false, false, "sol000");
+  BOOST_CHECK_EQUAL(h5parm.GetSolSetName(), "sol000");
+  BOOST_CHECK_EQUAL(h5parm.NumSolTabs(), 4u);
+  BOOST_CHECK(h5parm.HasSolTab("mysol"));
+  BOOST_CHECK(!h5parm.HasSolTab("nonexistingsol"));
+}
+
+BOOST_FIXTURE_TEST_CASE(axes, H5Fixture) {
+  H5Parm h5parm("tH5Parm_tmp.h5", false, false, "sol000");
+
+  // Check the axes
+  SolTab soltab = h5parm.GetSolTab("mysol");
+  BOOST_CHECK_EQUAL(soltab.GetType(), "mytype");
+  CheckAxes(soltab, kNumTimes);
+
+  BOOST_CHECK_EQUAL(h5parm.GetNumSources(), 4u);
+
+  // Return and check nearest source
+  BOOST_CHECK_EQUAL(h5parm.GetNearestSource(0.49, 0.49), "aaa");
+  BOOST_CHECK_EQUAL(h5parm.GetNearestSource(1.0, 0.51), "ccc");
+  BOOST_CHECK_EQUAL(h5parm.GetNearestSource(1.0, 0.49), "ddd");
+
+  double starttime = 57878.49999;
+  hsize_t starttimeindex = soltab.GetTimeIndex(starttime);
+  vector<double> val = soltab.GetValues("Antenna12", starttimeindex, kNumTimes,
+                                        1, 0, 4, 0, 4, 0);
+  BOOST_CHECK_CLOSE(val[0], 10., 1e-8);
+  BOOST_CHECK_CLOSE(val[1], 11., 1e-8);
+  BOOST_CHECK_CLOSE(val[2], 12., 1e-8);
+  BOOST_CHECK_CLOSE(val[3], 13., 1e-8);
+
+  starttime = 57880.5;
+  starttimeindex = soltab.GetTimeIndex(starttime);
+  BOOST_CHECK_EQUAL(starttimeindex, hsize_t{1});
+  vector<double> val2 =
+      soltab.GetValues("Antenna123", starttimeindex, 2, 2, 0, 4, 0, 4, 0);
+
+  BOOST_CHECK_CLOSE(val2[0], 21., 1e-8);
+  BOOST_CHECK_CLOSE(val2[1], 23., 1e-8);
+  BOOST_CHECK_CLOSE(soltab.GetTimeInterval(), 2., 1e-8);
+
+  vector<string> antennas = soltab.GetStringAxis("ant");
+  BOOST_CHECK_EQUAL(antennas.size(), size_t{3});
+  BOOST_CHECK_EQUAL(antennas[0], "Antenna1");
+  BOOST_CHECK_EQUAL(antennas[1], "Antenna12");
+  BOOST_CHECK_EQUAL(antennas[2], "Antenna123");
+}
+
+BOOST_FIXTURE_TEST_CASE(grid_interpolation, H5Fixture) {
+  H5Parm h5parm("tH5Parm_tmp.h5", false, false, "sol000");
+  SolTab& soltab = h5parm.GetSolTab("mysol");
+
+  const vector<double> freqs{130e6, 131e6};
+
+  const vector<double> times1{57878.5, 57880.5, 57882.5, 57884.5,
+                              57886.5, 57888.5, 57890.5};
+
+  vector<double> newgridvals =
+      soltab.GetValuesOrWeights("val", "Antenna1", times1, freqs, 0, 0, true);
+  BOOST_REQUIRE_EQUAL(newgridvals.size(), times1.size() * freqs.size());
+  size_t idx = 0;
+  for (size_t time = 0; time < times1.size(); ++time) {
+    for (size_t freq = 0; freq < freqs.size(); ++freq) {
+      BOOST_CHECK_CLOSE(newgridvals[idx], time, 1e-8);
+      ++idx;
+    }
+  }
+
+  vector<double> times2;
+  for (size_t time = 0; time < 3 * times1.size() + 2; ++time) {
+    times2.push_back(57878.5 + 2.0 * time / 3.);
+  }
+  newgridvals =
+      soltab.GetValuesOrWeights("val", "Antenna1", times2, freqs, 0, 0, true);
+  BOOST_REQUIRE_EQUAL(newgridvals.size(), times2.size() * freqs.size());
+  idx = 0;
+  for (size_t time = 0; time < times2.size(); ++time) {
+    for (size_t freq = 0; freq < freqs.size(); ++freq) {
+      BOOST_CHECK_CLOSE(newgridvals[idx],
+                        std::min((time + 1) / 3, times1.size() - 1), 1e-8);
+      ++idx;
+    }
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(interpolate_single_time, H5Fixture) {
+  H5Parm h5parm("tH5Parm_tmp.h5", false, false, "sol000");
+  SolTab& soltab = h5parm.GetSolTab("mysol");
+
+  const vector<double> freqs{130e6, 131e6};
+  const vector<double> times{57000, 57878.7, 57880.3, 57890.3, 58000};
+  const vector<double> expected_nearest{10, 10, 11, 16, 16};
+  const vector<double> expected_bilinear{10.0, 10.1, 10.9, 15.9, 16.0};
+
+  for (size_t time = 0; time < times.size(); ++time) {
+    const vector<double> nearest_vals = soltab.GetValuesOrWeights(
+        "val", "Antenna12", {times[time]}, freqs, 0, 0, true);
+    const vector<double> bilinear_vals = soltab.GetValuesOrWeights(
+        "val", "Antenna12", {times[time]}, freqs, 0, 0, false);
+
+    BOOST_REQUIRE_EQUAL(nearest_vals.size(), 1 * freqs.size());
+    BOOST_REQUIRE_EQUAL(bilinear_vals.size(), 1 * freqs.size());
+
+    for (size_t freq = 0; freq < freqs.size(); ++freq) {
+      BOOST_CHECK_CLOSE(nearest_vals[freq], expected_nearest[time], 1e-8);
+      BOOST_CHECK_CLOSE(bilinear_vals[freq], expected_bilinear[time], 1e-8);
+    }
+  }
+}
+
+BOOST_FIXTURE_TEST_CASE(freq_interval_and_index, H5Fixture) {
+  H5Parm h5parm("tH5Parm_tmp.h5", false, false, "sol000");
+  const SolTab& soltab = h5parm.GetSolTab("mysolwithfreq");
+  BOOST_CHECK_CLOSE(soltab.GetFreqInterval(0), 1.0e6, 1.0e-8);
+  BOOST_CHECK_CLOSE(soltab.GetFreqInterval(1), 4.0e6, 1.0e-8);
+  BOOST_CHECK_CLOSE(soltab.GetFreqInterval(2), 2.0e6, 1.0e-8);
+
+  BOOST_CHECK_THROW(soltab.GetFreqIndex(128.0e6),
+                    std::runtime_error);               // Too far from lowest
+  BOOST_CHECK_EQUAL(soltab.GetFreqIndex(129.1e6), 0);  // closest to 130e6
+  BOOST_CHECK_EQUAL(soltab.GetFreqIndex(130.4e6), 0);  // closest to 130e6
+  BOOST_CHECK_EQUAL(soltab.GetFreqIndex(130.6e6), 1);  // closest to 131e6
+  BOOST_CHECK_EQUAL(soltab.GetFreqIndex(136.1e6), 3);  // closest to 137e6
+  BOOST_CHECK_EQUAL(soltab.GetFreqIndex(137.0e6), 3);  // closest to 137e6
+  BOOST_CHECK_EQUAL(soltab.GetFreqIndex(137.8e6), 3);  // closest to 137e6
+  BOOST_CHECK_THROW(soltab.GetFreqIndex(150.0e6),
+                    std::runtime_error);  // Too far from highest
+}
+
+BOOST_FIXTURE_TEST_CASE(axis_ordering, H5Fixture) {
+  H5Parm h5parm("tH5Parm_tmp.h5", false, false, "sol000");
+
+  SolTab soltab_tf = h5parm.GetSolTab("timefreq");
+  SolTab soltab_ft = h5parm.GetSolTab("freqtime");
+
+  const vector<double> freqs{130e6, 135e6, 131e6};
+  const vector<double> times{57000, 57878.7, 57880.3, 57890.3, 58000};
+
+  const vector<double> nearest_tf = soltab_tf.GetValuesOrWeights(
+      "val", "Antenna12", times, freqs, 0, 0, true);
+  const vector<double> nearest_ft = soltab_ft.GetValuesOrWeights(
+      "val", "Antenna12", times, freqs, 0, 0, true);
+
+  // GetValuesOrWeights should make sure that frequency is the fastest changing
+  // index, even when in the underlying h5 array time was changing fastest
+  BOOST_CHECK_EQUAL_COLLECTIONS(nearest_tf.begin(), nearest_tf.end(),
+                                nearest_ft.begin(), nearest_ft.end());
+}
+
+BOOST_AUTO_TEST_SUITE_END()
Index: wsclean/external/schaapcommon/src/h5parm/test/tjonesparameters.cc
===================================================================
--- /dev/null
+++ wsclean/external/schaapcommon/src/h5parm/test/tjonesparameters.cc
@@ -0,0 +1,378 @@
+// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
+// SPDX-License-Identifier: GPL-3.0-or-later
+
+#include <boost/test/unit_test.hpp>
+
+#include "jonesparameters.h"
+#include "h5parm.h"
+
+using schaapcommon::h5parm::AxisInfo;
+using schaapcommon::h5parm::H5Parm;
+using schaapcommon::h5parm::JonesParameters;
+using schaapcommon::h5parm::SolTab;
+
+const std::vector<double> kFreqs{130e6, 131e6};
+const std::vector<double> kTimes{0., 1.};
+const unsigned int kNAnts = 4;
+const JonesParameters::InterpolationType kInterpolationType =
+    JonesParameters::InterpolationType::LINEAR;
+const hsize_t kDirection = 42;
+
+class SolTabMock : public SolTab {
+ public:
+  SolTabMock() : called(0) {}
+  std::vector<double> GetValuesOrWeights(const std::string& val_or_weight,
+                                         const std::string& ant_name,
+                                         const std::vector<double>& times,
+                                         const std::vector<double>& freqs,
+                                         unsigned int pol, unsigned int dir,
+                                         bool nearest) override {
+    ++called;
+    auto res = std::vector<double>(kNAnts, 200.);
+
+    if (ant_name.back() - '0' >= int(kNAnts)) {
+      // Number represented by last character of ant_name is >= kNants
+      // E.g. an antenna 'Antenna5' is requested which is not in the soltab
+      throw(std::runtime_error("SolTab has no element Antenna" +
+                               std::string(1, ant_name.back()) +
+                               " in antenna"));
+    }
+
+    if (val_or_weight == "val") {
+      res.back() = 100.;
+    } else {
+      res.back() = 0.;
+    }
+    return res;
+  }
+
+  int called;
+};
+
+JonesParameters PrepareJonesParameters(JonesParameters::CorrectType ct,
+                                       bool invert = false,
+                                       float sigma_mmse = 0.,
+                                       unsigned int parm_size = 0) {
+  std::vector<std::string> antNames;
+  for (unsigned int i = 0; i < kNAnts; ++i) {
+    std::stringstream antNameStr;
+    antNameStr << "Antenna" << i;
+    antNames.push_back(antNameStr.str());
+  }
+
+  SolTabMock mock = SolTabMock();
+  SolTabMock mock2 = SolTabMock();
+
+  JonesParameters jones(kFreqs, kTimes, antNames, ct, kInterpolationType,
+                        kDirection, &mock, &mock2, invert, sigma_mmse,
+                        parm_size);
+  return jones;
+}
+
+BOOST_AUTO_TEST_SUITE(jonesparameters)
+
+BOOST_AUTO_TEST_CASE(check_parse_list) {
+  std::vector<std::string> list0 = JonesParameters::ParseList("abc,def");
+  BOOST_CHECK_EQUAL(list0[0], "abc");
+  BOOST_CHECK_EQUAL(list0[1], "def");
+  BOOST_CHECK_THROW(std::vector<std::string> list1 =
+                        JonesParameters::ParseList("abc,def,ghi"),
+                    std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_gain) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::GAIN);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_EQUAL(parms.shape()[1], kNAnts);
+  BOOST_CHECK_EQUAL(parms.shape()[2], kTimes.size() * kFreqs.size());
+  // Amplitude and phase are 200
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 97.437, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), -174.659, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_scalar_gain) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::SCALARGAIN);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_EQUAL(parms.shape()[1], kNAnts);
+  BOOST_CHECK_EQUAL(parms.shape()[2], kTimes.size() * kFreqs.size());
+  // Amplitude and phase are 200
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 97.437, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), -174.659, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_fulljones) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::FULLJONES, true, 1.);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 4);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 0.5006091, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 0.00108991, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_tec) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::TEC, false, 0., 1U);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), -0.993747, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 0.1116511, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_tec2) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::TEC, true, 0., 2U);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), -0.993747, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), -0.1116511, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_r_angle) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::ROTATIONANGLE);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 4);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 0.487187, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 0., 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_r_angle_inverted) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::ROTATIONANGLE, true);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 0.487187, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 0.0, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_r_measure) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::ROTATIONMEASURE);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 4);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), -0.185403, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 0., 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_r_measure_inverted) {
+  JonesParameters jones = PrepareJonesParameters(
+      JonesParameters::CorrectType::ROTATIONMEASURE, true, 0.5, 4);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), -0.185403, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 0.0, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_phase) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::PHASE);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 0.487187, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), -0.87329, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_scalar_phase) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::SCALARPHASE);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 0.487187, 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), -0.87329, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_amplitude) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::AMPLITUDE);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 200., 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 0., 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_scalar_amplitude) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::SCALARAMPLITUDE);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 200., 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 0., 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_clock) {
+  JonesParameters jones = PrepareJonesParameters(
+      JonesParameters::CorrectType::CLOCK, false, 0., 1U);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 1., 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 2.08822e-06, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_clock2) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::CLOCK, true, 50, 2U);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 1., 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), -2.08822e-06, 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_gain_re_im) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::GAIN_RE_IM);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 200., 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 200., 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(make_complex_fulljones_re_im) {
+  JonesParameters jones =
+      PrepareJonesParameters(JonesParameters::CorrectType::FULLJONES_RE_IM);
+  const auto parms = jones.GetParms();
+
+  BOOST_CHECK_EQUAL(parms.shape()[0], 4);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).real(), 200., 1e-3);
+  BOOST_CHECK_CLOSE(parms(0, 0, 0).imag(), 200., 1e-3);
+}
+
+BOOST_AUTO_TEST_CASE(fulljones_with_nullptr) {
+  std::vector<std::string> antNames;
+  for (unsigned int i = 0; i < kNAnts; ++i) {
+    std::stringstream antNameStr;
+    antNameStr << "Antenna" << i;
+    antNames.push_back(antNameStr.str());
+  }
+
+  SolTabMock mock = SolTabMock();
+
+  BOOST_CHECK_THROW(
+      JonesParameters jones(kFreqs, kTimes, antNames,
+                            JonesParameters::CorrectType::FULLJONES,
+                            kInterpolationType, kDirection, &mock, nullptr),
+      std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(missing_antenna_error) {
+  std::vector<std::string> antNames;
+  for (unsigned int i = 0; i < kNAnts + 1; ++i) {
+    std::stringstream antNameStr;
+    antNameStr << "Antenna" << i;
+    antNames.push_back(antNameStr.str());
+  }
+
+  SolTabMock mock = SolTabMock();
+
+  BOOST_CHECK_THROW(
+      JonesParameters jones(kFreqs, kTimes, antNames,
+                            JonesParameters::CorrectType::AMPLITUDE,
+                            kInterpolationType, kDirection, &mock, nullptr),
+      std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(missing_antenna_flag) {
+  std::vector<std::string> antNames;
+  for (unsigned int i = 0; i < kNAnts + 1; ++i) {
+    std::stringstream antNameStr;
+    antNameStr << "Antenna" << i;
+    antNames.push_back(antNameStr.str());
+  }
+
+  SolTabMock mock = SolTabMock();
+
+  JonesParameters jones(kFreqs, kTimes, antNames,
+                        JonesParameters::CorrectType::AMPLITUDE,
+                        kInterpolationType, kDirection, &mock, nullptr, false,
+                        0, 0, JonesParameters::MissingAntennaBehavior::kFlag);
+
+  const auto parms = jones.GetParms();
+  BOOST_CHECK_EQUAL(parms.shape()[1], kNAnts + 1);
+  BOOST_CHECK(std::isfinite(parms(0, kNAnts - 1, 0).real()));
+  BOOST_CHECK(!std::isfinite(parms(0, kNAnts, 0).real()));
+}
+
+BOOST_AUTO_TEST_CASE(missing_antenna_unit_diag) {
+  std::vector<std::string> antNames;
+  for (unsigned int i = 0; i < kNAnts + 1; ++i) {
+    std::stringstream antNameStr;
+    antNameStr << "Antenna" << i;
+    antNames.push_back(antNameStr.str());
+  }
+
+  SolTabMock mock = SolTabMock();
+
+  JonesParameters jones(kFreqs, kTimes, antNames,
+                        JonesParameters::CorrectType::AMPLITUDE,
+                        kInterpolationType, kDirection, &mock, nullptr, false,
+                        0, 0, JonesParameters::MissingAntennaBehavior::kUnit);
+
+  const auto parms = jones.GetParms();
+  BOOST_CHECK_EQUAL(parms.shape()[0], 2);
+  BOOST_CHECK_EQUAL(parms.shape()[1], kNAnts + 1);
+  BOOST_CHECK_EQUAL(parms(0, kNAnts, 0).real(), 1.);
+  BOOST_CHECK_EQUAL(parms(1, kNAnts, 0).real(), 1.);
+  BOOST_CHECK_EQUAL(parms(0, kNAnts, 0).imag(), 0.);
+}
+
+BOOST_AUTO_TEST_CASE(missing_antenna_unit_full) {
+  std::vector<std::string> antNames;
+  for (unsigned int i = 0; i < kNAnts + 1; ++i) {
+    std::stringstream antNameStr;
+    antNameStr << "Antenna" << i;
+    antNames.push_back(antNameStr.str());
+  }
+
+  SolTabMock mock = SolTabMock();
+
+  JonesParameters jones(kFreqs, kTimes, antNames,
+                        JonesParameters::CorrectType::ROTATIONANGLE,
+                        kInterpolationType, kDirection, &mock, nullptr, false,
+                        0, 0, JonesParameters::MissingAntennaBehavior::kUnit);
+
+  const auto parms = jones.GetParms();
+  BOOST_CHECK_EQUAL(parms.shape()[0], 4);
+  BOOST_CHECK_EQUAL(parms.shape()[1], kNAnts + 1);
+  BOOST_CHECK_EQUAL(parms(0, kNAnts, 0).real(), 1.);
+  BOOST_CHECK_EQUAL(parms(0, kNAnts, 0).imag(), 0.);
+  BOOST_CHECK_EQUAL(parms(1, kNAnts, 0).real(), 0.);
+  BOOST_CHECK_EQUAL(parms(1, kNAnts, 0).imag(), 0.);
+  BOOST_CHECK_EQUAL(parms(2, kNAnts, 0).real(), 0.);
+  BOOST_CHECK_EQUAL(parms(2, kNAnts, 0).imag(), 0.);
+  BOOST_CHECK_EQUAL(parms(3, kNAnts, 0).real(), 1.);
+  BOOST_CHECK_EQUAL(parms(3, kNAnts, 0).imag(), 0.);
+}
+
+BOOST_AUTO_TEST_CASE(correcttype_to_str) {
+  std::vector<std::string> correction_names = {
+      "gain",        "fulljones",       "tec",           "clock",
+      "scalarphase", "scalaramplitude", "rotationangle", "rotationmeasure",
+      "phase",       "amplitude"};
+
+  for (const std::string& correction_name : correction_names) {
+    JonesParameters::CorrectType correction_type =
+        JonesParameters::StringToCorrectType(correction_name);
+    std::string correction_name_back =
+        JonesParameters::CorrectTypeToString(correction_type);
+    BOOST_CHECK_EQUAL(correction_name, correction_name_back);
+  }
+  BOOST_CHECK_THROW(JonesParameters::StringToCorrectType("nosuchcorrection"),
+                    std::runtime_error);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
